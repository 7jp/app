{"version":3,"sources":["webpack:///./node_modules/codemirror/addon/search/search.js","webpack:///./node_modules/codemirror/mode/sass/sass.js","webpack:///./node_modules/codemirror/addon/search/match-highlighter.js","webpack:///./node_modules/codemirror/addon/dialog/dialog.js","webpack:///./node_modules/codemirror/addon/selection/active-line.js","webpack:///./node_modules/codemirror/addon/hint/javascript-hint.js","webpack:///./node_modules/codemirror/mode/php/php.js","webpack:///./node_modules/codemirror/mode/clike/clike.js","webpack:///./src/interfaces/code/input.vue?b38b","webpack:///./node_modules/codemirror/lib/codemirror.js","webpack:///./node_modules/codemirror/mode/pug/pug.js","webpack:///./node_modules/codemirror/mode/vue/vue.js","webpack:///./node_modules/codemirror/addon/search/matchesonscrollbar.js","webpack:///./node_modules/codemirror/addon/comment/comment.js","webpack:///./node_modules/codemirror/addon/mode/simple.js","webpack:///./node_modules/codemirror/mode/stylus/stylus.js","webpack:///./node_modules/codemirror/mode/css/css.js","webpack:///./node_modules/codemirror/addon/edit/matchbrackets.js","webpack:///./node_modules/@directus/extension-toolkit/mixins/interface.js","webpack:///./node_modules/vue-codemirror/dist/vue-codemirror.js","webpack:///./node_modules/codemirror/addon/selection/mark-selection.js","webpack:///./node_modules/codemirror/keymap/sublime.js","webpack:///./node_modules/codemirror/addon/hint/show-hint.js","webpack:///./node_modules/codemirror/addon/scroll/annotatescrollbar.js","webpack:///./node_modules/codemirror/addon/mode/overlay.js","webpack:///./node_modules/codemirror/mode/coffeescript/coffeescript.js","webpack:///./node_modules/codemirror/addon/search/searchcursor.js","webpack:///./node_modules/codemirror/mode/xml/xml.js","webpack:///./node_modules/codemirror/mode/htmlmixed/htmlmixed.js","webpack:///./src/interfaces/code/input.vue?20d5","webpack:///src/interfaces/code/input.vue","webpack:///./src/interfaces/code/input.vue?0ad0","webpack:///./src/interfaces/code/input.vue","webpack:///./node_modules/codemirror/mode/handlebars/handlebars.js","webpack:///./node_modules/codemirror/addon/mode/multiplex.js","webpack:///./node_modules/codemirror/addon/display/autorefresh.js","webpack:///./node_modules/codemirror/mode/javascript/javascript.js"],"names":["mod","__webpack_require__","CodeMirror","searchOverlay","query","caseInsensitive","RegExp","replace","global","source","ignoreCase","token","stream","lastIndex","pos","match","exec","string","index","length","skipToEnd","SearchState","this","posFrom","posTo","lastQuery","overlay","getSearchState","cm","state","search","queryCaseInsensitive","toLowerCase","getSearchCursor","caseFold","multiline","persistentDialog","text","deflt","onEnter","onKeyDown","openDialog","value","selectValueOnOpen","closeOnEnter","onClose","clearSearch","dialog","shortText","f","prompt","confirmDialog","fs","openConfirm","confirm","parseString","_","ch","parseQuery","isRE","indexOf","e","test","startSearch","queryText","removeOverlay","addOverlay","showMatchesOnScrollbar","annotate","clear","doSearch","rev","persistent","immediate","findNext","q","getSelection","hiding","searchNext","event","e_stop","getCursor","style","opacity","shiftKey","to","line","document","querySelector","display","wrapper","getBoundingClientRect","bottom","cursorCoords","top","getQueryDialog","keyName","extra","getOption","cmd","keyMap","execCommand","operation","callback","cursor","find","Pos","lastLine","firstLine","setSelection","from","scrollIntoView","phrase","getReplaceQueryDialog","getReplacementQueryDialog","getDoReplaceConfirm","replaceAll","getRange","i","all","dialogText","advance","start","doReplace","commands","findPersistent","findPersistentNext","findPersistentPrev","findPrev","defineMode","config","cssMode","mimeModes","propertyKeywords","colorKeywords","valueKeywords","fontProperties","tokenRegexp","words","join","word","keywords","keywordsRegexp","operators","opRegexp","pseudoElementsRegexp","isEndLine","peek","urlTokens","next","tokenizer","tokenBase","eatSpace","buildStringTokenizer","comment","indentation","multiLine","sol","skipTo","quote","greedy","stringTokenizer","nextChar","peekChar","previousChar","charAt","endingString","cursorHalf","buildInterpolationTokenizer","currentTokenizer","indent","indentCount","lastScopeOffset","scopes","offset","currentOffset","indentUnit","unshift","dedent","shift","eatWhile","current","hasOwnProperty","prevProp","prop","tokenLexer","startOfToken","withCurrentIndent","newScopes","scope","push","startState","type","definedVars","definedMixins","lastToken","content","defineMIME","defaults","minChars","delay","wordsOnly","annotateScrollbar","showToken","trim","State","options","name","timeout","matchesonscroll","active","cursorActivity","matchHighlighter","hasFocus","scheduleHighlight","onFocus","clearTimeout","setTimeout","highlightMatches","hasBoundary","makeOverlay","searchFor","className","somethingSelected","isWord","selection","re","cur","getLine","end","slice","str","chr","boundariesAround","defineOption","val","old","Init","off","on","dialogDiv","template","wrap","getWrapperElement","appendChild","createElement","innerHTML","addClass","closeNotification","newVal","currentNotificationClose","defineExtension","closed","me","close","inp","rmClass","parentNode","removeChild","focus","button","getElementsByTagName","select","onInput","onKeyUp","keyCode","blur","closeOnBlur","callbacks","buttons","blurring","b","e_preventDefault","doneTimer","duration","WRAP_CLASS","BACK_CLASS","GUTT_CLASS","clearActiveLines","activeLines","removeLineClass","sameArray","a","updateActiveLines","ranges","range","option","nonEmpty","anchor","head","empty","getLineHandleVisualStart","addLineClass","selectionChange","sel","prev","listSelections","forEach","arr","arrayContains","item","Array","prototype","scriptHint","editor","getToken","innerMode","getMode","mode","helperType","tprop","context","list","getCompletions","javascriptHint","javascriptKeywords","getTokenAt","getCoffeeScriptToken","coffeescriptHint","coffeescriptKeywords","registerHelper","stringProps","split","arrayProps","funcProps","forAllProps","obj","Object","getOwnPropertyNames","getPrototypeOf","o","found","globalScope","window","maybeAdd","lastIndexOf","gatherCompletions","Function","base","pop","additionalContext","useGlobalScope","jQuery","v","localVars","globalVars","matchSequence","escapes","phpString","patterns","tokenize","closing","phpString_","escaped","eol","tokStack","phpKeywords","phpAtoms","phpBuiltin","phpConfig","blockKeywords","defKeywords","atoms","builtin","multiLineStrings","hooks","$","<","before","quoted","eat","delim","#","/","\"","_stream","{","}","parserConfig","htmlMode","phpMode","dispatch","isPHP","curMode","pending","php","curState","html","m","openPHP","backUp","startOpen","copyState","htmlNew","phpNew","textAfter","blockCommentStart","blockCommentEnd","lineComment","Context","indented","column","info","align","pushContext","col","popContext","t","typeBefore","prevToken","typeAtEndOfLine","isTopScope","contains","propertyIsEnumerable","curPunc","isDefKeyword","statementIndentUnit","dontAlignCalls","types","indentStatements","indentSwitch","namespaceSeparator","isPunctuationChar","numberStart","number","isOperatorChar","isIdentifierChar","isReservedIdentifier","result","tokenString","tokenComment","maybeEnd","maybeEOL","typeFirstDefinitions","basecolumn","startOfLine","ctx","undefined","styleDefs","Pass","firstChar","dontIndentStatements","hook","switchBlock","allmanIndentation","electricInput","blockCommentContinue","fold","cKeywords","basicCTypes","basicObjCTypes","cTypes","identifier","objCTypes","cBlockKeywords","cDefKeywords","cppHook","pointerHook","cIsReservedIdentifier","cpp14Literal","cpp11StringHook","cpp11RawStringDelim","tokenRawString","cppLooksLikeConstructor","lastTwo","tokenAtString","def","mimes","add","tokenTripleString","tokenNestedComment","depth","tokenKotlinString","tripleString","*","modeProps","u","U","L","R","0","1","2","3","4","5","6","7","8","9","@","'","=","cx","closeBrackets","pairs","triples","intendSwitch","tokenCeylonString","first","toUpperCase","`","_node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_index_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_lib_loader_js_ref_8_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_input_vue_vue_type_style_index_0_id_2d72df86_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0__","_node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_index_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_lib_loader_js_ref_8_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_input_vue_vue_type_style_index_0_id_2d72df86_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0___default","n","factory","module","exports","userAgent","navigator","platform","gecko","ie_upto10","ie_11up","edge","ie","ie_version","documentMode","webkit","qtwebkit","chrome","presto","safari","vendor","mac_geMountainLion","phantom","ios","android","mobile","mac","chromeOS","windows","presto_version","Number","flipCtrlCmd","captureRightClick","classTest","cls","node","after","removeChildren","count","childNodes","firstChild","removeChildrenAndAdd","parent","elt","tag","cssText","createTextNode","eltP","setAttribute","child","nodeType","host","activeElt","activeElement","body","shadowRoot","joinClasses","as","createRange","endNode","r","setEnd","setStart","createTextRange","moveToElementText","collapse","moveEnd","moveStart","selectInput","bind","args","call","arguments","apply","copyObj","target","overwrite","countColumn","tabSize","startIndex","startValue","nextTab","selectionStart","selectionEnd","_e","Delayed","id","array","set","ms","scrollerGap","toString","sel_dontScroll","scroll","sel_mouse","origin","sel_move","findColumn","goal","skipped","Math","min","spaceStrs","spaceStr","lst","map","out","insertSorted","score","priority","splice","nothing","createObj","props","inst","create","nonASCIISingleCaseWordChar","isWordCharBasic","isWordChar","helper","isEmpty","extendingChars","isExtendingChar","charCodeAt","skipExtendingChars","dir","findFirst","pred","midF","mid","ceil","floor","Display","place","doc","input","d","scrollbarFiller","gutterFiller","lineDiv","selectionDiv","cursorDiv","measure","lineMeasure","lineSpace","lines","mover","sizer","sizerWidth","heightForcer","gutters","lineGutter","scroller","zIndex","paddingRight","draggable","viewFrom","viewTo","reportedViewFrom","reportedViewTo","view","renderedView","externalMeasured","viewOffset","lastWrapHeight","lastWrapWidth","updateLineNumbers","nativeBarWidth","barHeight","barWidth","scrollbarsClipped","lineNumWidth","lineNumInnerWidth","lineNumChars","alignWidgets","cachedCharWidth","cachedTextHeight","cachedPaddingH","maxLine","maxLineLength","maxLineChanged","wheelDX","wheelDY","wheelStartX","wheelStartY","selForContextMenu","activeTouch","init","size","Error","chunk","children","sz","chunkSize","getBetween","iter","getLines","updateLineHeight","height","diff","lineNo","no","lineAtHeight","h","outer","i$1","lh","isLine","l","lineNumberFor","String","lineNumberFormatter","firstLineNumber","sticky","cmp","equalCursorPos","copyPos","x","maxPos","minPos","clipLine","max","clipPos","last","clipToLen","linelen","clipPosArray","sawReadOnlySpans","sawCollapsedSpans","seeReadOnlySpans","seeCollapsedSpans","MarkedSpan","marker","getMarkedSpanFor","spans","span","removeMarkedSpan","addMarkedSpan","markedSpans","concat","attachLine","markedSpansBefore","startCh","isInsert","nw","startsBefore","inclusiveLeft","insertLeft","endsAfter","inclusiveRight","markedSpansAfter","endCh","stretchSpansOverChange","change","full","oldFirst","oldLast","sameLine","span$1","found$1","clearEmptySpans","newMarkers","gapMarkers","gap","i$2","i$3","clearWhenEmpty","removeReadOnlyRanges","markers","mark","readOnly","parts","mk","j","p","newParts","dfrom","dto","detachMarkedSpans","detachLine","attachMarkedSpans","extraLeft","extraRight","compareCollapsedMarkers","lenDiff","aPos","bPos","fromCmp","toCmp","collapsedSpanAtSide","sps","sp","collapsed","collapsedSpanAtStart","collapsedSpanAtEnd","collapsedSpanAround","conflictingCollapsedRange","lineNo$$1","visualLine","merged","visualLineEnd","visualLineContinued","visualLineNo","lineN","vis","visualLineEndNo","lineIsHidden","widgetNode","lineIsHiddenInner","heightAtLine","lineObj","lineLength","len","findMaxLine","iterateBidiSections","order","part","level","bidiOther","getBidiPartAt","bidiOrdering","lowTypes","arabicTypes","charType","code","bidiRE","isNeutral","isStrong","countsAsLeft","countsAsNum","BidiSpan","direction","outerType","type$1","prev$1","type$2","i$4","type$3","i$5","cur$1","type$4","i$6","end$1","replace$1","j$1","i$7","at","j$2","nstart","reverse","getOrder","noHandlers","emitter","addEventListener","attachEvent","map$$1","_handlers","getHandlers","removeEventListener","detachEvent","signal","handlers","signalDOMEvent","override","preventDefault","defaultPrevented","e_defaultPrevented","codemirrorIgnore","signalCursorActivity","curOp","cursorActivityHandlers","hasHandler","eventMixin","ctor","returnValue","e_stopPropagation","stopPropagation","cancelBubble","e_target","srcElement","e_button","which","ctrlKey","zwspSupported","badBidiRects","dragAndDrop","div","zeroWidthElement","offsetHeight","offsetWidth","hasBadBidiRects","txt","r0","r1","left","right","splitLinesAuto","nl","rt","hasSelection","te","range$$1","ownerDocument","parentElement","compareEndPoints","hasCopyEvent","oncopy","badZoomedRects","hasBadZoomedRects","normal","fromRange","abs","modes","dependencies","mime","spec","resolveMode","mfactory","modeObj","modeExtensions","exts","prop$1","extendMode","properties","nstate","a1","a2","StringStream","lineOracle","lastColumnPos","lastColumnValue","lineStart","ok","this$1","pattern","consume","cased","substr","hideFirstChars","inner","lookAhead","oracle","baseToken","SavedContext","maxLookAhead","baseTokens","baseTokenPos","highlightLine","forceToEnd","st","modeGen","lineClasses","runMode","loop","overlays","i_end","opaque","styles","classes","bgClass","textClass","getLineStyles","updateFrontier","getContextBefore","resetState","maxHighlightLength","stateAfter","save","styleClasses","highlightFrontier","modeFrontier","precise","findStartLine","saved","fromSaved","processLine","nextLine","startAt","callBlankLine","readToken","blankLine","copy","Token","takeToken","asArray","tokens","extractLineClasses","output","lineClass","flattenSpans","curStart","curStyle","addModeClass","mName","minindent","minline","lim","retreatFrontier","Line","estimateHeight","updateLine","estHeight","cleanUpLine","styleToClassCache","styleToClassCacheWithMode","interpretTokenStyle","cache","buildLineContent","lineView","builder","pre","trailingSpace","splitSpaces","rest","addToken","buildToken","buildTokenBadBidi","allowFrontierUpdate","insertLineContent","maps","caches","lastChild","defaultSpecialCharPlaceholder","title","startStyle","endStyle","css","attributes","displayText","special","specialChars","mustWrap","createDocumentFragment","txt$1","tabWidth","specialCharPlaceholder","fullStyle","attr","trailingBefore","spaceBefore","buildCollapsedSpan","ignoreWidget","widget","needsContentAttribute","setUneditable","allText","spanStyle","spanEndStyle","spanStartStyle","nextChange","Infinity","foundBookmarks","endStyles","upto","tokenText","LineView","hidden","buildViewArray","nextPos","operationGroup","pushOperation","op","ops","ownsGroup","delayedCallbacks","fireCallbacksForOps","group","cursorActivityCalled","finishOperation","endCb","orphanDelayedCallbacks","signalLater","fireOrphanDelayed","delayed","updateLineForChanges","dims","changes","updateLineText","updateLineGutter","updateLineClasses","updateLineWidgets","ensureLineWrapped","replaceChild","updateLineBackground","background","insertBefore","getLineContent","ext","built","wrapClass","gutter","gutterBackground","gutterClass","fixedGutter","fixedPos","gutterTotalWidth","gutterMarkers","lineNumbers","wrap$1","gutterWrap","lineNumber","gutterLeft","k","gutterWidth","alignable","nextSibling","insertLineWidgets","buildLineElement","insertLineWidgetsFor","allowAbove","widgets","ws","handleMouseEvents","positionLineWidget","above","noHScroll","width","wrapperWidth","coverGutter","paddingLeft","position","marginLeft","widgetHeight","parentStyle","clientWidth","eventInWidget","getAttribute","paddingTop","offsetTop","paddingVert","paddingH","getComputedStyle","currentStyle","data","parseInt","isNaN","scrollGap","displayWidth","displayHeight","clientHeight","ensureLineHeights","rect","wrapping","lineWrapping","curWidth","heights","rects","getClientRects","mapFromLineView","updateExternalMeasurement","measureChar","bias","measureCharPrepared","prepareMeasureForLine","findViewForLine","findViewIndex","getDimensions","forceUpdate","hasHeights","prepared","varHeight","key","measureCharInner","bogus","rtop","rbottom","measureText","nullRect","nodeAndOffsetInLineMap","mStart","mEnd","coverStart","coverEnd","getUsefulRect","maybeUpdateRectForZooming","rSpan","charWidth","rbot","bot","singleCursorHeightPerLine","screen","logicalXDPI","deviceXDPI","scaleX","scaleY","logicalYDPI","deviceYDPI","clearLineMeasurementCacheFor","clearLineMeasurementCache","externalMeasure","clearCaches","pageScrollX","pageXOffset","documentElement","scrollLeft","pageScrollY","marginTop","pageYOffset","scrollTop","widgetTopHeight","intoCoordSystem","includeWidgets","yOff","lOff","xOff","fromCoordSystem","coords","localBox","lineSpaceBox","charCoords","preparedMeasure","get","getBidi","partPos","invert","other","estimateCoords","PosWithInfo","outside","xRel","coordsChar","y","coordsCharInner","rangeEnd","wrappedLineExtent","begin","wrappedLineExtentChar","targetTop","boxIsAfter","box","widgetHeight$$1","ltr","coordsBidiPartWrapped","coordsBidiPart","baseX","chAround","boxAround","atLeft","atStart","_lineNo","ref","closestDist","endX","dist","textHeight","clientLeft","offsetLeft","compensateForHScroll","th","perLine","widgetsHeight","estimateLineHeights","est","posFromMouse","liberal","forRect","space","clientX","clientY","colDiff","round","updateSelection","showSelection","prepareSelection","primary","curFragment","cursors","selFragment","primIndex","showCursorWhenSelecting","drawSelectionCursor","drawSelectionRange","cursorHeight","otherCursor","cmpCoords","fragment","padding","leftSide","rightSide","docLTR","drawForLine","fromArg","toArg","lineLen","wrapX","side","extent","fromPos","toPos","openStart","openEnd","openLeft","openRight","topLeft","topRight","botLeft","botRight","sFrom","sTo","fromLine","toLine","singleVLine","leftEnd","rightStart","restartBlink","focused","clearInterval","blinker","visibility","cursorBlinkRate","setInterval","ensureFocus","delayBlurEvent","delayingBlurEvent","onBlur","reset","receivedFocus","updateHeightsInViewport","prevBottom","updateWidgetHeight","chWidth","w","visibleLines","viewport","ensure","ensureFrom","ensureTo","alignHorizontally","comp","gutterW","maybeUpdateLineNumberWidth","innerW","updateGutterSpace","maybeScrollWindow","doScroll","innerHeight","scrollNode","scrollPosIntoView","margin","limit","changed","endCoords","scrollPos","calculateScrollPos","startTop","startLeft","updateScrollTop","setScrollLeft","snapMargin","screentop","docBottom","atTop","atBottom","newTop","screenleft","screenw","tooWide","addToScrollTop","resolveScrollToPos","ensureCursorVisible","scrollToPos","cursorScrollMargin","scrollToCoords","scrollToRange","scrollToCoordsRange","sPos","updateDisplaySimple","setScrollTop","startWorker","forceScroll","scrollHeight","scrollbars","isScroller","scrollWidth","measureForScrollbars","docH","viewHeight","viewWidth","barLeft","docHeight","NativeScrollbars","vert","horiz","tabIndex","checkedZeroWidth","minHeight","minWidth","update","needsH","needsV","sWidth","totalHeight","totalWidth","zeroWidthHack","disableHoriz","enableZeroWidthBar","disableVert","pointerEvents","bar","maybeDisable","elt$$1","elementFromPoint","NullScrollbars","updateScrollbars","startWidth","startHeight","updateScrollbarsInner","sizes","paddingBottom","borderBottom","coverGutterNextToScrollbar","scrollbarModel","native","null","initScrollbars","scrollbarStyle","axis","nextOpId","startOperation","viewChanged","updateInput","typing","changeObjs","selectionChanged","updateMaxLine","endOperation","endOperations","endOperation_R1","endOperation_W1","endOperation_R2","endOperation_W2","endOperation_finish","maybeClipScrollbars","mustUpdate","DisplayUpdate","updatedDisplay","updateDisplayIfNeeded","barMeasure","adjustWidthTo","maxScrollLeft","preparedSelection","takeFocus","setDocumentHeight","postUpdateDisplay","maybeHiddenMarkers","unhidden","maybeUnhiddenMarkers","finish","runInOp","methodOp","docMethodOp","regChange","lendiff","resetView","cut","viewCuttingPoint","cut$1","cutTop","cutBot","regLineChange","oldN","newN","adjustView","countDirtyView","dirty","time","highlight","highlightWorker","Date","workTime","changedLines","oldStyles","highlighted","oldCls","newCls","ischange","workDelay","force","visible","editorIsHidden","wrapperHeight","oldDisplayWidth","events","marginBottom","borderRightWidth","selectionSnapshot","anchorNode","extend","anchorOffset","focusNode","focusOffset","restoreSelection","snapshot","removeAllRanges","addRange","viewportMargin","different","toUpdate","selSnapshot","patchDisplay","updateNumbersFrom","container","rm","currentWheelTarget","updateNumber","updateGutters","specs","gElt","setGuttersForLineNumbers","wheelSamples","wheelPixelsPerUnit","wheelEventDelta","dx","wheelDeltaX","dy","wheelDeltaY","detail","HORIZONTAL_AXIS","VERTICAL_AXIS","wheelDelta","wheelEventPixels","delta","onScrollWheel","canScrollX","canScrollY","pixels","movedX","movedY","sample","Selection","equals","here","there","deepCopy","Range","normalizeSelection","mayTouch","selectionsMayTouch","prim","sort","inv","simpleSelection","changeEnd","adjustForChange","computeSelAfterChange","offsetPos","computeReplacedSel","hint","oldPrev","newPrev","loadMode","modeOption","resetModeState","isWholeLineUpdate","wholeLineUpdateBefore","updateDoc","estimateHeight$$1","spansFor","linesFor","lastText","lastSpans","nlines","insert","remove","added","added$1","added$2","linkedDocs","sharedHistOnly","propagate","skip","sharedHist","linked","rel","shared","attachDoc","setDirectionClass","directionChanged","History","startGen","done","undone","undoDepth","lastModTime","lastSelTime","lastOp","lastSelOp","lastOrigin","lastSelOrigin","generation","maxGeneration","historyChangeFromChange","histChange","attachLocalSpans","clearSelectionEvents","lastChangeEvent","hist","addChangeToHistory","selAfter","opId","history","historyEventDelay","pushSelectionToHistory","selectionEventCanBeMerged","addSelectionToHistory","clearRedo","dest","existing","removeClearedSpans","explicitlyCleared","getOldSpans","mergeOldSpans","stretched","oldCur","stretchCur","copyHistoryArray","newGroup","instantiateSel","newChanges","extendRange","posBefore","extendSelection","extendSelections","heads","newSel","replaceOneSelection","setSimpleSelection","filterSelectionChange","setSelectionReplaceHistory","setSelectionNoUndo","NaN","setSelectionInner","skipAtomicInSelection","reCheckSelection","mayClear","newAnchor","skipAtomic","newHead","skipAtomicInner","oldPos","atomic","near","movePos","far","cantEdit","selectAll","filterChange","canceled","cancel","makeChange","ignoreReadOnly","suppressEdits","makeChangeInner","makeChangeSingleDoc","rebased","rebaseHist","makeChangeFromHistory","allowSelectionOnly","suppress","antiChanges","filter","returned","shiftDoc","distance","removed","makeChangeSingleDocInEditor","recomputeMaxLength","checkWidthStart","changesHandler","changeHandler","replaceRange","assign","splitLines","rebaseHistSelSingle","rebaseHistArray","sub","copied","changeLine","handle","changeType","LeafChunk","BranchChunk","removeInner","insertInner","iterN","oldHeight","remaining","leaf","maybeSpill","spilled","sibling","myIndex","used","LineWidget","opt","adjustScrollWhenAboveVisible","addLineWidget","insertAt","aboveVisible","oldH","nextMarkerId","TextMarker","markText","markTextShared","replacedWith","addToHistory","curLine","clearOnEnter","clearHistory","withOp","visual","dHeight","SharedTextMarker","cloneNode","isParent","findSharedMarkers","findMarks","copySharedMarkers","mFrom","mTo","subMark","detachSharedMarkers","subMarker","nextDocId","Doc","lineSep","cleanGeneration","constructor","getValue","lineSeparator","setValue","getLineHandle","getLineNumber","lineCount","setCursor","extendSelectionsBy","setSelections","addSelection","getSelections","replaceSelection","dup","replaceSelections","undo","redo","undoSelection","redoSelection","setExtending","getExtending","historySize","markClean","changeGeneration","forceSplit","isClean","gen","getHistory","setHistory","histData","setGutterMarker","gutterID","clearGutter","lineInfo","where","removeLineWidget","setBookmark","realOpts","findMarksAt","getAllMarks","posFromIndex","sepSize","indexFromPos","copyHistory","linkedDoc","unlinkDoc","link","splitIds","iterLinkedDocs","getEditor","setDirection","eachLine","lastDrop","onDrop","clearDragCursor","files","dataTransfer","isReadOnly","FileReader","File","read","loadFile","file","allowDropFileTypes","reader","onload","readAsText","draggingText","text$1","getData","selected","onDragStart","setData","effectAllowed","setDragImage","img","src","_top","onDragOver","frag","dragCursor","forEachCodeMirror","getElementsByClassName","byClass","editors","globalsRegistered","ensureGlobalHandlers","registerGlobalHandlers","resizeTimer","onResize","setSize","keyNames","13","16","17","18","19","20","27","32","33","34","35","36","37","38","39","40","44","45","46","59","61","91","92","93","106","107","109","110","111","127","145","173","186","187","188","189","190","191","192","219","220","221","222","63232","63233","63234","63235","63272","63273","63275","63276","63277","63302","fromCharCode","normalizeKeyName","alt","ctrl","normalizeKeyMap","keymap","keyname","keys","lookupKey","getKeyMap","fallthrough","isModifierKey","addModifierNames","noShift","altKey","metaKey","altGraphKey","deleteNearSelection","compute","kill","toKill","replaced","moveCharLogically","moveLogically","endOfLine","visually","moveInStorageOrder","prep","moveVisually","bidi","mv","getWrappedLineExtent","searchInVisualLine","getRes","res","nextCh","basic","Left","Right","Up","Down","End","Home","PageUp","PageDown","Delete","Backspace","Shift-Backspace","Tab","Shift-Tab","Enter","Insert","Esc","pcDefault","Ctrl-A","Ctrl-D","Ctrl-Z","Shift-Ctrl-Z","Ctrl-Y","Ctrl-Home","Ctrl-End","Ctrl-Up","Ctrl-Down","Ctrl-Left","Ctrl-Right","Alt-Left","Alt-Right","Ctrl-Backspace","Ctrl-Delete","Ctrl-S","Ctrl-F","Ctrl-G","Shift-Ctrl-G","Shift-Ctrl-F","Shift-Ctrl-R","Ctrl-[","Ctrl-]","Ctrl-U","Shift-Ctrl-U","Alt-U","emacsy","Ctrl-B","Ctrl-P","Ctrl-N","Alt-F","Alt-B","Ctrl-E","Ctrl-V","Shift-Ctrl-V","Ctrl-H","Alt-D","Alt-Backspace","Ctrl-K","Ctrl-T","Ctrl-O","macDefault","Cmd-A","Cmd-D","Cmd-Z","Shift-Cmd-Z","Cmd-Y","Cmd-Home","Cmd-Up","Cmd-End","Cmd-Down","Cmd-Left","Cmd-Right","Ctrl-Alt-Backspace","Alt-Delete","Cmd-S","Cmd-F","Cmd-G","Shift-Cmd-G","Cmd-Alt-F","Shift-Cmd-Alt-F","Cmd-[","Cmd-]","Cmd-Backspace","Cmd-Delete","Cmd-U","Shift-Cmd-U","singleSelection","killLine","deleteLine","delLineLeft","delWrappedLineLeft","leftPos","delWrappedLineRight","rightPos","goDocStart","goDocEnd","goLineStart","goLineStartSmart","lineStartSmart","goLineEnd","lineEnd","goLineRight","goLineLeft","goLineLeftSmart","goLineUp","moveV","goLineDown","goPageUp","goPageDown","goCharLeft","moveH","goCharRight","goColumnLeft","goColumnRight","goWordLeft","goGroupRight","goGroupLeft","goWordRight","delCharBefore","deleteH","delCharAfter","delWordBefore","delWordAfter","delGroupBefore","delGroupAfter","indentAuto","indentSelection","indentMore","indentLess","insertTab","insertSoftTab","spaces","defaultTab","transposeChars","newlineAndIndent","sels","indentLine","openLine","toggleOverwrite","firstNonWS","inWS","doHandleBinding","bound","dropShift","ensurePolled","prevShift","lookupKeyForEditor","keyMaps","extraKeys","stopSeq","dispatchKey","seq","keySeq","dispatchKeyInner","handleKeyBinding","motion","handleCharBinding","lastStoppedKey","handled","showCrossHair","up","onKeyPress","charCode","lastClick","lastDoubleClick","DOUBLECLICK_DELAY","PastClick","clickRepeat","now","compare","onMouseDown","supportsTouch","clickInGutter","repeat","selectingText","handleMappedButton","leftButtonDown","onContextMenu","configureMouse","unit","addNew","moveOnDrag","contained","behavior","dragDrop","leftButtonStartDrag","leftButtonSelect","moved","dragEnd","mouseMove","dragStart","e2","rangeForUnit","findWordAt","ourRange","ourIndex","startSel","lastPos","extendTo","startCol","posCol","oldRange","ranges$1","bidiSimplify","editorSize","counter","curCount","move","anchorLine","boundary","headIndex","usePart","gutterEvent","prevent","mX","mY","touches","lineBox","g","contextMenuInGutter","themeChanged","theme","optionHandlers","defineOptions","notOnInit","newBreaks","refresh","getInputField","spellcheck","autocorrect","autocapitalize","guttersChanged","detach","attach","wrappingChanged","integer","readOnlyChanged","dragDropChanged","resetPosition","getField","wasOn","funcs","dragFunctions","toggle","enter","over","leave","drop","inputStyles","inputStyle","pasteIncoming","cutIncoming","autofocus","registerEventHandlers","finishInit","initHooks","textRendering","touchFinished","prevTouch","finishTouch","isMouseLikeTouchEvent","touch","radiusX","radiusY","farAway","pageX","pageY","how","aggressive","curSpace","curSpaceString","indentString","indentWithTabs","pos$1","defineInitHook","lastCopied","setLastCopied","newLastCopied","applyTextInput","inserted","deleted","recent","paste","textLines","multiPaste","pasteLinesPerSelection","lineWise","changeEvent","triggerElectric","handlePaste","pasted","clipboardData","disableInput","electricChars","smartIndent","getModeAt","copyableRanges","lineRange","disableBrowserMagic","field","hiddenTextarea","border","addEditorMethods","helpers","setOption","getDoc","addKeyMap","removeKeyMap","modeSpec","newRanges","getLineTokens","getTokenTypeAt","getHelper","getHelpers","help","_global","getStateAfter","defaultTextHeight","defaultCharWidth","getViewport","addWidget","vspace","hspace","triggerOnKeyDown","triggerOnKeyPress","triggerOnKeyUp","triggerOnMouseDown","findPosH","amount","hitSide","rtlMoveVisually","findPosV","goalColumn","goals","headPos","startChar","check","scrollTo","getScrollInfo","interpret","swapDoc","phraseText","phrases","getScrollerElement","getGutterElement","registerGlobalHelper","predicate","origDir","findNextLine","moveOnce","boundToLine","sawType","pageSize","moveAmount","ContentEditableInput","lastAnchorNode","lastAnchorOffset","lastFocusNode","lastFocusOffset","polling","composing","gracePeriod","readDOMTimeout","posToDOM","isInGutter","scan","badPos","bad","domTextBetween","extraLinebreak","recognizeMarker","addText","walk","cmText","markerID","isBlock","nodeName","textContent","nodeValue","domToPos","lineNode","locateNodeInLineView","textNode","topNode","curNode","previousSibling","dist$1","onCopyCut","lineWiseCopyCut","clearData","kludge","hadFocus","showPrimarySelection","updateFromDOM","readFromDOMSoon","forceCompositionEnd","showMultipleSelections","curAnchor","curFocus","rng","rangeCount","getRangeAt","startGracePeriod","rememberSelection","selectionInEditor","commonAncestorContainer","poll","pollSelection","pollInterval","pollContent","fromIndex","fromNode","toNode","toIndex","newText","oldText","cutFront","cutEnd","oldTop","maxCutFront","newBot","oldBot","maxCutEnd","chFrom","chTo","contentEditable","TextareaInput","prevInput","pollingFast","fromTextArea","textarea","tabindex","placeholder","realSubmit","form","leaveSubmitMethodAlone","submit","wrappedSubmit","getTextArea","toTextArea","addLegacyProps","cmpPos","createField","prepareCopyCut","fastPoll","dispatchEvent","Event","_display","moveInputWithCursor","wrapOff","lineOff","teTop","teLeft","drawn","contextMenuPending","slowPoll","missed","same","resetSelectionOnContextMenu","oldScrollY","oldCSS","oldWrapperCSS","wrapperBox","offsetParent","scrollY","rehide","detectingSelectAll","prepareSelectAllHack","mouseup","extval","disabled","dontDelegate","method","contenteditable","func","defineDocExtension","version","KEYWORD","DOCTYPE","ID","CLASS","ATTRS_NEST","(","[","jsMode","javaScriptLine","javaScriptLineExcludesColon","javaScriptArguments","javaScriptArgumentsDepth","isInterpolating","interpolationNesting","jsState","restOfLine","isIncludeFiltered","isEach","lastTag","scriptType","isAttrs","attrsNest","inAttributeName","attributeIsType","attrValue","indentOf","indentToken","innerState","innerModeForLine","javaScript","tok","yieldStatement","doctype","interpolation","interpolationContinued","caseStatement","when","defaultStatement","extendsStatement","append","prepend","block","include","includeFiltered","includeFilteredContinued","mixin","mixinCallAfter","callArguments","conditional","each","eachContinued","whileStatement","captures","innerModes","substring","setInnerMode","attrs","attrsContinued","ex","attributesBlock","colon","dot","fail","nextToken","tagLanguages","script","mustacheOverlay","overlayMode","backdrop","tags","SearchAnnotation","annotateOptions","listenForChanges","annotation","matches","findMatches","self","_cm","onChange","MAX_MATCHES","offsetLine","changeStart","sizeChange","maxMatches","startLine","endLine","newFrom","newTo","updateAfterChange","noOptions","nonWS","probablyInsideString","useInnerComments","toggleComment","minLine","uncomment","commentString","pad","blankLines","commentBlankLines","baseString","whitespace","fullLines","blockComment","startString","endString","lastLineHasText","lead","blockCommentLead","didSomething","lineString","endPos","open","insideStart","insideEnd","lastStart","firstEnd","almostLastStart","foundEnd","ensureState","states","toRegex","caret","flags","asToken","Rule","regex","tokenFunction","pend","local","endToken","localState","endScan","rule","stack","enterLocalMode","pers","persistentStates","lState","forceEnd","indentFunction","meta","dontIndentStates","rules","dedentIfLineStart","defineSimpleMode","simpleMode","states_","hasIndentation","orig","s","indentUnitString","tagKeywords","keySet","tagKeywords_","tagVariablesRegexp","propertyKeywords_","nonStandardPropertyKeywords","nonStandardPropertyKeywords_","valueKeywords_","colorKeywords_","documentTypes","documentTypes_","documentTypesRegexp","wordRegexp","mediaFeatures","mediaFeatures_","mediaTypes","mediaTypes_","fontProperties_","operatorsRegexp","wordOperatorKeywordsRegexp","wordOperatorKeywords_","blockKeywords_","vendorPrefixesRegexp","commonAtoms","commonAtoms_","firstWordMatch","firstWord","tokenCComment","tokenParenthesized","wordIsTag","currentIndent","contextIndent","pass","popAndPass","wordIsProperty","wordIsBlock","wordIsVendorPrefix","wordAsValue","wordLC","typeIsBlock","typeIsInterpolation","typeIsPseudo","escapeRegExp","firstWordOfLine","parens","vendorPrefixes","pseudo","atBlock","atBlock_parens","keyframes","variableName","lineFirstWord","lineIndent","prevLineFirstWord","prevLineIndent","commonDef_","hintWords","inline","tokenHooks","mediaValueKeywords","counterDescriptors","allowNested","supportsAtComponent","ret","tp","stateArg","maybeprop","propBlock","atComponentBlock","restricted_atBlock_before","restricted_atBlock","mediaValueKeywords_","counterDescriptors_","allWords",":","&","ie_lt8","matching",")","]",">","bracketRegex","findMatchingBracket","afterCursor","strict","scanForBracket","forward","maxScanLen","maxScanLineLength","maxScanLines","matchBrackets","autoclear","maxHighlightLen","maxHighlightLineLength","marks","doMatchBrackets","currentlyHighlighted","oldConfig","required","default","readonly","Boolean","newItem","relation","fields","values","c","defineProperty","configurable","enumerable","__esModule","TypeError","writable","codemirror","cminstance","unseenLines","merge","globalOptions","globalEvents","watch","deep","handler","$nextTick","switchMerge","handerCodeChange","methods","initialize","MergeView","$refs","mergeview","edit","$emit","unseenLineMarkers","destroy","mounted","beforeDestroy","install","component","render","staticRenderFns","_compiled","functional","_scopeId","$vnode","ssrContext","__VUE_SSR_CONTEXT__","_registeredComponents","_ssrRegister","beforeCreate","_injectStyles","esModule","$createElement","_self","_c","staticClass","class","onCursorActivity","markedSelection","markedSelectionStyle","CHUNK_SIZE","coverRange","addAt","atEnd","cmds","findPosSubword","cat","moveSubword","insertLine","newSelection","wordAt","addCursorToSelection","newRange","isSelectedRange","goSubwordLeft","goSubwordRight","scrollLineUp","visibleBottomLine","scrollLineDown","visibleTopLine","splitSelectionByLine","lineRanges","singleSelectionTop","selectLine","extended","insertLineAfter","insertLineBefore","selectNextOccurrence","fullWord","sublimeFindFullWord","addCursorToPrevLine","addCursorToNextLine","mirror","selectBetweenBrackets","opening","startPos","sortLines","caseSensitive","toSort","au","bu","modifyWordOrSelection","indices","replacements","getTarget","findAndGoTo","findPrevious","selectScope","goToBracket","swapLineUp","linesToMove","newSels","swapLineDown","toggleCommentIndented","joinLines","joined","actual","duplicateLine","sortLinesInsensitive","nextBookmark","sublimeBookmarks","prevBookmark","toggleBookmark","sublimeBookmark","clearBookmarks","selectBookmarks","smartBackspace","toStartOfLine","deletePos","prevIndent","delLineRight","upcaseAtCursor","downcaseAtCursor","setSublimeMark","sublimeMark","selectToSublimeMark","deleteToSublimeMark","tmp","sublimeKilled","swapWithSublimeMark","sublimeYank","showInCenter","findUnder","findUnderPrevious","findAllUnder","primaryIndex","macSublime","Shift-Ctrl-K","Alt-Q","Ctrl-Alt-Up","Ctrl-Alt-Down","Cmd-L","Shift-Cmd-L","Cmd-Enter","Shift-Cmd-Enter","Shift-Cmd-Space","Shift-Cmd-M","Cmd-M","Cmd-Ctrl-Up","Cmd-Ctrl-Down","Cmd-/","Cmd-J","Shift-Cmd-D","F5","Cmd-F5","F2","Shift-F2","Cmd-F2","Shift-Cmd-F2","Alt-F2","Cmd-K Cmd-K","Cmd-K Cmd-U","Cmd-K Cmd-L","Cmd-K Cmd-Space","Cmd-K Cmd-A","Cmd-K Cmd-W","Cmd-K Cmd-X","Cmd-K Cmd-Y","Cmd-K Cmd-C","Cmd-K Cmd-G","Cmd-K Cmd-Backspace","Cmd-K Cmd-0","Cmd-K Cmd-J","Ctrl-Shift-Up","Ctrl-Shift-Down","Cmd-F3","Shift-Cmd-F3","Alt-F3","Shift-Cmd-[","Shift-Cmd-]","Cmd-I","Shift-Cmd-I","Cmd-H","F3","Shift-F3","pcSublime","Ctrl-L","Shift-Ctrl-L","Ctrl-Enter","Shift-Ctrl-Enter","Shift-Ctrl-Space","Shift-Ctrl-M","Ctrl-M","Shift-Ctrl-Up","Shift-Ctrl-Down","Ctrl-/","Ctrl-J","Shift-Ctrl-D","F9","Ctrl-F9","Ctrl-F2","Shift-Ctrl-F2","Ctrl-K Ctrl-K","Ctrl-K Ctrl-U","Ctrl-K Ctrl-L","Ctrl-K Ctrl-Space","Ctrl-K Ctrl-A","Ctrl-K Ctrl-W","Ctrl-K Ctrl-X","Ctrl-K Ctrl-Y","Ctrl-K Ctrl-C","Ctrl-K Ctrl-G","Ctrl-K Ctrl-Backspace","Ctrl-K Ctrl-0","Ctrl-K Ctrl-J","Ctrl-F3","Shift-Ctrl-F3","Shift-Ctrl-[","Shift-Ctrl-]","Ctrl-I","Shift-Ctrl-I","sublime","HINT_ELEMENT_CLASS","ACTIVE_HINT_ELEMENT_CLASS","Completion","debounce","tick","startLen","activityFunc","showHint","getHints","async","newOpts","parseOptions","selections","supportsSelection","completionActive","completion","requestAnimationFrame","fn","cancelAnimationFrame","hintOptions","defaultOptions","resolve","getText","buildKeyMap","baseMap","moveFocus","menuSize","setFocus","pick","custom","customKeys","ourMap","addBinding","getHintElement","hintsElement","el","Widget","picked","parentWindow","defaultView","hints","selectedHint","completions","hintId","alignWithWord","below","winW","innerWidth","winH","overlapY","scrolls","startScroll","curTop","closingOnBlur","overlapX","avoidWrap","changeActive","screenAmount","closeOnUnfocus","onScroll","curScroll","point","completeOnSingleClick","applicableHelpers","fetchHints","then","resolveAutoHints","resolved","app","run","fromList","anyword","closeCharacters","disable","myTick","finishUpdate","completeSingle","term","autocomplete","auto","Annotation","scheduleRedraw","doRedraw","redraw","buttonHeight","scrollButtonHeight","annotations","doUpdate","computeScale","resizeHandler","hScale","anns","singleLineH","curLineObj","getY","topY","nextTop","ann","combine","basePos","baseCur","overlayPos","overlayCur","streamSeen","combineTokens","overlayToken","conf","parserConf","ERRORCLASS","delimiters","identifiers","atProp","wordOperators","indentKeywords","commonKeywords","stringPrefixes","regexPrefixes","commonConstants","constants","scopeOffset","lineOffset","longComment","floatLiteral","intLiteral","tokenFactory","delimiter","singleline","outclass","singleLineStringErrors","alignOffset","_indent","matched","delimiter_index","external","fillAlign","closer","closes","doFold","noFold","regexpFlags","regexp","ensureFlags","maybeMultiline","searchRegexpForward","searchRegexpForwardMultiline","inside","lastMatchIn","cutOff","newMatch","searchRegexpBackward","searchRegexpBackwardMultiline","adjustPos","folded","foldFunc","searchStringForward","cutFrom","searchStringBackward","topString","SearchCursor","atOccurrence","normalize","htmlConfig","autoSelfClosers","area","br","command","embed","frame","hr","keygen","param","track","wbr","menuitem","implicitlyClosed","dd","li","optgroup","rp","tbody","td","tfoot","tr","contextGrabbers","dt","address","article","aside","blockquote","dl","fieldset","footer","h1","h2","h3","h4","h5","h6","header","hgroup","menu","nav","ol","section","table","ul","thead","doNotIndent","allowUnquoted","allowMissing","xmlConfig","allowMissingTagName","editorConf","config_","setStyle","inText","chain","parser","inBlock","inTag","baseState","tagName","tagStart","inAttribute","stringStartCol","closure","isInAttribute","terminator","noIndent","maybePopContext","nextTagName","parentTagName","tagNameState","closeTagNameState","attrState","matchClosing","closeState","closeStateErr","attrEqState","attrValueState","attrContinuedState","isInText","baseIndent","fullLine","multilineTagIndentPastTag","multilineTagIndentFactor","alignCDATA","tagAfter","grabbers","configuration","skipAttribute","defaultTags","maybeBackup","pat","attrRegexpCache","getAttrRegexp","getAttrValue","getTagRegexp","anchored","addTags","findMatchingMode","tagInfo","tagText","configTags","configScript","scriptTypes","htmlState","endTagA","endTag","localMode","_vm","_h","altOptions","cmOptions","stringValue","directives","rawName","$t","expression","click","fillTemplate","_v","_s","$tc","lang","language","inputvue_type_script_lang_js_","mixins","interface_default","components","vue_codemirror","autoRefresh","styleActiveLine","styleSelectedText","highlightSelectionMatches","Ctrl","codemirrorEl","oldVal","$set","computed","availableTypes","text/plain","text/javascript","application/json","text/x-vue","application/x-httpd-php","esm_typeof","stringify_default","JSON","parse","$lodash","isObject","isArray","code_inputvue_type_script_lang_js_","componentNormalizer","__webpack_exports__","handlebars","dash_comment","multiplexingMode","parseDelimiters","others","returnEnd","innerActive","curInner","oldContent","delimStyle","innerToken","innerStyle","outerIndent","possibleOuterIndent","outerToken","startListening","stopListening","hurry","statementIndent","jsonldMode","jsonld","jsonMode","json","isTS","typescript","wordRE","wordCharacters","kw","A","B","C","D","operator","atom","if","while","with","else","do","try","finally","return","break","continue","new","delete","void","throw","debugger","var","const","let","function","catch","for","switch","case","in","typeof","instanceof","true","false","super","yield","export","import","extends","await","isJsonldKeyword","readRegexp","inSet","cont","expressionAllowed","tokenQuasi","lexical","lastType","brackets","findFatArrow","fatArrowAt","arrow","sawSomething","bracket","atomicTypes","variable","jsonld-keyword","JSLexical","inScope","varname","vars","parseJS","cc","marked","combinator","statement","lex","inList","register","newContext","registerVarScoped","Var","isModifier","defaultVars","pushcontext","pushblockcontext","popcontext","pushlex","poplex","expect","wanted","exp","vardef","parenExpr","maybeexpression","maybeelse","functiondef","forspec","enumdef","typename","typeexpr","maybelabel","maybeCatchBinding","afterExport","afterImport","funarg","expressionInner","expressionNoComma","noComma","arrowBodyNoComma","arrowBody","commasep","maybeop","maybeoperatorNoComma","maybeoperatorComma","classExpression","arrayLiteral","contCommasep","objprop","quasi","maybeTarget","expr","property","continueQuasi","targetNoComma","maybeTypeArgs","getterSetter","afterprop","maybetype","what","sep","proceed","mayberettype","isKW","afterType","typeprop","typearg","maybeReturnType","functiondecl","typeparam","maybeTypeDefault","maybeAssign","vardefCont","eltpattern","proppattern","_type","forspec1","forspec2","classNameAfter","classBody","classfield","isInterface","maybeFrom","exportField","importSpec","maybeMoreImports","maybeAs","enummember","isContinuedStatement","doubleIndentSwitch","skipExpression"],"mappings":"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ACA,+DACA,gEACA,sEACA,kEACA,sEACA,mFACA,6DACA,qEACA,qEACA,wDACA,gDACA,wDACA,qEACA,mEACA,mEACA,8EACA,qFACA,4DACA,wEACA,wEACA,sEACA,mEACA,wEACA,+EACA,8DACA,gEACA,4FACA,gEACA,4DACA,oEACA,0DACA,2CACA,kEACA,uFACA,+DACA,sCACA,iEACA,sEACA,wEACA,kEACA,iEACA,+GACA,sEACA,8DACA,yEACA,iEACA,kFACA,yDACA,wEACA,8DACA,mEACA,sEACA,8DACA,6DACA,0EACA,oFACA,mEACA,sDACA,kEACA,6EACA,uEACA,kFACA,qCAEA,0EACA,8EACA,oDACA,sEACA,6EACA,0EACA,qEACA,oEACA,2DACA12E,EAAAu2E,EAAAG,GAEAE,EAAA,CACA,6EACA,4EACA,kEACA,kFACA,yCACAD,EAAAJ,EAAAK,GAEAW,EAAA,CACA,2EACA,2CACAp3E,EAAAo2E,EAAAgB,GAEAuD,EAAA,CACA,gEACA,wCACAZ,EAAA3D,EAAAuE,GAEAhE,EAAA,CACA,+DACA,8DACA,0EACA,kEACA,kEACA,gEACA,6DACA,4DACA,+DACA,kEACA,0DACA,oEACA,wEACA,8DACA,oEACA,uEACA,yEACA,oEACA,wEACA,qEACA,2DACA,qEACA,wEACA,+DACA,+DACA,qCACA72E,EAAAs2E,EAAAO,GAEAD,EAAA,CACA,oEACA,gFACA,kEACA,oGACA,oFACA,6EACA,mFACA,8EACA,mEACA,uEACA,mEACA,qFACA,qDACA,qFACA,kFACA,6EACA,gFACA,kEACA,0BACA,8EACA,2EACA,yEACA,mDACA,oDACA,kDACA,qDACA,4EACA,kFACA,mGACA,6EACA,+EACA,4DACA,4EACA,oEACA,uEACA,gGACA,mEACA,+CACA,qEACA,sEACA,mFACA,gEACA,kEACA,qFACA,yDACA,kEACA,wDACA,oEACA,yEACA,oEACA,oDACA,uEACA,gFACA,gEACA,mEACA,mGACA,8DACA,uEACA,+EACA,yEACA,+DACA,8DACA,gDACA,oEACA,qEACA,4E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","file":"js/chunk-c9355f5e.b6144ca6.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n// Define search commands. Depends on dialog.js or another\n// implementation of the openDialog method.\n\n// Replace works a little oddly -- it will do the replace on the next\n// Ctrl-G (or whatever is bound to findNext) press. You prevent a\n// replace by making sure the match is no longer selected when hitting\n// Ctrl-G.\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"./searchcursor\"), require(\"../dialog/dialog\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"./searchcursor\", \"../dialog/dialog\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  function searchOverlay(query, caseInsensitive) {\n    if (typeof query == \"string\")\n      query = new RegExp(query.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, \"\\\\$&\"), caseInsensitive ? \"gi\" : \"g\");\n    else if (!query.global)\n      query = new RegExp(query.source, query.ignoreCase ? \"gi\" : \"g\");\n\n    return {token: function(stream) {\n      query.lastIndex = stream.pos;\n      var match = query.exec(stream.string);\n      if (match && match.index == stream.pos) {\n        stream.pos += match[0].length || 1;\n        return \"searching\";\n      } else if (match) {\n        stream.pos = match.index;\n      } else {\n        stream.skipToEnd();\n      }\n    }};\n  }\n\n  function SearchState() {\n    this.posFrom = this.posTo = this.lastQuery = this.query = null;\n    this.overlay = null;\n  }\n\n  function getSearchState(cm) {\n    return cm.state.search || (cm.state.search = new SearchState());\n  }\n\n  function queryCaseInsensitive(query) {\n    return typeof query == \"string\" && query == query.toLowerCase();\n  }\n\n  function getSearchCursor(cm, query, pos) {\n    // Heuristic: if the query string is all lowercase, do a case insensitive search.\n    return cm.getSearchCursor(query, pos, {caseFold: queryCaseInsensitive(query), multiline: true});\n  }\n\n  function persistentDialog(cm, text, deflt, onEnter, onKeyDown) {\n    cm.openDialog(text, onEnter, {\n      value: deflt,\n      selectValueOnOpen: true,\n      closeOnEnter: false,\n      onClose: function() { clearSearch(cm); },\n      onKeyDown: onKeyDown\n    });\n  }\n\n  function dialog(cm, text, shortText, deflt, f) {\n    if (cm.openDialog) cm.openDialog(text, f, {value: deflt, selectValueOnOpen: true});\n    else f(prompt(shortText, deflt));\n  }\n\n  function confirmDialog(cm, text, shortText, fs) {\n    if (cm.openConfirm) cm.openConfirm(text, fs);\n    else if (confirm(shortText)) fs[0]();\n  }\n\n  function parseString(string) {\n    return string.replace(/\\\\(.)/g, function(_, ch) {\n      if (ch == \"n\") return \"\\n\"\n      if (ch == \"r\") return \"\\r\"\n      return ch\n    })\n  }\n\n  function parseQuery(query) {\n    var isRE = query.match(/^\\/(.*)\\/([a-z]*)$/);\n    if (isRE) {\n      try { query = new RegExp(isRE[1], isRE[2].indexOf(\"i\") == -1 ? \"\" : \"i\"); }\n      catch(e) {} // Not a regular expression after all, do a string search\n    } else {\n      query = parseString(query)\n    }\n    if (typeof query == \"string\" ? query == \"\" : query.test(\"\"))\n      query = /x^/;\n    return query;\n  }\n\n  function startSearch(cm, state, query) {\n    state.queryText = query;\n    state.query = parseQuery(query);\n    cm.removeOverlay(state.overlay, queryCaseInsensitive(state.query));\n    state.overlay = searchOverlay(state.query, queryCaseInsensitive(state.query));\n    cm.addOverlay(state.overlay);\n    if (cm.showMatchesOnScrollbar) {\n      if (state.annotate) { state.annotate.clear(); state.annotate = null; }\n      state.annotate = cm.showMatchesOnScrollbar(state.query, queryCaseInsensitive(state.query));\n    }\n  }\n\n  function doSearch(cm, rev, persistent, immediate) {\n    var state = getSearchState(cm);\n    if (state.query) return findNext(cm, rev);\n    var q = cm.getSelection() || state.lastQuery;\n    if (q instanceof RegExp && q.source == \"x^\") q = null\n    if (persistent && cm.openDialog) {\n      var hiding = null\n      var searchNext = function(query, event) {\n        CodeMirror.e_stop(event);\n        if (!query) return;\n        if (query != state.queryText) {\n          startSearch(cm, state, query);\n          state.posFrom = state.posTo = cm.getCursor();\n        }\n        if (hiding) hiding.style.opacity = 1\n        findNext(cm, event.shiftKey, function(_, to) {\n          var dialog\n          if (to.line < 3 && document.querySelector &&\n              (dialog = cm.display.wrapper.querySelector(\".CodeMirror-dialog\")) &&\n              dialog.getBoundingClientRect().bottom - 4 > cm.cursorCoords(to, \"window\").top)\n            (hiding = dialog).style.opacity = .4\n        })\n      };\n      persistentDialog(cm, getQueryDialog(cm), q, searchNext, function(event, query) {\n        var keyName = CodeMirror.keyName(event)\n        var extra = cm.getOption('extraKeys'), cmd = (extra && extra[keyName]) || CodeMirror.keyMap[cm.getOption(\"keyMap\")][keyName]\n        if (cmd == \"findNext\" || cmd == \"findPrev\" ||\n          cmd == \"findPersistentNext\" || cmd == \"findPersistentPrev\") {\n          CodeMirror.e_stop(event);\n          startSearch(cm, getSearchState(cm), query);\n          cm.execCommand(cmd);\n        } else if (cmd == \"find\" || cmd == \"findPersistent\") {\n          CodeMirror.e_stop(event);\n          searchNext(query, event);\n        }\n      });\n      if (immediate && q) {\n        startSearch(cm, state, q);\n        findNext(cm, rev);\n      }\n    } else {\n      dialog(cm, getQueryDialog(cm), \"Search for:\", q, function(query) {\n        if (query && !state.query) cm.operation(function() {\n          startSearch(cm, state, query);\n          state.posFrom = state.posTo = cm.getCursor();\n          findNext(cm, rev);\n        });\n      });\n    }\n  }\n\n  function findNext(cm, rev, callback) {cm.operation(function() {\n    var state = getSearchState(cm);\n    var cursor = getSearchCursor(cm, state.query, rev ? state.posFrom : state.posTo);\n    if (!cursor.find(rev)) {\n      cursor = getSearchCursor(cm, state.query, rev ? CodeMirror.Pos(cm.lastLine()) : CodeMirror.Pos(cm.firstLine(), 0));\n      if (!cursor.find(rev)) return;\n    }\n    cm.setSelection(cursor.from(), cursor.to());\n    cm.scrollIntoView({from: cursor.from(), to: cursor.to()}, 20);\n    state.posFrom = cursor.from(); state.posTo = cursor.to();\n    if (callback) callback(cursor.from(), cursor.to())\n  });}\n\n  function clearSearch(cm) {cm.operation(function() {\n    var state = getSearchState(cm);\n    state.lastQuery = state.query;\n    if (!state.query) return;\n    state.query = state.queryText = null;\n    cm.removeOverlay(state.overlay);\n    if (state.annotate) { state.annotate.clear(); state.annotate = null; }\n  });}\n\n\n  function getQueryDialog(cm)  {\n    return '<span class=\"CodeMirror-search-label\">' + cm.phrase(\"Search:\") + '</span> <input type=\"text\" style=\"width: 10em\" class=\"CodeMirror-search-field\"/> <span style=\"color: #888\" class=\"CodeMirror-search-hint\">' + cm.phrase(\"(Use /re/ syntax for regexp search)\") + '</span>';\n  }\n  function getReplaceQueryDialog(cm) {\n    return ' <input type=\"text\" style=\"width: 10em\" class=\"CodeMirror-search-field\"/> <span style=\"color: #888\" class=\"CodeMirror-search-hint\">' + cm.phrase(\"(Use /re/ syntax for regexp search)\") + '</span>';\n  }\n  function getReplacementQueryDialog(cm) {\n    return '<span class=\"CodeMirror-search-label\">' + cm.phrase(\"With:\") + '</span> <input type=\"text\" style=\"width: 10em\" class=\"CodeMirror-search-field\"/>';\n  }\n  function getDoReplaceConfirm(cm) {\n    return '<span class=\"CodeMirror-search-label\">' + cm.phrase(\"Replace?\") + '</span> <button>' + cm.phrase(\"Yes\") + '</button> <button>' + cm.phrase(\"No\") + '</button> <button>' + cm.phrase(\"All\") + '</button> <button>' + cm.phrase(\"Stop\") + '</button> ';\n  }\n\n  function replaceAll(cm, query, text) {\n    cm.operation(function() {\n      for (var cursor = getSearchCursor(cm, query); cursor.findNext();) {\n        if (typeof query != \"string\") {\n          var match = cm.getRange(cursor.from(), cursor.to()).match(query);\n          cursor.replace(text.replace(/\\$(\\d)/g, function(_, i) {return match[i];}));\n        } else cursor.replace(text);\n      }\n    });\n  }\n\n  function replace(cm, all) {\n    if (cm.getOption(\"readOnly\")) return;\n    var query = cm.getSelection() || getSearchState(cm).lastQuery;\n    var dialogText = '<span class=\"CodeMirror-search-label\">' + (all ? cm.phrase(\"Replace all:\") : cm.phrase(\"Replace:\")) + '</span>';\n    dialog(cm, dialogText + getReplaceQueryDialog(cm), dialogText, query, function(query) {\n      if (!query) return;\n      query = parseQuery(query);\n      dialog(cm, getReplacementQueryDialog(cm), cm.phrase(\"Replace with:\"), \"\", function(text) {\n        text = parseString(text)\n        if (all) {\n          replaceAll(cm, query, text)\n        } else {\n          clearSearch(cm);\n          var cursor = getSearchCursor(cm, query, cm.getCursor(\"from\"));\n          var advance = function() {\n            var start = cursor.from(), match;\n            if (!(match = cursor.findNext())) {\n              cursor = getSearchCursor(cm, query);\n              if (!(match = cursor.findNext()) ||\n                  (start && cursor.from().line == start.line && cursor.from().ch == start.ch)) return;\n            }\n            cm.setSelection(cursor.from(), cursor.to());\n            cm.scrollIntoView({from: cursor.from(), to: cursor.to()});\n            confirmDialog(cm, getDoReplaceConfirm(cm), cm.phrase(\"Replace?\"),\n                          [function() {doReplace(match);}, advance,\n                           function() {replaceAll(cm, query, text)}]);\n          };\n          var doReplace = function(match) {\n            cursor.replace(typeof query == \"string\" ? text :\n                           text.replace(/\\$(\\d)/g, function(_, i) {return match[i];}));\n            advance();\n          };\n          advance();\n        }\n      });\n    });\n  }\n\n  CodeMirror.commands.find = function(cm) {clearSearch(cm); doSearch(cm);};\n  CodeMirror.commands.findPersistent = function(cm) {clearSearch(cm); doSearch(cm, false, true);};\n  CodeMirror.commands.findPersistentNext = function(cm) {doSearch(cm, false, true, true);};\n  CodeMirror.commands.findPersistentPrev = function(cm) {doSearch(cm, true, true, true);};\n  CodeMirror.commands.findNext = doSearch;\n  CodeMirror.commands.findPrev = function(cm) {doSearch(cm, true);};\n  CodeMirror.commands.clearSearch = clearSearch;\n  CodeMirror.commands.replace = replace;\n  CodeMirror.commands.replaceAll = function(cm) {replace(cm, true);};\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"../css/css\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"../css/css\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"sass\", function(config) {\n  var cssMode = CodeMirror.mimeModes[\"text/css\"];\n  var propertyKeywords = cssMode.propertyKeywords || {},\n      colorKeywords = cssMode.colorKeywords || {},\n      valueKeywords = cssMode.valueKeywords || {},\n      fontProperties = cssMode.fontProperties || {};\n\n  function tokenRegexp(words) {\n    return new RegExp(\"^\" + words.join(\"|\"));\n  }\n\n  var keywords = [\"true\", \"false\", \"null\", \"auto\"];\n  var keywordsRegexp = new RegExp(\"^\" + keywords.join(\"|\"));\n\n  var operators = [\"\\\\(\", \"\\\\)\", \"=\", \">\", \"<\", \"==\", \">=\", \"<=\", \"\\\\+\", \"-\",\n                   \"\\\\!=\", \"/\", \"\\\\*\", \"%\", \"and\", \"or\", \"not\", \";\",\"\\\\{\",\"\\\\}\",\":\"];\n  var opRegexp = tokenRegexp(operators);\n\n  var pseudoElementsRegexp = /^::?[a-zA-Z_][\\w\\-]*/;\n\n  var word;\n\n  function isEndLine(stream) {\n    return !stream.peek() || stream.match(/\\s+$/, false);\n  }\n\n  function urlTokens(stream, state) {\n    var ch = stream.peek();\n\n    if (ch === \")\") {\n      stream.next();\n      state.tokenizer = tokenBase;\n      return \"operator\";\n    } else if (ch === \"(\") {\n      stream.next();\n      stream.eatSpace();\n\n      return \"operator\";\n    } else if (ch === \"'\" || ch === '\"') {\n      state.tokenizer = buildStringTokenizer(stream.next());\n      return \"string\";\n    } else {\n      state.tokenizer = buildStringTokenizer(\")\", false);\n      return \"string\";\n    }\n  }\n  function comment(indentation, multiLine) {\n    return function(stream, state) {\n      if (stream.sol() && stream.indentation() <= indentation) {\n        state.tokenizer = tokenBase;\n        return tokenBase(stream, state);\n      }\n\n      if (multiLine && stream.skipTo(\"*/\")) {\n        stream.next();\n        stream.next();\n        state.tokenizer = tokenBase;\n      } else {\n        stream.skipToEnd();\n      }\n\n      return \"comment\";\n    };\n  }\n\n  function buildStringTokenizer(quote, greedy) {\n    if (greedy == null) { greedy = true; }\n\n    function stringTokenizer(stream, state) {\n      var nextChar = stream.next();\n      var peekChar = stream.peek();\n      var previousChar = stream.string.charAt(stream.pos-2);\n\n      var endingString = ((nextChar !== \"\\\\\" && peekChar === quote) || (nextChar === quote && previousChar !== \"\\\\\"));\n\n      if (endingString) {\n        if (nextChar !== quote && greedy) { stream.next(); }\n        if (isEndLine(stream)) {\n          state.cursorHalf = 0;\n        }\n        state.tokenizer = tokenBase;\n        return \"string\";\n      } else if (nextChar === \"#\" && peekChar === \"{\") {\n        state.tokenizer = buildInterpolationTokenizer(stringTokenizer);\n        stream.next();\n        return \"operator\";\n      } else {\n        return \"string\";\n      }\n    }\n\n    return stringTokenizer;\n  }\n\n  function buildInterpolationTokenizer(currentTokenizer) {\n    return function(stream, state) {\n      if (stream.peek() === \"}\") {\n        stream.next();\n        state.tokenizer = currentTokenizer;\n        return \"operator\";\n      } else {\n        return tokenBase(stream, state);\n      }\n    };\n  }\n\n  function indent(state) {\n    if (state.indentCount == 0) {\n      state.indentCount++;\n      var lastScopeOffset = state.scopes[0].offset;\n      var currentOffset = lastScopeOffset + config.indentUnit;\n      state.scopes.unshift({ offset:currentOffset });\n    }\n  }\n\n  function dedent(state) {\n    if (state.scopes.length == 1) return;\n\n    state.scopes.shift();\n  }\n\n  function tokenBase(stream, state) {\n    var ch = stream.peek();\n\n    // Comment\n    if (stream.match(\"/*\")) {\n      state.tokenizer = comment(stream.indentation(), true);\n      return state.tokenizer(stream, state);\n    }\n    if (stream.match(\"//\")) {\n      state.tokenizer = comment(stream.indentation(), false);\n      return state.tokenizer(stream, state);\n    }\n\n    // Interpolation\n    if (stream.match(\"#{\")) {\n      state.tokenizer = buildInterpolationTokenizer(tokenBase);\n      return \"operator\";\n    }\n\n    // Strings\n    if (ch === '\"' || ch === \"'\") {\n      stream.next();\n      state.tokenizer = buildStringTokenizer(ch);\n      return \"string\";\n    }\n\n    if(!state.cursorHalf){// state.cursorHalf === 0\n    // first half i.e. before : for key-value pairs\n    // including selectors\n\n      if (ch === \"-\") {\n        if (stream.match(/^-\\w+-/)) {\n          return \"meta\";\n        }\n      }\n\n      if (ch === \".\") {\n        stream.next();\n        if (stream.match(/^[\\w-]+/)) {\n          indent(state);\n          return \"qualifier\";\n        } else if (stream.peek() === \"#\") {\n          indent(state);\n          return \"tag\";\n        }\n      }\n\n      if (ch === \"#\") {\n        stream.next();\n        // ID selectors\n        if (stream.match(/^[\\w-]+/)) {\n          indent(state);\n          return \"builtin\";\n        }\n        if (stream.peek() === \"#\") {\n          indent(state);\n          return \"tag\";\n        }\n      }\n\n      // Variables\n      if (ch === \"$\") {\n        stream.next();\n        stream.eatWhile(/[\\w-]/);\n        return \"variable-2\";\n      }\n\n      // Numbers\n      if (stream.match(/^-?[0-9\\.]+/))\n        return \"number\";\n\n      // Units\n      if (stream.match(/^(px|em|in)\\b/))\n        return \"unit\";\n\n      if (stream.match(keywordsRegexp))\n        return \"keyword\";\n\n      if (stream.match(/^url/) && stream.peek() === \"(\") {\n        state.tokenizer = urlTokens;\n        return \"atom\";\n      }\n\n      if (ch === \"=\") {\n        // Match shortcut mixin definition\n        if (stream.match(/^=[\\w-]+/)) {\n          indent(state);\n          return \"meta\";\n        }\n      }\n\n      if (ch === \"+\") {\n        // Match shortcut mixin definition\n        if (stream.match(/^\\+[\\w-]+/)){\n          return \"variable-3\";\n        }\n      }\n\n      if(ch === \"@\"){\n        if(stream.match(/@extend/)){\n          if(!stream.match(/\\s*[\\w]/))\n            dedent(state);\n        }\n      }\n\n\n      // Indent Directives\n      if (stream.match(/^@(else if|if|media|else|for|each|while|mixin|function)/)) {\n        indent(state);\n        return \"def\";\n      }\n\n      // Other Directives\n      if (ch === \"@\") {\n        stream.next();\n        stream.eatWhile(/[\\w-]/);\n        return \"def\";\n      }\n\n      if (stream.eatWhile(/[\\w-]/)){\n        if(stream.match(/ *: *[\\w-\\+\\$#!\\(\"']/,false)){\n          word = stream.current().toLowerCase();\n          var prop = state.prevProp + \"-\" + word;\n          if (propertyKeywords.hasOwnProperty(prop)) {\n            return \"property\";\n          } else if (propertyKeywords.hasOwnProperty(word)) {\n            state.prevProp = word;\n            return \"property\";\n          } else if (fontProperties.hasOwnProperty(word)) {\n            return \"property\";\n          }\n          return \"tag\";\n        }\n        else if(stream.match(/ *:/,false)){\n          indent(state);\n          state.cursorHalf = 1;\n          state.prevProp = stream.current().toLowerCase();\n          return \"property\";\n        }\n        else if(stream.match(/ *,/,false)){\n          return \"tag\";\n        }\n        else{\n          indent(state);\n          return \"tag\";\n        }\n      }\n\n      if(ch === \":\"){\n        if (stream.match(pseudoElementsRegexp)){ // could be a pseudo-element\n          return \"variable-3\";\n        }\n        stream.next();\n        state.cursorHalf=1;\n        return \"operator\";\n      }\n\n    } // cursorHalf===0 ends here\n    else{\n\n      if (ch === \"#\") {\n        stream.next();\n        // Hex numbers\n        if (stream.match(/[0-9a-fA-F]{6}|[0-9a-fA-F]{3}/)){\n          if (isEndLine(stream)) {\n            state.cursorHalf = 0;\n          }\n          return \"number\";\n        }\n      }\n\n      // Numbers\n      if (stream.match(/^-?[0-9\\.]+/)){\n        if (isEndLine(stream)) {\n          state.cursorHalf = 0;\n        }\n        return \"number\";\n      }\n\n      // Units\n      if (stream.match(/^(px|em|in)\\b/)){\n        if (isEndLine(stream)) {\n          state.cursorHalf = 0;\n        }\n        return \"unit\";\n      }\n\n      if (stream.match(keywordsRegexp)){\n        if (isEndLine(stream)) {\n          state.cursorHalf = 0;\n        }\n        return \"keyword\";\n      }\n\n      if (stream.match(/^url/) && stream.peek() === \"(\") {\n        state.tokenizer = urlTokens;\n        if (isEndLine(stream)) {\n          state.cursorHalf = 0;\n        }\n        return \"atom\";\n      }\n\n      // Variables\n      if (ch === \"$\") {\n        stream.next();\n        stream.eatWhile(/[\\w-]/);\n        if (isEndLine(stream)) {\n          state.cursorHalf = 0;\n        }\n        return \"variable-2\";\n      }\n\n      // bang character for !important, !default, etc.\n      if (ch === \"!\") {\n        stream.next();\n        state.cursorHalf = 0;\n        return stream.match(/^[\\w]+/) ? \"keyword\": \"operator\";\n      }\n\n      if (stream.match(opRegexp)){\n        if (isEndLine(stream)) {\n          state.cursorHalf = 0;\n        }\n        return \"operator\";\n      }\n\n      // attributes\n      if (stream.eatWhile(/[\\w-]/)) {\n        if (isEndLine(stream)) {\n          state.cursorHalf = 0;\n        }\n        word = stream.current().toLowerCase();\n        if (valueKeywords.hasOwnProperty(word)) {\n          return \"atom\";\n        } else if (colorKeywords.hasOwnProperty(word)) {\n          return \"keyword\";\n        } else if (propertyKeywords.hasOwnProperty(word)) {\n          state.prevProp = stream.current().toLowerCase();\n          return \"property\";\n        } else {\n          return \"tag\";\n        }\n      }\n\n      //stream.eatSpace();\n      if (isEndLine(stream)) {\n        state.cursorHalf = 0;\n        return null;\n      }\n\n    } // else ends here\n\n    if (stream.match(opRegexp))\n      return \"operator\";\n\n    // If we haven't returned by now, we move 1 character\n    // and return an error\n    stream.next();\n    return null;\n  }\n\n  function tokenLexer(stream, state) {\n    if (stream.sol()) state.indentCount = 0;\n    var style = state.tokenizer(stream, state);\n    var current = stream.current();\n\n    if (current === \"@return\" || current === \"}\"){\n      dedent(state);\n    }\n\n    if (style !== null) {\n      var startOfToken = stream.pos - current.length;\n\n      var withCurrentIndent = startOfToken + (config.indentUnit * state.indentCount);\n\n      var newScopes = [];\n\n      for (var i = 0; i < state.scopes.length; i++) {\n        var scope = state.scopes[i];\n\n        if (scope.offset <= withCurrentIndent)\n          newScopes.push(scope);\n      }\n\n      state.scopes = newScopes;\n    }\n\n\n    return style;\n  }\n\n  return {\n    startState: function() {\n      return {\n        tokenizer: tokenBase,\n        scopes: [{offset: 0, type: \"sass\"}],\n        indentCount: 0,\n        cursorHalf: 0,  // cursor half tells us if cursor lies after (1)\n                        // or before (0) colon (well... more or less)\n        definedVars: [],\n        definedMixins: []\n      };\n    },\n    token: function(stream, state) {\n      var style = tokenLexer(stream, state);\n\n      state.lastToken = { style: style, content: stream.current() };\n\n      return style;\n    },\n\n    indent: function(state) {\n      return state.scopes[0].offset;\n    }\n  };\n}, \"css\");\n\nCodeMirror.defineMIME(\"text/x-sass\", \"sass\");\n\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n// Highlighting text that matches the selection\n//\n// Defines an option highlightSelectionMatches, which, when enabled,\n// will style strings that match the selection throughout the\n// document.\n//\n// The option can be set to true to simply enable it, or to a\n// {minChars, style, wordsOnly, showToken, delay} object to explicitly\n// configure it. minChars is the minimum amount of characters that should be\n// selected for the behavior to occur, and style is the token style to\n// apply to the matches. This will be prefixed by \"cm-\" to create an\n// actual CSS class name. If wordsOnly is enabled, the matches will be\n// highlighted only if the selected text is a word. showToken, when enabled,\n// will cause the current token to be highlighted when nothing is selected.\n// delay is used to specify how much time to wait, in milliseconds, before\n// highlighting the matches. If annotateScrollbar is enabled, the occurences\n// will be highlighted on the scrollbar via the matchesonscrollbar addon.\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"./matchesonscrollbar\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"./matchesonscrollbar\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var defaults = {\n    style: \"matchhighlight\",\n    minChars: 2,\n    delay: 100,\n    wordsOnly: false,\n    annotateScrollbar: false,\n    showToken: false,\n    trim: true\n  }\n\n  function State(options) {\n    this.options = {}\n    for (var name in defaults)\n      this.options[name] = (options && options.hasOwnProperty(name) ? options : defaults)[name]\n    this.overlay = this.timeout = null;\n    this.matchesonscroll = null;\n    this.active = false;\n  }\n\n  CodeMirror.defineOption(\"highlightSelectionMatches\", false, function(cm, val, old) {\n    if (old && old != CodeMirror.Init) {\n      removeOverlay(cm);\n      clearTimeout(cm.state.matchHighlighter.timeout);\n      cm.state.matchHighlighter = null;\n      cm.off(\"cursorActivity\", cursorActivity);\n      cm.off(\"focus\", onFocus)\n    }\n    if (val) {\n      var state = cm.state.matchHighlighter = new State(val);\n      if (cm.hasFocus()) {\n        state.active = true\n        highlightMatches(cm)\n      } else {\n        cm.on(\"focus\", onFocus)\n      }\n      cm.on(\"cursorActivity\", cursorActivity);\n    }\n  });\n\n  function cursorActivity(cm) {\n    var state = cm.state.matchHighlighter;\n    if (state.active || cm.hasFocus()) scheduleHighlight(cm, state)\n  }\n\n  function onFocus(cm) {\n    var state = cm.state.matchHighlighter\n    if (!state.active) {\n      state.active = true\n      scheduleHighlight(cm, state)\n    }\n  }\n\n  function scheduleHighlight(cm, state) {\n    clearTimeout(state.timeout);\n    state.timeout = setTimeout(function() {highlightMatches(cm);}, state.options.delay);\n  }\n\n  function addOverlay(cm, query, hasBoundary, style) {\n    var state = cm.state.matchHighlighter;\n    cm.addOverlay(state.overlay = makeOverlay(query, hasBoundary, style));\n    if (state.options.annotateScrollbar && cm.showMatchesOnScrollbar) {\n      var searchFor = hasBoundary ? new RegExp(\"\\\\b\" + query.replace(/[\\\\\\[.+*?(){|^$]/g, \"\\\\$&\") + \"\\\\b\") : query;\n      state.matchesonscroll = cm.showMatchesOnScrollbar(searchFor, false,\n        {className: \"CodeMirror-selection-highlight-scrollbar\"});\n    }\n  }\n\n  function removeOverlay(cm) {\n    var state = cm.state.matchHighlighter;\n    if (state.overlay) {\n      cm.removeOverlay(state.overlay);\n      state.overlay = null;\n      if (state.matchesonscroll) {\n        state.matchesonscroll.clear();\n        state.matchesonscroll = null;\n      }\n    }\n  }\n\n  function highlightMatches(cm) {\n    cm.operation(function() {\n      var state = cm.state.matchHighlighter;\n      removeOverlay(cm);\n      if (!cm.somethingSelected() && state.options.showToken) {\n        var re = state.options.showToken === true ? /[\\w$]/ : state.options.showToken;\n        var cur = cm.getCursor(), line = cm.getLine(cur.line), start = cur.ch, end = start;\n        while (start && re.test(line.charAt(start - 1))) --start;\n        while (end < line.length && re.test(line.charAt(end))) ++end;\n        if (start < end)\n          addOverlay(cm, line.slice(start, end), re, state.options.style);\n        return;\n      }\n      var from = cm.getCursor(\"from\"), to = cm.getCursor(\"to\");\n      if (from.line != to.line) return;\n      if (state.options.wordsOnly && !isWord(cm, from, to)) return;\n      var selection = cm.getRange(from, to)\n      if (state.options.trim) selection = selection.replace(/^\\s+|\\s+$/g, \"\")\n      if (selection.length >= state.options.minChars)\n        addOverlay(cm, selection, false, state.options.style);\n    });\n  }\n\n  function isWord(cm, from, to) {\n    var str = cm.getRange(from, to);\n    if (str.match(/^\\w+$/) !== null) {\n        if (from.ch > 0) {\n            var pos = {line: from.line, ch: from.ch - 1};\n            var chr = cm.getRange(pos, from);\n            if (chr.match(/\\W/) === null) return false;\n        }\n        if (to.ch < cm.getLine(from.line).length) {\n            var pos = {line: to.line, ch: to.ch + 1};\n            var chr = cm.getRange(to, pos);\n            if (chr.match(/\\W/) === null) return false;\n        }\n        return true;\n    } else return false;\n  }\n\n  function boundariesAround(stream, re) {\n    return (!stream.start || !re.test(stream.string.charAt(stream.start - 1))) &&\n      (stream.pos == stream.string.length || !re.test(stream.string.charAt(stream.pos)));\n  }\n\n  function makeOverlay(query, hasBoundary, style) {\n    return {token: function(stream) {\n      if (stream.match(query) &&\n          (!hasBoundary || boundariesAround(stream, hasBoundary)))\n        return style;\n      stream.next();\n      stream.skipTo(query.charAt(0)) || stream.skipToEnd();\n    }};\n  }\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n// Open simple dialogs on top of an editor. Relies on dialog.css.\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  function dialogDiv(cm, template, bottom) {\n    var wrap = cm.getWrapperElement();\n    var dialog;\n    dialog = wrap.appendChild(document.createElement(\"div\"));\n    if (bottom)\n      dialog.className = \"CodeMirror-dialog CodeMirror-dialog-bottom\";\n    else\n      dialog.className = \"CodeMirror-dialog CodeMirror-dialog-top\";\n\n    if (typeof template == \"string\") {\n      dialog.innerHTML = template;\n    } else { // Assuming it's a detached DOM element.\n      dialog.appendChild(template);\n    }\n    CodeMirror.addClass(wrap, 'dialog-opened');\n    return dialog;\n  }\n\n  function closeNotification(cm, newVal) {\n    if (cm.state.currentNotificationClose)\n      cm.state.currentNotificationClose();\n    cm.state.currentNotificationClose = newVal;\n  }\n\n  CodeMirror.defineExtension(\"openDialog\", function(template, callback, options) {\n    if (!options) options = {};\n\n    closeNotification(this, null);\n\n    var dialog = dialogDiv(this, template, options.bottom);\n    var closed = false, me = this;\n    function close(newVal) {\n      if (typeof newVal == 'string') {\n        inp.value = newVal;\n      } else {\n        if (closed) return;\n        closed = true;\n        CodeMirror.rmClass(dialog.parentNode, 'dialog-opened');\n        dialog.parentNode.removeChild(dialog);\n        me.focus();\n\n        if (options.onClose) options.onClose(dialog);\n      }\n    }\n\n    var inp = dialog.getElementsByTagName(\"input\")[0], button;\n    if (inp) {\n      inp.focus();\n\n      if (options.value) {\n        inp.value = options.value;\n        if (options.selectValueOnOpen !== false) {\n          inp.select();\n        }\n      }\n\n      if (options.onInput)\n        CodeMirror.on(inp, \"input\", function(e) { options.onInput(e, inp.value, close);});\n      if (options.onKeyUp)\n        CodeMirror.on(inp, \"keyup\", function(e) {options.onKeyUp(e, inp.value, close);});\n\n      CodeMirror.on(inp, \"keydown\", function(e) {\n        if (options && options.onKeyDown && options.onKeyDown(e, inp.value, close)) { return; }\n        if (e.keyCode == 27 || (options.closeOnEnter !== false && e.keyCode == 13)) {\n          inp.blur();\n          CodeMirror.e_stop(e);\n          close();\n        }\n        if (e.keyCode == 13) callback(inp.value, e);\n      });\n\n      if (options.closeOnBlur !== false) CodeMirror.on(inp, \"blur\", close);\n    } else if (button = dialog.getElementsByTagName(\"button\")[0]) {\n      CodeMirror.on(button, \"click\", function() {\n        close();\n        me.focus();\n      });\n\n      if (options.closeOnBlur !== false) CodeMirror.on(button, \"blur\", close);\n\n      button.focus();\n    }\n    return close;\n  });\n\n  CodeMirror.defineExtension(\"openConfirm\", function(template, callbacks, options) {\n    closeNotification(this, null);\n    var dialog = dialogDiv(this, template, options && options.bottom);\n    var buttons = dialog.getElementsByTagName(\"button\");\n    var closed = false, me = this, blurring = 1;\n    function close() {\n      if (closed) return;\n      closed = true;\n      CodeMirror.rmClass(dialog.parentNode, 'dialog-opened');\n      dialog.parentNode.removeChild(dialog);\n      me.focus();\n    }\n    buttons[0].focus();\n    for (var i = 0; i < buttons.length; ++i) {\n      var b = buttons[i];\n      (function(callback) {\n        CodeMirror.on(b, \"click\", function(e) {\n          CodeMirror.e_preventDefault(e);\n          close();\n          if (callback) callback(me);\n        });\n      })(callbacks[i]);\n      CodeMirror.on(b, \"blur\", function() {\n        --blurring;\n        setTimeout(function() { if (blurring <= 0) close(); }, 200);\n      });\n      CodeMirror.on(b, \"focus\", function() { ++blurring; });\n    }\n  });\n\n  /*\n   * openNotification\n   * Opens a notification, that can be closed with an optional timer\n   * (default 5000ms timer) and always closes on click.\n   *\n   * If a notification is opened while another is opened, it will close the\n   * currently opened one and open the new one immediately.\n   */\n  CodeMirror.defineExtension(\"openNotification\", function(template, options) {\n    closeNotification(this, close);\n    var dialog = dialogDiv(this, template, options && options.bottom);\n    var closed = false, doneTimer;\n    var duration = options && typeof options.duration !== \"undefined\" ? options.duration : 5000;\n\n    function close() {\n      if (closed) return;\n      closed = true;\n      clearTimeout(doneTimer);\n      CodeMirror.rmClass(dialog.parentNode, 'dialog-opened');\n      dialog.parentNode.removeChild(dialog);\n    }\n\n    CodeMirror.on(dialog, 'click', function(e) {\n      CodeMirror.e_preventDefault(e);\n      close();\n    });\n\n    if (duration)\n      doneTimer = setTimeout(close, duration);\n\n    return close;\n  });\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n  var WRAP_CLASS = \"CodeMirror-activeline\";\n  var BACK_CLASS = \"CodeMirror-activeline-background\";\n  var GUTT_CLASS = \"CodeMirror-activeline-gutter\";\n\n  CodeMirror.defineOption(\"styleActiveLine\", false, function(cm, val, old) {\n    var prev = old == CodeMirror.Init ? false : old;\n    if (val == prev) return\n    if (prev) {\n      cm.off(\"beforeSelectionChange\", selectionChange);\n      clearActiveLines(cm);\n      delete cm.state.activeLines;\n    }\n    if (val) {\n      cm.state.activeLines = [];\n      updateActiveLines(cm, cm.listSelections());\n      cm.on(\"beforeSelectionChange\", selectionChange);\n    }\n  });\n\n  function clearActiveLines(cm) {\n    for (var i = 0; i < cm.state.activeLines.length; i++) {\n      cm.removeLineClass(cm.state.activeLines[i], \"wrap\", WRAP_CLASS);\n      cm.removeLineClass(cm.state.activeLines[i], \"background\", BACK_CLASS);\n      cm.removeLineClass(cm.state.activeLines[i], \"gutter\", GUTT_CLASS);\n    }\n  }\n\n  function sameArray(a, b) {\n    if (a.length != b.length) return false;\n    for (var i = 0; i < a.length; i++)\n      if (a[i] != b[i]) return false;\n    return true;\n  }\n\n  function updateActiveLines(cm, ranges) {\n    var active = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i];\n      var option = cm.getOption(\"styleActiveLine\");\n      if (typeof option == \"object\" && option.nonEmpty ? range.anchor.line != range.head.line : !range.empty())\n        continue\n      var line = cm.getLineHandleVisualStart(range.head.line);\n      if (active[active.length - 1] != line) active.push(line);\n    }\n    if (sameArray(cm.state.activeLines, active)) return;\n    cm.operation(function() {\n      clearActiveLines(cm);\n      for (var i = 0; i < active.length; i++) {\n        cm.addLineClass(active[i], \"wrap\", WRAP_CLASS);\n        cm.addLineClass(active[i], \"background\", BACK_CLASS);\n        cm.addLineClass(active[i], \"gutter\", GUTT_CLASS);\n      }\n      cm.state.activeLines = active;\n    });\n  }\n\n  function selectionChange(cm, sel) {\n    updateActiveLines(cm, sel.ranges);\n  }\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  var Pos = CodeMirror.Pos;\n\n  function forEach(arr, f) {\n    for (var i = 0, e = arr.length; i < e; ++i) f(arr[i]);\n  }\n\n  function arrayContains(arr, item) {\n    if (!Array.prototype.indexOf) {\n      var i = arr.length;\n      while (i--) {\n        if (arr[i] === item) {\n          return true;\n        }\n      }\n      return false;\n    }\n    return arr.indexOf(item) != -1;\n  }\n\n  function scriptHint(editor, keywords, getToken, options) {\n    // Find the token at the cursor\n    var cur = editor.getCursor(), token = getToken(editor, cur);\n    if (/\\b(?:string|comment)\\b/.test(token.type)) return;\n    var innerMode = CodeMirror.innerMode(editor.getMode(), token.state);\n    if (innerMode.mode.helperType === \"json\") return;\n    token.state = innerMode.state;\n\n    // If it's not a 'word-style' token, ignore the token.\n    if (!/^[\\w$_]*$/.test(token.string)) {\n      token = {start: cur.ch, end: cur.ch, string: \"\", state: token.state,\n               type: token.string == \".\" ? \"property\" : null};\n    } else if (token.end > cur.ch) {\n      token.end = cur.ch;\n      token.string = token.string.slice(0, cur.ch - token.start);\n    }\n\n    var tprop = token;\n    // If it is a property, find out what it is a property of.\n    while (tprop.type == \"property\") {\n      tprop = getToken(editor, Pos(cur.line, tprop.start));\n      if (tprop.string != \".\") return;\n      tprop = getToken(editor, Pos(cur.line, tprop.start));\n      if (!context) var context = [];\n      context.push(tprop);\n    }\n    return {list: getCompletions(token, context, keywords, options),\n            from: Pos(cur.line, token.start),\n            to: Pos(cur.line, token.end)};\n  }\n\n  function javascriptHint(editor, options) {\n    return scriptHint(editor, javascriptKeywords,\n                      function (e, cur) {return e.getTokenAt(cur);},\n                      options);\n  };\n  CodeMirror.registerHelper(\"hint\", \"javascript\", javascriptHint);\n\n  function getCoffeeScriptToken(editor, cur) {\n  // This getToken, it is for coffeescript, imitates the behavior of\n  // getTokenAt method in javascript.js, that is, returning \"property\"\n  // type and treat \".\" as indepenent token.\n    var token = editor.getTokenAt(cur);\n    if (cur.ch == token.start + 1 && token.string.charAt(0) == '.') {\n      token.end = token.start;\n      token.string = '.';\n      token.type = \"property\";\n    }\n    else if (/^\\.[\\w$_]*$/.test(token.string)) {\n      token.type = \"property\";\n      token.start++;\n      token.string = token.string.replace(/\\./, '');\n    }\n    return token;\n  }\n\n  function coffeescriptHint(editor, options) {\n    return scriptHint(editor, coffeescriptKeywords, getCoffeeScriptToken, options);\n  }\n  CodeMirror.registerHelper(\"hint\", \"coffeescript\", coffeescriptHint);\n\n  var stringProps = (\"charAt charCodeAt indexOf lastIndexOf substring substr slice trim trimLeft trimRight \" +\n                     \"toUpperCase toLowerCase split concat match replace search\").split(\" \");\n  var arrayProps = (\"length concat join splice push pop shift unshift slice reverse sort indexOf \" +\n                    \"lastIndexOf every some filter forEach map reduce reduceRight \").split(\" \");\n  var funcProps = \"prototype apply call bind\".split(\" \");\n  var javascriptKeywords = (\"break case catch class const continue debugger default delete do else export extends false finally for function \" +\n                  \"if in import instanceof new null return super switch this throw true try typeof var void while with yield\").split(\" \");\n  var coffeescriptKeywords = (\"and break catch class continue delete do else extends false finally for \" +\n                  \"if in instanceof isnt new no not null of off on or return switch then throw true try typeof until void while with yes\").split(\" \");\n\n  function forAllProps(obj, callback) {\n    if (!Object.getOwnPropertyNames || !Object.getPrototypeOf) {\n      for (var name in obj) callback(name)\n    } else {\n      for (var o = obj; o; o = Object.getPrototypeOf(o))\n        Object.getOwnPropertyNames(o).forEach(callback)\n    }\n  }\n\n  function getCompletions(token, context, keywords, options) {\n    var found = [], start = token.string, global = options && options.globalScope || window;\n    function maybeAdd(str) {\n      if (str.lastIndexOf(start, 0) == 0 && !arrayContains(found, str)) found.push(str);\n    }\n    function gatherCompletions(obj) {\n      if (typeof obj == \"string\") forEach(stringProps, maybeAdd);\n      else if (obj instanceof Array) forEach(arrayProps, maybeAdd);\n      else if (obj instanceof Function) forEach(funcProps, maybeAdd);\n      forAllProps(obj, maybeAdd)\n    }\n\n    if (context && context.length) {\n      // If this is a property, see if it belongs to some object we can\n      // find in the current environment.\n      var obj = context.pop(), base;\n      if (obj.type && obj.type.indexOf(\"variable\") === 0) {\n        if (options && options.additionalContext)\n          base = options.additionalContext[obj.string];\n        if (!options || options.useGlobalScope !== false)\n          base = base || global[obj.string];\n      } else if (obj.type == \"string\") {\n        base = \"\";\n      } else if (obj.type == \"atom\") {\n        base = 1;\n      } else if (obj.type == \"function\") {\n        if (global.jQuery != null && (obj.string == '$' || obj.string == 'jQuery') &&\n            (typeof global.jQuery == 'function'))\n          base = global.jQuery();\n        else if (global._ != null && (obj.string == '_') && (typeof global._ == 'function'))\n          base = global._();\n      }\n      while (base != null && context.length)\n        base = base[context.pop().string];\n      if (base != null) gatherCompletions(base);\n    } else {\n      // If not, just look in the global object and any local scope\n      // (reading into JS mode internals to get at the local and global variables)\n      for (var v = token.state.localVars; v; v = v.next) maybeAdd(v.name);\n      for (var v = token.state.globalVars; v; v = v.next) maybeAdd(v.name);\n      if (!options || options.useGlobalScope !== false)\n        gatherCompletions(global);\n      forEach(keywords, maybeAdd);\n    }\n    return found;\n  }\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"../htmlmixed/htmlmixed\"), require(\"../clike/clike\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"../htmlmixed/htmlmixed\", \"../clike/clike\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  function keywords(str) {\n    var obj = {}, words = str.split(\" \");\n    for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\n    return obj;\n  }\n\n  // Helper for phpString\n  function matchSequence(list, end, escapes) {\n    if (list.length == 0) return phpString(end);\n    return function (stream, state) {\n      var patterns = list[0];\n      for (var i = 0; i < patterns.length; i++) if (stream.match(patterns[i][0])) {\n        state.tokenize = matchSequence(list.slice(1), end);\n        return patterns[i][1];\n      }\n      state.tokenize = phpString(end, escapes);\n      return \"string\";\n    };\n  }\n  function phpString(closing, escapes) {\n    return function(stream, state) { return phpString_(stream, state, closing, escapes); };\n  }\n  function phpString_(stream, state, closing, escapes) {\n    // \"Complex\" syntax\n    if (escapes !== false && stream.match(\"${\", false) || stream.match(\"{$\", false)) {\n      state.tokenize = null;\n      return \"string\";\n    }\n\n    // Simple syntax\n    if (escapes !== false && stream.match(/^\\$[a-zA-Z_][a-zA-Z0-9_]*/)) {\n      // After the variable name there may appear array or object operator.\n      if (stream.match(\"[\", false)) {\n        // Match array operator\n        state.tokenize = matchSequence([\n          [[\"[\", null]],\n          [[/\\d[\\w\\.]*/, \"number\"],\n           [/\\$[a-zA-Z_][a-zA-Z0-9_]*/, \"variable-2\"],\n           [/[\\w\\$]+/, \"variable\"]],\n          [[\"]\", null]]\n        ], closing, escapes);\n      }\n      if (stream.match(/\\-\\>\\w/, false)) {\n        // Match object operator\n        state.tokenize = matchSequence([\n          [[\"->\", null]],\n          [[/[\\w]+/, \"variable\"]]\n        ], closing, escapes);\n      }\n      return \"variable-2\";\n    }\n\n    var escaped = false;\n    // Normal string\n    while (!stream.eol() &&\n           (escaped || escapes === false ||\n            (!stream.match(\"{$\", false) &&\n             !stream.match(/^(\\$[a-zA-Z_][a-zA-Z0-9_]*|\\$\\{)/, false)))) {\n      if (!escaped && stream.match(closing)) {\n        state.tokenize = null;\n        state.tokStack.pop(); state.tokStack.pop();\n        break;\n      }\n      escaped = stream.next() == \"\\\\\" && !escaped;\n    }\n    return \"string\";\n  }\n\n  var phpKeywords = \"abstract and array as break case catch class clone const continue declare default \" +\n    \"do else elseif enddeclare endfor endforeach endif endswitch endwhile extends final \" +\n    \"for foreach function global goto if implements interface instanceof namespace \" +\n    \"new or private protected public static switch throw trait try use var while xor \" +\n    \"die echo empty exit eval include include_once isset list require require_once return \" +\n    \"print unset __halt_compiler self static parent yield insteadof finally\";\n  var phpAtoms = \"true false null TRUE FALSE NULL __CLASS__ __DIR__ __FILE__ __LINE__ __METHOD__ __FUNCTION__ __NAMESPACE__ __TRAIT__\";\n  var phpBuiltin = \"func_num_args func_get_arg func_get_args strlen strcmp strncmp strcasecmp strncasecmp each error_reporting define defined trigger_error user_error set_error_handler restore_error_handler get_declared_classes get_loaded_extensions extension_loaded get_extension_funcs debug_backtrace constant bin2hex hex2bin sleep usleep time mktime gmmktime strftime gmstrftime strtotime date gmdate getdate localtime checkdate flush wordwrap htmlspecialchars htmlentities html_entity_decode md5 md5_file crc32 getimagesize image_type_to_mime_type phpinfo phpversion phpcredits strnatcmp strnatcasecmp substr_count strspn strcspn strtok strtoupper strtolower strpos strrpos strrev hebrev hebrevc nl2br basename dirname pathinfo stripslashes stripcslashes strstr stristr strrchr str_shuffle str_word_count strcoll substr substr_replace quotemeta ucfirst ucwords strtr addslashes addcslashes rtrim str_replace str_repeat count_chars chunk_split trim ltrim strip_tags similar_text explode implode setlocale localeconv parse_str str_pad chop strchr sprintf printf vprintf vsprintf sscanf fscanf parse_url urlencode urldecode rawurlencode rawurldecode readlink linkinfo link unlink exec system escapeshellcmd escapeshellarg passthru shell_exec proc_open proc_close rand srand getrandmax mt_rand mt_srand mt_getrandmax base64_decode base64_encode abs ceil floor round is_finite is_nan is_infinite bindec hexdec octdec decbin decoct dechex base_convert number_format fmod ip2long long2ip getenv putenv getopt microtime gettimeofday getrusage uniqid quoted_printable_decode set_time_limit get_cfg_var magic_quotes_runtime set_magic_quotes_runtime get_magic_quotes_gpc get_magic_quotes_runtime import_request_variables error_log serialize unserialize memory_get_usage var_dump var_export debug_zval_dump print_r highlight_file show_source highlight_string ini_get ini_get_all ini_set ini_alter ini_restore get_include_path set_include_path restore_include_path setcookie header headers_sent connection_aborted connection_status ignore_user_abort parse_ini_file is_uploaded_file move_uploaded_file intval floatval doubleval strval gettype settype is_null is_resource is_bool is_long is_float is_int is_integer is_double is_real is_numeric is_string is_array is_object is_scalar ereg ereg_replace eregi eregi_replace split spliti join sql_regcase dl pclose popen readfile rewind rmdir umask fclose feof fgetc fgets fgetss fread fopen fpassthru ftruncate fstat fseek ftell fflush fwrite fputs mkdir rename copy tempnam tmpfile file file_get_contents file_put_contents stream_select stream_context_create stream_context_set_params stream_context_set_option stream_context_get_options stream_filter_prepend stream_filter_append fgetcsv flock get_meta_tags stream_set_write_buffer set_file_buffer set_socket_blocking stream_set_blocking socket_set_blocking stream_get_meta_data stream_register_wrapper stream_wrapper_register stream_set_timeout socket_set_timeout socket_get_status realpath fnmatch fsockopen pfsockopen pack unpack get_browser crypt opendir closedir chdir getcwd rewinddir readdir dir glob fileatime filectime filegroup fileinode filemtime fileowner fileperms filesize filetype file_exists is_writable is_writeable is_readable is_executable is_file is_dir is_link stat lstat chown touch clearstatcache mail ob_start ob_flush ob_clean ob_end_flush ob_end_clean ob_get_flush ob_get_clean ob_get_length ob_get_level ob_get_status ob_get_contents ob_implicit_flush ob_list_handlers ksort krsort natsort natcasesort asort arsort sort rsort usort uasort uksort shuffle array_walk count end prev next reset current key min max in_array array_search extract compact array_fill range array_multisort array_push array_pop array_shift array_unshift array_splice array_slice array_merge array_merge_recursive array_keys array_values array_count_values array_reverse array_reduce array_pad array_flip array_change_key_case array_rand array_unique array_intersect array_intersect_assoc array_diff array_diff_assoc array_sum array_filter array_map array_chunk array_key_exists array_intersect_key array_combine array_column pos sizeof key_exists assert assert_options version_compare ftok str_rot13 aggregate session_name session_module_name session_save_path session_id session_regenerate_id session_decode session_register session_unregister session_is_registered session_encode session_start session_destroy session_unset session_set_save_handler session_cache_limiter session_cache_expire session_set_cookie_params session_get_cookie_params session_write_close preg_match preg_match_all preg_replace preg_replace_callback preg_split preg_quote preg_grep overload ctype_alnum ctype_alpha ctype_cntrl ctype_digit ctype_lower ctype_graph ctype_print ctype_punct ctype_space ctype_upper ctype_xdigit virtual apache_request_headers apache_note apache_lookup_uri apache_child_terminate apache_setenv apache_response_headers apache_get_version getallheaders mysql_connect mysql_pconnect mysql_close mysql_select_db mysql_create_db mysql_drop_db mysql_query mysql_unbuffered_query mysql_db_query mysql_list_dbs mysql_list_tables mysql_list_fields mysql_list_processes mysql_error mysql_errno mysql_affected_rows mysql_insert_id mysql_result mysql_num_rows mysql_num_fields mysql_fetch_row mysql_fetch_array mysql_fetch_assoc mysql_fetch_object mysql_data_seek mysql_fetch_lengths mysql_fetch_field mysql_field_seek mysql_free_result mysql_field_name mysql_field_table mysql_field_len mysql_field_type mysql_field_flags mysql_escape_string mysql_real_escape_string mysql_stat mysql_thread_id mysql_client_encoding mysql_get_client_info mysql_get_host_info mysql_get_proto_info mysql_get_server_info mysql_info mysql mysql_fieldname mysql_fieldtable mysql_fieldlen mysql_fieldtype mysql_fieldflags mysql_selectdb mysql_createdb mysql_dropdb mysql_freeresult mysql_numfields mysql_numrows mysql_listdbs mysql_listtables mysql_listfields mysql_db_name mysql_dbname mysql_tablename mysql_table_name pg_connect pg_pconnect pg_close pg_connection_status pg_connection_busy pg_connection_reset pg_host pg_dbname pg_port pg_tty pg_options pg_ping pg_query pg_send_query pg_cancel_query pg_fetch_result pg_fetch_row pg_fetch_assoc pg_fetch_array pg_fetch_object pg_fetch_all pg_affected_rows pg_get_result pg_result_seek pg_result_status pg_free_result pg_last_oid pg_num_rows pg_num_fields pg_field_name pg_field_num pg_field_size pg_field_type pg_field_prtlen pg_field_is_null pg_get_notify pg_get_pid pg_result_error pg_last_error pg_last_notice pg_put_line pg_end_copy pg_copy_to pg_copy_from pg_trace pg_untrace pg_lo_create pg_lo_unlink pg_lo_open pg_lo_close pg_lo_read pg_lo_write pg_lo_read_all pg_lo_import pg_lo_export pg_lo_seek pg_lo_tell pg_escape_string pg_escape_bytea pg_unescape_bytea pg_client_encoding pg_set_client_encoding pg_meta_data pg_convert pg_insert pg_update pg_delete pg_select pg_exec pg_getlastoid pg_cmdtuples pg_errormessage pg_numrows pg_numfields pg_fieldname pg_fieldsize pg_fieldtype pg_fieldnum pg_fieldprtlen pg_fieldisnull pg_freeresult pg_result pg_loreadall pg_locreate pg_lounlink pg_loopen pg_loclose pg_loread pg_lowrite pg_loimport pg_loexport http_response_code get_declared_traits getimagesizefromstring socket_import_stream stream_set_chunk_size trait_exists header_register_callback class_uses session_status session_register_shutdown echo print global static exit array empty eval isset unset die include require include_once require_once json_decode json_encode json_last_error json_last_error_msg curl_close curl_copy_handle curl_errno curl_error curl_escape curl_exec curl_file_create curl_getinfo curl_init curl_multi_add_handle curl_multi_close curl_multi_exec curl_multi_getcontent curl_multi_info_read curl_multi_init curl_multi_remove_handle curl_multi_select curl_multi_setopt curl_multi_strerror curl_pause curl_reset curl_setopt_array curl_setopt curl_share_close curl_share_init curl_share_setopt curl_strerror curl_unescape curl_version mysqli_affected_rows mysqli_autocommit mysqli_change_user mysqli_character_set_name mysqli_close mysqli_commit mysqli_connect_errno mysqli_connect_error mysqli_connect mysqli_data_seek mysqli_debug mysqli_dump_debug_info mysqli_errno mysqli_error_list mysqli_error mysqli_fetch_all mysqli_fetch_array mysqli_fetch_assoc mysqli_fetch_field_direct mysqli_fetch_field mysqli_fetch_fields mysqli_fetch_lengths mysqli_fetch_object mysqli_fetch_row mysqli_field_count mysqli_field_seek mysqli_field_tell mysqli_free_result mysqli_get_charset mysqli_get_client_info mysqli_get_client_stats mysqli_get_client_version mysqli_get_connection_stats mysqli_get_host_info mysqli_get_proto_info mysqli_get_server_info mysqli_get_server_version mysqli_info mysqli_init mysqli_insert_id mysqli_kill mysqli_more_results mysqli_multi_query mysqli_next_result mysqli_num_fields mysqli_num_rows mysqli_options mysqli_ping mysqli_prepare mysqli_query mysqli_real_connect mysqli_real_escape_string mysqli_real_query mysqli_reap_async_query mysqli_refresh mysqli_rollback mysqli_select_db mysqli_set_charset mysqli_set_local_infile_default mysqli_set_local_infile_handler mysqli_sqlstate mysqli_ssl_set mysqli_stat mysqli_stmt_init mysqli_store_result mysqli_thread_id mysqli_thread_safe mysqli_use_result mysqli_warning_count\";\n  CodeMirror.registerHelper(\"hintWords\", \"php\", [phpKeywords, phpAtoms, phpBuiltin].join(\" \").split(\" \"));\n  CodeMirror.registerHelper(\"wordChars\", \"php\", /[\\w$]/);\n\n  var phpConfig = {\n    name: \"clike\",\n    helperType: \"php\",\n    keywords: keywords(phpKeywords),\n    blockKeywords: keywords(\"catch do else elseif for foreach if switch try while finally\"),\n    defKeywords: keywords(\"class function interface namespace trait\"),\n    atoms: keywords(phpAtoms),\n    builtin: keywords(phpBuiltin),\n    multiLineStrings: true,\n    hooks: {\n      \"$\": function(stream) {\n        stream.eatWhile(/[\\w\\$_]/);\n        return \"variable-2\";\n      },\n      \"<\": function(stream, state) {\n        var before;\n        if (before = stream.match(/<<\\s*/)) {\n          var quoted = stream.eat(/['\"]/);\n          stream.eatWhile(/[\\w\\.]/);\n          var delim = stream.current().slice(before[0].length + (quoted ? 2 : 1));\n          if (quoted) stream.eat(quoted);\n          if (delim) {\n            (state.tokStack || (state.tokStack = [])).push(delim, 0);\n            state.tokenize = phpString(delim, quoted != \"'\");\n            return \"string\";\n          }\n        }\n        return false;\n      },\n      \"#\": function(stream) {\n        while (!stream.eol() && !stream.match(\"?>\", false)) stream.next();\n        return \"comment\";\n      },\n      \"/\": function(stream) {\n        if (stream.eat(\"/\")) {\n          while (!stream.eol() && !stream.match(\"?>\", false)) stream.next();\n          return \"comment\";\n        }\n        return false;\n      },\n      '\"': function(_stream, state) {\n        (state.tokStack || (state.tokStack = [])).push('\"', 0);\n        state.tokenize = phpString('\"');\n        return \"string\";\n      },\n      \"{\": function(_stream, state) {\n        if (state.tokStack && state.tokStack.length)\n          state.tokStack[state.tokStack.length - 1]++;\n        return false;\n      },\n      \"}\": function(_stream, state) {\n        if (state.tokStack && state.tokStack.length > 0 &&\n            !--state.tokStack[state.tokStack.length - 1]) {\n          state.tokenize = phpString(state.tokStack[state.tokStack.length - 2]);\n        }\n        return false;\n      }\n    }\n  };\n\n  CodeMirror.defineMode(\"php\", function(config, parserConfig) {\n    var htmlMode = CodeMirror.getMode(config, (parserConfig && parserConfig.htmlMode) || \"text/html\");\n    var phpMode = CodeMirror.getMode(config, phpConfig);\n\n    function dispatch(stream, state) {\n      var isPHP = state.curMode == phpMode;\n      if (stream.sol() && state.pending && state.pending != '\"' && state.pending != \"'\") state.pending = null;\n      if (!isPHP) {\n        if (stream.match(/^<\\?\\w*/)) {\n          state.curMode = phpMode;\n          if (!state.php) state.php = CodeMirror.startState(phpMode, htmlMode.indent(state.html, \"\", \"\"))\n          state.curState = state.php;\n          return \"meta\";\n        }\n        if (state.pending == '\"' || state.pending == \"'\") {\n          while (!stream.eol() && stream.next() != state.pending) {}\n          var style = \"string\";\n        } else if (state.pending && stream.pos < state.pending.end) {\n          stream.pos = state.pending.end;\n          var style = state.pending.style;\n        } else {\n          var style = htmlMode.token(stream, state.curState);\n        }\n        if (state.pending) state.pending = null;\n        var cur = stream.current(), openPHP = cur.search(/<\\?/), m;\n        if (openPHP != -1) {\n          if (style == \"string\" && (m = cur.match(/[\\'\\\"]$/)) && !/\\?>/.test(cur)) state.pending = m[0];\n          else state.pending = {end: stream.pos, style: style};\n          stream.backUp(cur.length - openPHP);\n        }\n        return style;\n      } else if (isPHP && state.php.tokenize == null && stream.match(\"?>\")) {\n        state.curMode = htmlMode;\n        state.curState = state.html;\n        if (!state.php.context.prev) state.php = null;\n        return \"meta\";\n      } else {\n        return phpMode.token(stream, state.curState);\n      }\n    }\n\n    return {\n      startState: function() {\n        var html = CodeMirror.startState(htmlMode)\n        var php = parserConfig.startOpen ? CodeMirror.startState(phpMode) : null\n        return {html: html,\n                php: php,\n                curMode: parserConfig.startOpen ? phpMode : htmlMode,\n                curState: parserConfig.startOpen ? php : html,\n                pending: null};\n      },\n\n      copyState: function(state) {\n        var html = state.html, htmlNew = CodeMirror.copyState(htmlMode, html),\n            php = state.php, phpNew = php && CodeMirror.copyState(phpMode, php), cur;\n        if (state.curMode == htmlMode) cur = htmlNew;\n        else cur = phpNew;\n        return {html: htmlNew, php: phpNew, curMode: state.curMode, curState: cur,\n                pending: state.pending};\n      },\n\n      token: dispatch,\n\n      indent: function(state, textAfter, line) {\n        if ((state.curMode != phpMode && /^\\s*<\\//.test(textAfter)) ||\n            (state.curMode == phpMode && /^\\?>/.test(textAfter)))\n          return htmlMode.indent(state.html, textAfter, line);\n        return state.curMode.indent(state.curState, textAfter, line);\n      },\n\n      blockCommentStart: \"/*\",\n      blockCommentEnd: \"*/\",\n      lineComment: \"//\",\n\n      innerMode: function(state) { return {state: state.curState, mode: state.curMode}; }\n    };\n  }, \"htmlmixed\", \"clike\");\n\n  CodeMirror.defineMIME(\"application/x-httpd-php\", \"php\");\n  CodeMirror.defineMIME(\"application/x-httpd-php-open\", {name: \"php\", startOpen: true});\n  CodeMirror.defineMIME(\"text/x-php\", phpConfig);\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nfunction Context(indented, column, type, info, align, prev) {\n  this.indented = indented;\n  this.column = column;\n  this.type = type;\n  this.info = info;\n  this.align = align;\n  this.prev = prev;\n}\nfunction pushContext(state, col, type, info) {\n  var indent = state.indented;\n  if (state.context && state.context.type == \"statement\" && type != \"statement\")\n    indent = state.context.indented;\n  return state.context = new Context(indent, col, type, info, null, state.context);\n}\nfunction popContext(state) {\n  var t = state.context.type;\n  if (t == \")\" || t == \"]\" || t == \"}\")\n    state.indented = state.context.indented;\n  return state.context = state.context.prev;\n}\n\nfunction typeBefore(stream, state, pos) {\n  if (state.prevToken == \"variable\" || state.prevToken == \"type\") return true;\n  if (/\\S(?:[^- ]>|[*\\]])\\s*$|\\*$/.test(stream.string.slice(0, pos))) return true;\n  if (state.typeAtEndOfLine && stream.column() == stream.indentation()) return true;\n}\n\nfunction isTopScope(context) {\n  for (;;) {\n    if (!context || context.type == \"top\") return true;\n    if (context.type == \"}\" && context.prev.info != \"namespace\") return false;\n    context = context.prev;\n  }\n}\n\nCodeMirror.defineMode(\"clike\", function(config, parserConfig) {\n  var indentUnit = config.indentUnit,\n      statementIndentUnit = parserConfig.statementIndentUnit || indentUnit,\n      dontAlignCalls = parserConfig.dontAlignCalls,\n      keywords = parserConfig.keywords || {},\n      types = parserConfig.types || {},\n      builtin = parserConfig.builtin || {},\n      blockKeywords = parserConfig.blockKeywords || {},\n      defKeywords = parserConfig.defKeywords || {},\n      atoms = parserConfig.atoms || {},\n      hooks = parserConfig.hooks || {},\n      multiLineStrings = parserConfig.multiLineStrings,\n      indentStatements = parserConfig.indentStatements !== false,\n      indentSwitch = parserConfig.indentSwitch !== false,\n      namespaceSeparator = parserConfig.namespaceSeparator,\n      isPunctuationChar = parserConfig.isPunctuationChar || /[\\[\\]{}\\(\\),;\\:\\.]/,\n      numberStart = parserConfig.numberStart || /[\\d\\.]/,\n      number = parserConfig.number || /^(?:0x[a-f\\d]+|0b[01]+|(?:\\d+\\.?\\d*|\\.\\d+)(?:e[-+]?\\d+)?)(u|ll?|l|f)?/i,\n      isOperatorChar = parserConfig.isOperatorChar || /[+\\-*&%=<>!?|\\/]/,\n      isIdentifierChar = parserConfig.isIdentifierChar || /[\\w\\$_\\xa1-\\uffff]/,\n      // An optional function that takes a {string} token and returns true if it\n      // should be treated as a builtin.\n      isReservedIdentifier = parserConfig.isReservedIdentifier || false;\n\n  var curPunc, isDefKeyword;\n\n  function tokenBase(stream, state) {\n    var ch = stream.next();\n    if (hooks[ch]) {\n      var result = hooks[ch](stream, state);\n      if (result !== false) return result;\n    }\n    if (ch == '\"' || ch == \"'\") {\n      state.tokenize = tokenString(ch);\n      return state.tokenize(stream, state);\n    }\n    if (isPunctuationChar.test(ch)) {\n      curPunc = ch;\n      return null;\n    }\n    if (numberStart.test(ch)) {\n      stream.backUp(1)\n      if (stream.match(number)) return \"number\"\n      stream.next()\n    }\n    if (ch == \"/\") {\n      if (stream.eat(\"*\")) {\n        state.tokenize = tokenComment;\n        return tokenComment(stream, state);\n      }\n      if (stream.eat(\"/\")) {\n        stream.skipToEnd();\n        return \"comment\";\n      }\n    }\n    if (isOperatorChar.test(ch)) {\n      while (!stream.match(/^\\/[\\/*]/, false) && stream.eat(isOperatorChar)) {}\n      return \"operator\";\n    }\n    stream.eatWhile(isIdentifierChar);\n    if (namespaceSeparator) while (stream.match(namespaceSeparator))\n      stream.eatWhile(isIdentifierChar);\n\n    var cur = stream.current();\n    if (contains(keywords, cur)) {\n      if (contains(blockKeywords, cur)) curPunc = \"newstatement\";\n      if (contains(defKeywords, cur)) isDefKeyword = true;\n      return \"keyword\";\n    }\n    if (contains(types, cur)) return \"type\";\n    if (contains(builtin, cur)\n        || (isReservedIdentifier && isReservedIdentifier(cur))) {\n      if (contains(blockKeywords, cur)) curPunc = \"newstatement\";\n      return \"builtin\";\n    }\n    if (contains(atoms, cur)) return \"atom\";\n    return \"variable\";\n  }\n\n  function tokenString(quote) {\n    return function(stream, state) {\n      var escaped = false, next, end = false;\n      while ((next = stream.next()) != null) {\n        if (next == quote && !escaped) {end = true; break;}\n        escaped = !escaped && next == \"\\\\\";\n      }\n      if (end || !(escaped || multiLineStrings))\n        state.tokenize = null;\n      return \"string\";\n    };\n  }\n\n  function tokenComment(stream, state) {\n    var maybeEnd = false, ch;\n    while (ch = stream.next()) {\n      if (ch == \"/\" && maybeEnd) {\n        state.tokenize = null;\n        break;\n      }\n      maybeEnd = (ch == \"*\");\n    }\n    return \"comment\";\n  }\n\n  function maybeEOL(stream, state) {\n    if (parserConfig.typeFirstDefinitions && stream.eol() && isTopScope(state.context))\n      state.typeAtEndOfLine = typeBefore(stream, state, stream.pos)\n  }\n\n  // Interface\n\n  return {\n    startState: function(basecolumn) {\n      return {\n        tokenize: null,\n        context: new Context((basecolumn || 0) - indentUnit, 0, \"top\", null, false),\n        indented: 0,\n        startOfLine: true,\n        prevToken: null\n      };\n    },\n\n    token: function(stream, state) {\n      var ctx = state.context;\n      if (stream.sol()) {\n        if (ctx.align == null) ctx.align = false;\n        state.indented = stream.indentation();\n        state.startOfLine = true;\n      }\n      if (stream.eatSpace()) { maybeEOL(stream, state); return null; }\n      curPunc = isDefKeyword = null;\n      var style = (state.tokenize || tokenBase)(stream, state);\n      if (style == \"comment\" || style == \"meta\") return style;\n      if (ctx.align == null) ctx.align = true;\n\n      if (curPunc == \";\" || curPunc == \":\" || (curPunc == \",\" && stream.match(/^\\s*(?:\\/\\/.*)?$/, false)))\n        while (state.context.type == \"statement\") popContext(state);\n      else if (curPunc == \"{\") pushContext(state, stream.column(), \"}\");\n      else if (curPunc == \"[\") pushContext(state, stream.column(), \"]\");\n      else if (curPunc == \"(\") pushContext(state, stream.column(), \")\");\n      else if (curPunc == \"}\") {\n        while (ctx.type == \"statement\") ctx = popContext(state);\n        if (ctx.type == \"}\") ctx = popContext(state);\n        while (ctx.type == \"statement\") ctx = popContext(state);\n      }\n      else if (curPunc == ctx.type) popContext(state);\n      else if (indentStatements &&\n               (((ctx.type == \"}\" || ctx.type == \"top\") && curPunc != \";\") ||\n                (ctx.type == \"statement\" && curPunc == \"newstatement\"))) {\n        pushContext(state, stream.column(), \"statement\", stream.current());\n      }\n\n      if (style == \"variable\" &&\n          ((state.prevToken == \"def\" ||\n            (parserConfig.typeFirstDefinitions && typeBefore(stream, state, stream.start) &&\n             isTopScope(state.context) && stream.match(/^\\s*\\(/, false)))))\n        style = \"def\";\n\n      if (hooks.token) {\n        var result = hooks.token(stream, state, style);\n        if (result !== undefined) style = result;\n      }\n\n      if (style == \"def\" && parserConfig.styleDefs === false) style = \"variable\";\n\n      state.startOfLine = false;\n      state.prevToken = isDefKeyword ? \"def\" : style || curPunc;\n      maybeEOL(stream, state);\n      return style;\n    },\n\n    indent: function(state, textAfter) {\n      if (state.tokenize != tokenBase && state.tokenize != null || state.typeAtEndOfLine) return CodeMirror.Pass;\n      var ctx = state.context, firstChar = textAfter && textAfter.charAt(0);\n      var closing = firstChar == ctx.type;\n      if (ctx.type == \"statement\" && firstChar == \"}\") ctx = ctx.prev;\n      if (parserConfig.dontIndentStatements)\n        while (ctx.type == \"statement\" && parserConfig.dontIndentStatements.test(ctx.info))\n          ctx = ctx.prev\n      if (hooks.indent) {\n        var hook = hooks.indent(state, ctx, textAfter, indentUnit);\n        if (typeof hook == \"number\") return hook\n      }\n      var switchBlock = ctx.prev && ctx.prev.info == \"switch\";\n      if (parserConfig.allmanIndentation && /[{(]/.test(firstChar)) {\n        while (ctx.type != \"top\" && ctx.type != \"}\") ctx = ctx.prev\n        return ctx.indented\n      }\n      if (ctx.type == \"statement\")\n        return ctx.indented + (firstChar == \"{\" ? 0 : statementIndentUnit);\n      if (ctx.align && (!dontAlignCalls || ctx.type != \")\"))\n        return ctx.column + (closing ? 0 : 1);\n      if (ctx.type == \")\" && !closing)\n        return ctx.indented + statementIndentUnit;\n\n      return ctx.indented + (closing ? 0 : indentUnit) +\n        (!closing && switchBlock && !/^(?:case|default)\\b/.test(textAfter) ? indentUnit : 0);\n    },\n\n    electricInput: indentSwitch ? /^\\s*(?:case .*?:|default:|\\{\\}?|\\})$/ : /^\\s*[{}]$/,\n    blockCommentStart: \"/*\",\n    blockCommentEnd: \"*/\",\n    blockCommentContinue: \" * \",\n    lineComment: \"//\",\n    fold: \"brace\"\n  };\n});\n\n  function words(str) {\n    var obj = {}, words = str.split(\" \");\n    for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\n    return obj;\n  }\n  function contains(words, word) {\n    if (typeof words === \"function\") {\n      return words(word);\n    } else {\n      return words.propertyIsEnumerable(word);\n    }\n  }\n  var cKeywords = \"auto if break case register continue return default do sizeof \" +\n    \"static else struct switch extern typedef union for goto while enum const \" +\n    \"volatile inline restrict asm fortran\";\n\n  // Do not use this. Use the cTypes function below. This is global just to avoid\n  // excessive calls when cTypes is being called multiple times during a parse.\n  var basicCTypes = words(\"int long char short double float unsigned signed \" +\n    \"void bool\");\n\n  // Do not use this. Use the objCTypes function below. This is global just to avoid\n  // excessive calls when objCTypes is being called multiple times during a parse.\n  var basicObjCTypes = words(\"SEL instancetype id Class Protocol BOOL\");\n\n  // Returns true if identifier is a \"C\" type.\n  // C type is defined as those that are reserved by the compiler (basicTypes),\n  // and those that end in _t (Reserved by POSIX for types)\n  // http://www.gnu.org/software/libc/manual/html_node/Reserved-Names.html\n  function cTypes(identifier) {\n    return contains(basicCTypes, identifier) || /.+_t$/.test(identifier);\n  }\n\n  // Returns true if identifier is a \"Objective C\" type.\n  function objCTypes(identifier) {\n    return cTypes(identifier) || contains(basicObjCTypes, identifier);\n  }\n\n  var cBlockKeywords = \"case do else for if switch while struct enum union\";\n  var cDefKeywords = \"struct enum union\";\n\n  function cppHook(stream, state) {\n    if (!state.startOfLine) return false\n    for (var ch, next = null; ch = stream.peek();) {\n      if (ch == \"\\\\\" && stream.match(/^.$/)) {\n        next = cppHook\n        break\n      } else if (ch == \"/\" && stream.match(/^\\/[\\/\\*]/, false)) {\n        break\n      }\n      stream.next()\n    }\n    state.tokenize = next\n    return \"meta\"\n  }\n\n  function pointerHook(_stream, state) {\n    if (state.prevToken == \"type\") return \"type\";\n    return false;\n  }\n\n  // For C and C++ (and ObjC): identifiers starting with __\n  // or _ followed by a capital letter are reserved for the compiler.\n  function cIsReservedIdentifier(token) {\n    if (!token || token.length < 2) return false;\n    if (token[0] != '_') return false;\n    return (token[1] == '_') || (token[1] !== token[1].toLowerCase());\n  }\n\n  function cpp14Literal(stream) {\n    stream.eatWhile(/[\\w\\.']/);\n    return \"number\";\n  }\n\n  function cpp11StringHook(stream, state) {\n    stream.backUp(1);\n    // Raw strings.\n    if (stream.match(/(R|u8R|uR|UR|LR)/)) {\n      var match = stream.match(/\"([^\\s\\\\()]{0,16})\\(/);\n      if (!match) {\n        return false;\n      }\n      state.cpp11RawStringDelim = match[1];\n      state.tokenize = tokenRawString;\n      return tokenRawString(stream, state);\n    }\n    // Unicode strings/chars.\n    if (stream.match(/(u8|u|U|L)/)) {\n      if (stream.match(/[\"']/, /* eat */ false)) {\n        return \"string\";\n      }\n      return false;\n    }\n    // Ignore this hook.\n    stream.next();\n    return false;\n  }\n\n  function cppLooksLikeConstructor(word) {\n    var lastTwo = /(\\w+)::~?(\\w+)$/.exec(word);\n    return lastTwo && lastTwo[1] == lastTwo[2];\n  }\n\n  // C#-style strings where \"\" escapes a quote.\n  function tokenAtString(stream, state) {\n    var next;\n    while ((next = stream.next()) != null) {\n      if (next == '\"' && !stream.eat('\"')) {\n        state.tokenize = null;\n        break;\n      }\n    }\n    return \"string\";\n  }\n\n  // C++11 raw string literal is <prefix>\"<delim>( anything )<delim>\", where\n  // <delim> can be a string up to 16 characters long.\n  function tokenRawString(stream, state) {\n    // Escape characters that have special regex meanings.\n    var delim = state.cpp11RawStringDelim.replace(/[^\\w\\s]/g, '\\\\$&');\n    var match = stream.match(new RegExp(\".*?\\\\)\" + delim + '\"'));\n    if (match)\n      state.tokenize = null;\n    else\n      stream.skipToEnd();\n    return \"string\";\n  }\n\n  function def(mimes, mode) {\n    if (typeof mimes == \"string\") mimes = [mimes];\n    var words = [];\n    function add(obj) {\n      if (obj) for (var prop in obj) if (obj.hasOwnProperty(prop))\n        words.push(prop);\n    }\n    add(mode.keywords);\n    add(mode.types);\n    add(mode.builtin);\n    add(mode.atoms);\n    if (words.length) {\n      mode.helperType = mimes[0];\n      CodeMirror.registerHelper(\"hintWords\", mimes[0], words);\n    }\n\n    for (var i = 0; i < mimes.length; ++i)\n      CodeMirror.defineMIME(mimes[i], mode);\n  }\n\n  def([\"text/x-csrc\", \"text/x-c\", \"text/x-chdr\"], {\n    name: \"clike\",\n    keywords: words(cKeywords),\n    types: cTypes,\n    blockKeywords: words(cBlockKeywords),\n    defKeywords: words(cDefKeywords),\n    typeFirstDefinitions: true,\n    atoms: words(\"NULL true false\"),\n    isReservedIdentifier: cIsReservedIdentifier,\n    hooks: {\n      \"#\": cppHook,\n      \"*\": pointerHook,\n    },\n    modeProps: {fold: [\"brace\", \"include\"]}\n  });\n\n  def([\"text/x-c++src\", \"text/x-c++hdr\"], {\n    name: \"clike\",\n    // Keywords from https://en.cppreference.com/w/cpp/keyword includes C++20.\n    keywords: words(cKeywords + \"alignas alignof and and_eq audit axiom bitand bitor catch \" +\n                    \"class compl concept constexpr const_cast decltype delete dynamic_cast \" +\n                    \"explicit export final friend import module mutable namespace new noexcept \" +\n                    \"not not_eq operator or or_eq override private protected public \" +\n                    \"reinterpret_cast requires static_assert static_cast template this \" +\n                    \"thread_local throw try typeid typename using virtual xor xor_eq\"),\n    types: cTypes,\n    blockKeywords: words(cBlockKeywords + \" class try catch\"),\n    defKeywords: words(cDefKeywords + \" class namespace\"),\n    typeFirstDefinitions: true,\n    atoms: words(\"true false NULL nullptr\"),\n    dontIndentStatements: /^template$/,\n    isIdentifierChar: /[\\w\\$_~\\xa1-\\uffff]/,\n    isReservedIdentifier: cIsReservedIdentifier,\n    hooks: {\n      \"#\": cppHook,\n      \"*\": pointerHook,\n      \"u\": cpp11StringHook,\n      \"U\": cpp11StringHook,\n      \"L\": cpp11StringHook,\n      \"R\": cpp11StringHook,\n      \"0\": cpp14Literal,\n      \"1\": cpp14Literal,\n      \"2\": cpp14Literal,\n      \"3\": cpp14Literal,\n      \"4\": cpp14Literal,\n      \"5\": cpp14Literal,\n      \"6\": cpp14Literal,\n      \"7\": cpp14Literal,\n      \"8\": cpp14Literal,\n      \"9\": cpp14Literal,\n      token: function(stream, state, style) {\n        if (style == \"variable\" && stream.peek() == \"(\" &&\n            (state.prevToken == \";\" || state.prevToken == null ||\n             state.prevToken == \"}\") &&\n            cppLooksLikeConstructor(stream.current()))\n          return \"def\";\n      }\n    },\n    namespaceSeparator: \"::\",\n    modeProps: {fold: [\"brace\", \"include\"]}\n  });\n\n  def(\"text/x-java\", {\n    name: \"clike\",\n    keywords: words(\"abstract assert break case catch class const continue default \" +\n                    \"do else enum extends final finally float for goto if implements import \" +\n                    \"instanceof interface native new package private protected public \" +\n                    \"return static strictfp super switch synchronized this throw throws transient \" +\n                    \"try volatile while @interface\"),\n    types: words(\"byte short int long float double boolean char void Boolean Byte Character Double Float \" +\n                 \"Integer Long Number Object Short String StringBuffer StringBuilder Void\"),\n    blockKeywords: words(\"catch class do else finally for if switch try while\"),\n    defKeywords: words(\"class interface enum @interface\"),\n    typeFirstDefinitions: true,\n    atoms: words(\"true false null\"),\n    number: /^(?:0x[a-f\\d_]+|0b[01_]+|(?:[\\d_]+\\.?\\d*|\\.\\d+)(?:e[-+]?[\\d_]+)?)(u|ll?|l|f)?/i,\n    hooks: {\n      \"@\": function(stream) {\n        // Don't match the @interface keyword.\n        if (stream.match('interface', false)) return false;\n\n        stream.eatWhile(/[\\w\\$_]/);\n        return \"meta\";\n      }\n    },\n    modeProps: {fold: [\"brace\", \"import\"]}\n  });\n\n  def(\"text/x-csharp\", {\n    name: \"clike\",\n    keywords: words(\"abstract as async await base break case catch checked class const continue\" +\n                    \" default delegate do else enum event explicit extern finally fixed for\" +\n                    \" foreach goto if implicit in interface internal is lock namespace new\" +\n                    \" operator out override params private protected public readonly ref return sealed\" +\n                    \" sizeof stackalloc static struct switch this throw try typeof unchecked\" +\n                    \" unsafe using virtual void volatile while add alias ascending descending dynamic from get\" +\n                    \" global group into join let orderby partial remove select set value var yield\"),\n    types: words(\"Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func\" +\n                 \" Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32\" +\n                 \" UInt64 bool byte char decimal double short int long object\"  +\n                 \" sbyte float string ushort uint ulong\"),\n    blockKeywords: words(\"catch class do else finally for foreach if struct switch try while\"),\n    defKeywords: words(\"class interface namespace struct var\"),\n    typeFirstDefinitions: true,\n    atoms: words(\"true false null\"),\n    hooks: {\n      \"@\": function(stream, state) {\n        if (stream.eat('\"')) {\n          state.tokenize = tokenAtString;\n          return tokenAtString(stream, state);\n        }\n        stream.eatWhile(/[\\w\\$_]/);\n        return \"meta\";\n      }\n    }\n  });\n\n  function tokenTripleString(stream, state) {\n    var escaped = false;\n    while (!stream.eol()) {\n      if (!escaped && stream.match('\"\"\"')) {\n        state.tokenize = null;\n        break;\n      }\n      escaped = stream.next() == \"\\\\\" && !escaped;\n    }\n    return \"string\";\n  }\n\n  function tokenNestedComment(depth) {\n    return function (stream, state) {\n      var ch\n      while (ch = stream.next()) {\n        if (ch == \"*\" && stream.eat(\"/\")) {\n          if (depth == 1) {\n            state.tokenize = null\n            break\n          } else {\n            state.tokenize = tokenNestedComment(depth - 1)\n            return state.tokenize(stream, state)\n          }\n        } else if (ch == \"/\" && stream.eat(\"*\")) {\n          state.tokenize = tokenNestedComment(depth + 1)\n          return state.tokenize(stream, state)\n        }\n      }\n      return \"comment\"\n    }\n  }\n\n  def(\"text/x-scala\", {\n    name: \"clike\",\n    keywords: words(\n      /* scala */\n      \"abstract case catch class def do else extends final finally for forSome if \" +\n      \"implicit import lazy match new null object override package private protected return \" +\n      \"sealed super this throw trait try type val var while with yield _ \" +\n\n      /* package scala */\n      \"assert assume require print println printf readLine readBoolean readByte readShort \" +\n      \"readChar readInt readLong readFloat readDouble\"\n    ),\n    types: words(\n      \"AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either \" +\n      \"Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable \" +\n      \"Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering \" +\n      \"Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder \" +\n      \"StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector \" +\n\n      /* package java.lang */\n      \"Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable \" +\n      \"Compiler Double Exception Float Integer Long Math Number Object Package Pair Process \" +\n      \"Runtime Runnable SecurityManager Short StackTraceElement StrictMath String \" +\n      \"StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void\"\n    ),\n    multiLineStrings: true,\n    blockKeywords: words(\"catch class enum do else finally for forSome if match switch try while\"),\n    defKeywords: words(\"class enum def object package trait type val var\"),\n    atoms: words(\"true false null\"),\n    indentStatements: false,\n    indentSwitch: false,\n    isOperatorChar: /[+\\-*&%=<>!?|\\/#:@]/,\n    hooks: {\n      \"@\": function(stream) {\n        stream.eatWhile(/[\\w\\$_]/);\n        return \"meta\";\n      },\n      '\"': function(stream, state) {\n        if (!stream.match('\"\"')) return false;\n        state.tokenize = tokenTripleString;\n        return state.tokenize(stream, state);\n      },\n      \"'\": function(stream) {\n        stream.eatWhile(/[\\w\\$_\\xa1-\\uffff]/);\n        return \"atom\";\n      },\n      \"=\": function(stream, state) {\n        var cx = state.context\n        if (cx.type == \"}\" && cx.align && stream.eat(\">\")) {\n          state.context = new Context(cx.indented, cx.column, cx.type, cx.info, null, cx.prev)\n          return \"operator\"\n        } else {\n          return false\n        }\n      },\n\n      \"/\": function(stream, state) {\n        if (!stream.eat(\"*\")) return false\n        state.tokenize = tokenNestedComment(1)\n        return state.tokenize(stream, state)\n      }\n    },\n    modeProps: {closeBrackets: {pairs: '()[]{}\"\"', triples: '\"'}}\n  });\n\n  function tokenKotlinString(tripleString){\n    return function (stream, state) {\n      var escaped = false, next, end = false;\n      while (!stream.eol()) {\n        if (!tripleString && !escaped && stream.match('\"') ) {end = true; break;}\n        if (tripleString && stream.match('\"\"\"')) {end = true; break;}\n        next = stream.next();\n        if(!escaped && next == \"$\" && stream.match('{'))\n          stream.skipTo(\"}\");\n        escaped = !escaped && next == \"\\\\\" && !tripleString;\n      }\n      if (end || !tripleString)\n        state.tokenize = null;\n      return \"string\";\n    }\n  }\n\n  def(\"text/x-kotlin\", {\n    name: \"clike\",\n    keywords: words(\n      /*keywords*/\n      \"package as typealias class interface this super val operator \" +\n      \"var fun for is in This throw return annotation \" +\n      \"break continue object if else while do try when !in !is as? \" +\n\n      /*soft keywords*/\n      \"file import where by get set abstract enum open inner override private public internal \" +\n      \"protected catch finally out final vararg reified dynamic companion constructor init \" +\n      \"sealed field property receiver param sparam lateinit data inline noinline tailrec \" +\n      \"external annotation crossinline const operator infix suspend actual expect setparam\"\n    ),\n    types: words(\n      /* package java.lang */\n      \"Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable \" +\n      \"Compiler Double Exception Float Integer Long Math Number Object Package Pair Process \" +\n      \"Runtime Runnable SecurityManager Short StackTraceElement StrictMath String \" +\n      \"StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void Annotation Any BooleanArray \" +\n      \"ByteArray Char CharArray DeprecationLevel DoubleArray Enum FloatArray Function Int IntArray Lazy \" +\n      \"LazyThreadSafetyMode LongArray Nothing ShortArray Unit\"\n    ),\n    intendSwitch: false,\n    indentStatements: false,\n    multiLineStrings: true,\n    number: /^(?:0x[a-f\\d_]+|0b[01_]+|(?:[\\d_]+(\\.\\d+)?|\\.\\d+)(?:e[-+]?[\\d_]+)?)(u|ll?|l|f)?/i,\n    blockKeywords: words(\"catch class do else finally for if where try while enum\"),\n    defKeywords: words(\"class val var object interface fun\"),\n    atoms: words(\"true false null this\"),\n    hooks: {\n      \"@\": function(stream) {\n        stream.eatWhile(/[\\w\\$_]/);\n        return \"meta\";\n      },\n      '*': function(_stream, state) {\n        return state.prevToken == '.' ? 'variable' : 'operator';\n      },\n      '\"': function(stream, state) {\n        state.tokenize = tokenKotlinString(stream.match('\"\"'));\n        return state.tokenize(stream, state);\n      },\n      indent: function(state, ctx, textAfter, indentUnit) {\n        var firstChar = textAfter && textAfter.charAt(0);\n        if ((state.prevToken == \"}\" || state.prevToken == \")\") && textAfter == \"\")\n          return state.indented;\n        if (state.prevToken == \"operator\" && textAfter != \"}\" ||\n          state.prevToken == \"variable\" && firstChar == \".\" ||\n          (state.prevToken == \"}\" || state.prevToken == \")\") && firstChar == \".\")\n          return indentUnit * 2 + ctx.indented;\n        if (ctx.align && ctx.type == \"}\")\n          return ctx.indented + (state.context.type == (textAfter || \"\").charAt(0) ? 0 : indentUnit);\n      }\n    },\n    modeProps: {closeBrackets: {triples: '\"'}}\n  });\n\n  def([\"x-shader/x-vertex\", \"x-shader/x-fragment\"], {\n    name: \"clike\",\n    keywords: words(\"sampler1D sampler2D sampler3D samplerCube \" +\n                    \"sampler1DShadow sampler2DShadow \" +\n                    \"const attribute uniform varying \" +\n                    \"break continue discard return \" +\n                    \"for while do if else struct \" +\n                    \"in out inout\"),\n    types: words(\"float int bool void \" +\n                 \"vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 \" +\n                 \"mat2 mat3 mat4\"),\n    blockKeywords: words(\"for while do if else struct\"),\n    builtin: words(\"radians degrees sin cos tan asin acos atan \" +\n                    \"pow exp log exp2 sqrt inversesqrt \" +\n                    \"abs sign floor ceil fract mod min max clamp mix step smoothstep \" +\n                    \"length distance dot cross normalize ftransform faceforward \" +\n                    \"reflect refract matrixCompMult \" +\n                    \"lessThan lessThanEqual greaterThan greaterThanEqual \" +\n                    \"equal notEqual any all not \" +\n                    \"texture1D texture1DProj texture1DLod texture1DProjLod \" +\n                    \"texture2D texture2DProj texture2DLod texture2DProjLod \" +\n                    \"texture3D texture3DProj texture3DLod texture3DProjLod \" +\n                    \"textureCube textureCubeLod \" +\n                    \"shadow1D shadow2D shadow1DProj shadow2DProj \" +\n                    \"shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod \" +\n                    \"dFdx dFdy fwidth \" +\n                    \"noise1 noise2 noise3 noise4\"),\n    atoms: words(\"true false \" +\n                \"gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex \" +\n                \"gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 \" +\n                \"gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 \" +\n                \"gl_FogCoord gl_PointCoord \" +\n                \"gl_Position gl_PointSize gl_ClipVertex \" +\n                \"gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor \" +\n                \"gl_TexCoord gl_FogFragCoord \" +\n                \"gl_FragCoord gl_FrontFacing \" +\n                \"gl_FragData gl_FragDepth \" +\n                \"gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix \" +\n                \"gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse \" +\n                \"gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse \" +\n                \"gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose \" +\n                \"gl_ProjectionMatrixInverseTranspose \" +\n                \"gl_ModelViewProjectionMatrixInverseTranspose \" +\n                \"gl_TextureMatrixInverseTranspose \" +\n                \"gl_NormalScale gl_DepthRange gl_ClipPlane \" +\n                \"gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel \" +\n                \"gl_FrontLightModelProduct gl_BackLightModelProduct \" +\n                \"gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ \" +\n                \"gl_FogParameters \" +\n                \"gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords \" +\n                \"gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats \" +\n                \"gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits \" +\n                \"gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits \" +\n                \"gl_MaxDrawBuffers\"),\n    indentSwitch: false,\n    hooks: {\"#\": cppHook},\n    modeProps: {fold: [\"brace\", \"include\"]}\n  });\n\n  def(\"text/x-nesc\", {\n    name: \"clike\",\n    keywords: words(cKeywords + \" as atomic async call command component components configuration event generic \" +\n                    \"implementation includes interface module new norace nx_struct nx_union post provides \" +\n                    \"signal task uses abstract extends\"),\n    types: cTypes,\n    blockKeywords: words(cBlockKeywords),\n    atoms: words(\"null true false\"),\n    hooks: {\"#\": cppHook},\n    modeProps: {fold: [\"brace\", \"include\"]}\n  });\n\n  def(\"text/x-objectivec\", {\n    name: \"clike\",\n    keywords: words(cKeywords + \" bycopy byref in inout oneway out self super atomic nonatomic retain copy \" +\n                    \"readwrite readonly strong weak assign typeof nullable nonnull null_resettable _cmd \" +\n                    \"@interface @implementation @end @protocol @encode @property @synthesize @dynamic @class \" +\n                    \"@public @package @private @protected @required @optional @try @catch @finally @import \" +\n                    \"@selector @encode @defs @synchronized @autoreleasepool @compatibility_alias @available\"),\n    types: objCTypes,\n    builtin: words(\"FOUNDATION_EXPORT FOUNDATION_EXTERN NS_INLINE NS_FORMAT_FUNCTION NS_RETURNS_RETAINED \" +\n                   \"NS_ERROR_ENUM NS_RETURNS_NOT_RETAINED NS_RETURNS_INNER_POINTER NS_DESIGNATED_INITIALIZER \" +\n                   \"NS_ENUM NS_OPTIONS NS_REQUIRES_NIL_TERMINATION NS_ASSUME_NONNULL_BEGIN \" +\n                   \"NS_ASSUME_NONNULL_END NS_SWIFT_NAME NS_REFINED_FOR_SWIFT\"),\n    blockKeywords: words(cBlockKeywords + \" @synthesize @try @catch @finally @autoreleasepool @synchronized\"),\n    defKeywords: words(cDefKeywords + \" @interface @implementation @protocol @class\"),\n    dontIndentStatements: /^@.*$/,\n    typeFirstDefinitions: true,\n    atoms: words(\"YES NO NULL Nil nil true false nullptr\"),\n    isReservedIdentifier: cIsReservedIdentifier,\n    hooks: {\n      \"#\": cppHook,\n      \"*\": pointerHook,\n    },\n    modeProps: {fold: [\"brace\", \"include\"]}\n  });\n\n  def(\"text/x-squirrel\", {\n    name: \"clike\",\n    keywords: words(\"base break clone continue const default delete enum extends function in class\" +\n                    \" foreach local resume return this throw typeof yield constructor instanceof static\"),\n    types: cTypes,\n    blockKeywords: words(\"case catch class else for foreach if switch try while\"),\n    defKeywords: words(\"function local class\"),\n    typeFirstDefinitions: true,\n    atoms: words(\"true false null\"),\n    hooks: {\"#\": cppHook},\n    modeProps: {fold: [\"brace\", \"include\"]}\n  });\n\n  // Ceylon Strings need to deal with interpolation\n  var stringTokenizer = null;\n  function tokenCeylonString(type) {\n    return function(stream, state) {\n      var escaped = false, next, end = false;\n      while (!stream.eol()) {\n        if (!escaped && stream.match('\"') &&\n              (type == \"single\" || stream.match('\"\"'))) {\n          end = true;\n          break;\n        }\n        if (!escaped && stream.match('``')) {\n          stringTokenizer = tokenCeylonString(type);\n          end = true;\n          break;\n        }\n        next = stream.next();\n        escaped = type == \"single\" && !escaped && next == \"\\\\\";\n      }\n      if (end)\n          state.tokenize = null;\n      return \"string\";\n    }\n  }\n\n  def(\"text/x-ceylon\", {\n    name: \"clike\",\n    keywords: words(\"abstracts alias assembly assert assign break case catch class continue dynamic else\" +\n                    \" exists extends finally for function given if import in interface is let module new\" +\n                    \" nonempty object of out outer package return satisfies super switch then this throw\" +\n                    \" try value void while\"),\n    types: function(word) {\n        // In Ceylon all identifiers that start with an uppercase are types\n        var first = word.charAt(0);\n        return (first === first.toUpperCase() && first !== first.toLowerCase());\n    },\n    blockKeywords: words(\"case catch class dynamic else finally for function if interface module new object switch try while\"),\n    defKeywords: words(\"class dynamic function interface module object package value\"),\n    builtin: words(\"abstract actual aliased annotation by default deprecated doc final formal late license\" +\n                   \" native optional sealed see serializable shared suppressWarnings tagged throws variable\"),\n    isPunctuationChar: /[\\[\\]{}\\(\\),;\\:\\.`]/,\n    isOperatorChar: /[+\\-*&%=<>!?|^~:\\/]/,\n    numberStart: /[\\d#$]/,\n    number: /^(?:#[\\da-fA-F_]+|\\$[01_]+|[\\d_]+[kMGTPmunpf]?|[\\d_]+\\.[\\d_]+(?:[eE][-+]?\\d+|[kMGTPmunpf]|)|)/i,\n    multiLineStrings: true,\n    typeFirstDefinitions: true,\n    atoms: words(\"true false null larger smaller equal empty finished\"),\n    indentSwitch: false,\n    styleDefs: false,\n    hooks: {\n      \"@\": function(stream) {\n        stream.eatWhile(/[\\w\\$_]/);\n        return \"meta\";\n      },\n      '\"': function(stream, state) {\n          state.tokenize = tokenCeylonString(stream.match('\"\"') ? \"triple\" : \"single\");\n          return state.tokenize(stream, state);\n        },\n      '`': function(stream, state) {\n          if (!stringTokenizer || !stream.match('`')) return false;\n          state.tokenize = stringTokenizer;\n          stringTokenizer = null;\n          return state.tokenize(stream, state);\n        },\n      \"'\": function(stream) {\n        stream.eatWhile(/[\\w\\$_\\xa1-\\uffff]/);\n        return \"atom\";\n      },\n      token: function(_stream, state, style) {\n          if ((style == \"variable\" || style == \"type\") &&\n              state.prevToken == \".\") {\n            return \"variable-2\";\n          }\n        }\n    },\n    modeProps: {\n        fold: [\"brace\", \"import\"],\n        closeBrackets: {triples: '\"'}\n    }\n  });\n\n});\n","import mod from \"-!../../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--8-oneOf-1-0!../../../node_modules/css-loader/index.js??ref--8-oneOf-1-1!../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../node_modules/postcss-loader/src/index.js??ref--8-oneOf-1-2!../../../node_modules/sass-loader/lib/loader.js??ref--8-oneOf-1-3!../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./input.vue?vue&type=style&index=0&id=2d72df86&lang=scss&scoped=true&\"; export default mod; export * from \"-!../../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--8-oneOf-1-0!../../../node_modules/css-loader/index.js??ref--8-oneOf-1-1!../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../node_modules/postcss-loader/src/index.js??ref--8-oneOf-1-2!../../../node_modules/sass-loader/lib/loader.js??ref--8-oneOf-1-3!../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./input.vue?vue&type=style&index=0&id=2d72df86&lang=scss&scoped=true&\"","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n// This is CodeMirror (https://codemirror.net), a code editor\n// implemented in JavaScript on top of the browser's DOM.\n//\n// You can find some technical background for some of the code below\n// at http://marijnhaverbeke.nl/blog/#cm-internals .\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global.CodeMirror = factory());\n}(this, (function () { 'use strict';\n\n  // Kludges for bugs and behavior differences that can't be feature\n  // detected are enabled based on userAgent etc sniffing.\n  var userAgent = navigator.userAgent;\n  var platform = navigator.platform;\n\n  var gecko = /gecko\\/\\d/i.test(userAgent);\n  var ie_upto10 = /MSIE \\d/.test(userAgent);\n  var ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(userAgent);\n  var edge = /Edge\\/(\\d+)/.exec(userAgent);\n  var ie = ie_upto10 || ie_11up || edge;\n  var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);\n  var webkit = !edge && /WebKit\\//.test(userAgent);\n  var qtwebkit = webkit && /Qt\\/\\d+\\.\\d+/.test(userAgent);\n  var chrome = !edge && /Chrome\\//.test(userAgent);\n  var presto = /Opera\\//.test(userAgent);\n  var safari = /Apple Computer/.test(navigator.vendor);\n  var mac_geMountainLion = /Mac OS X 1\\d\\D([8-9]|\\d\\d)\\D/.test(userAgent);\n  var phantom = /PhantomJS/.test(userAgent);\n\n  var ios = !edge && /AppleWebKit/.test(userAgent) && /Mobile\\/\\w+/.test(userAgent);\n  var android = /Android/.test(userAgent);\n  // This is woefully incomplete. Suggestions for alternative methods welcome.\n  var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);\n  var mac = ios || /Mac/.test(platform);\n  var chromeOS = /\\bCrOS\\b/.test(userAgent);\n  var windows = /win/i.test(platform);\n\n  var presto_version = presto && userAgent.match(/Version\\/(\\d*\\.\\d*)/);\n  if (presto_version) { presto_version = Number(presto_version[1]); }\n  if (presto_version && presto_version >= 15) { presto = false; webkit = true; }\n  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X\n  var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));\n  var captureRightClick = gecko || (ie && ie_version >= 9);\n\n  function classTest(cls) { return new RegExp(\"(^|\\\\s)\" + cls + \"(?:$|\\\\s)\\\\s*\") }\n\n  var rmClass = function(node, cls) {\n    var current = node.className;\n    var match = classTest(cls).exec(current);\n    if (match) {\n      var after = current.slice(match.index + match[0].length);\n      node.className = current.slice(0, match.index) + (after ? match[1] + after : \"\");\n    }\n  };\n\n  function removeChildren(e) {\n    for (var count = e.childNodes.length; count > 0; --count)\n      { e.removeChild(e.firstChild); }\n    return e\n  }\n\n  function removeChildrenAndAdd(parent, e) {\n    return removeChildren(parent).appendChild(e)\n  }\n\n  function elt(tag, content, className, style) {\n    var e = document.createElement(tag);\n    if (className) { e.className = className; }\n    if (style) { e.style.cssText = style; }\n    if (typeof content == \"string\") { e.appendChild(document.createTextNode(content)); }\n    else if (content) { for (var i = 0; i < content.length; ++i) { e.appendChild(content[i]); } }\n    return e\n  }\n  // wrapper for elt, which removes the elt from the accessibility tree\n  function eltP(tag, content, className, style) {\n    var e = elt(tag, content, className, style);\n    e.setAttribute(\"role\", \"presentation\");\n    return e\n  }\n\n  var range;\n  if (document.createRange) { range = function(node, start, end, endNode) {\n    var r = document.createRange();\n    r.setEnd(endNode || node, end);\n    r.setStart(node, start);\n    return r\n  }; }\n  else { range = function(node, start, end) {\n    var r = document.body.createTextRange();\n    try { r.moveToElementText(node.parentNode); }\n    catch(e) { return r }\n    r.collapse(true);\n    r.moveEnd(\"character\", end);\n    r.moveStart(\"character\", start);\n    return r\n  }; }\n\n  function contains(parent, child) {\n    if (child.nodeType == 3) // Android browser always returns false when child is a textnode\n      { child = child.parentNode; }\n    if (parent.contains)\n      { return parent.contains(child) }\n    do {\n      if (child.nodeType == 11) { child = child.host; }\n      if (child == parent) { return true }\n    } while (child = child.parentNode)\n  }\n\n  function activeElt() {\n    // IE and Edge may throw an \"Unspecified Error\" when accessing document.activeElement.\n    // IE < 10 will throw when accessed while the page is loading or in an iframe.\n    // IE > 9 and Edge will throw when accessed in an iframe if document.body is unavailable.\n    var activeElement;\n    try {\n      activeElement = document.activeElement;\n    } catch(e) {\n      activeElement = document.body || null;\n    }\n    while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement)\n      { activeElement = activeElement.shadowRoot.activeElement; }\n    return activeElement\n  }\n\n  function addClass(node, cls) {\n    var current = node.className;\n    if (!classTest(cls).test(current)) { node.className += (current ? \" \" : \"\") + cls; }\n  }\n  function joinClasses(a, b) {\n    var as = a.split(\" \");\n    for (var i = 0; i < as.length; i++)\n      { if (as[i] && !classTest(as[i]).test(b)) { b += \" \" + as[i]; } }\n    return b\n  }\n\n  var selectInput = function(node) { node.select(); };\n  if (ios) // Mobile Safari apparently has a bug where select() is broken.\n    { selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; }; }\n  else if (ie) // Suppress mysterious IE10 errors\n    { selectInput = function(node) { try { node.select(); } catch(_e) {} }; }\n\n  function bind(f) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    return function(){return f.apply(null, args)}\n  }\n\n  function copyObj(obj, target, overwrite) {\n    if (!target) { target = {}; }\n    for (var prop in obj)\n      { if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))\n        { target[prop] = obj[prop]; } }\n    return target\n  }\n\n  // Counts the column offset in a string, taking tabs into account.\n  // Used mostly to find indentation.\n  function countColumn(string, end, tabSize, startIndex, startValue) {\n    if (end == null) {\n      end = string.search(/[^\\s\\u00a0]/);\n      if (end == -1) { end = string.length; }\n    }\n    for (var i = startIndex || 0, n = startValue || 0;;) {\n      var nextTab = string.indexOf(\"\\t\", i);\n      if (nextTab < 0 || nextTab >= end)\n        { return n + (end - i) }\n      n += nextTab - i;\n      n += tabSize - (n % tabSize);\n      i = nextTab + 1;\n    }\n  }\n\n  var Delayed = function() {this.id = null;};\n  Delayed.prototype.set = function (ms, f) {\n    clearTimeout(this.id);\n    this.id = setTimeout(f, ms);\n  };\n\n  function indexOf(array, elt) {\n    for (var i = 0; i < array.length; ++i)\n      { if (array[i] == elt) { return i } }\n    return -1\n  }\n\n  // Number of pixels added to scroller and sizer to hide scrollbar\n  var scrollerGap = 30;\n\n  // Returned or thrown by various protocols to signal 'I'm not\n  // handling this'.\n  var Pass = {toString: function(){return \"CodeMirror.Pass\"}};\n\n  // Reused option objects for setSelection & friends\n  var sel_dontScroll = {scroll: false}, sel_mouse = {origin: \"*mouse\"}, sel_move = {origin: \"+move\"};\n\n  // The inverse of countColumn -- find the offset that corresponds to\n  // a particular column.\n  function findColumn(string, goal, tabSize) {\n    for (var pos = 0, col = 0;;) {\n      var nextTab = string.indexOf(\"\\t\", pos);\n      if (nextTab == -1) { nextTab = string.length; }\n      var skipped = nextTab - pos;\n      if (nextTab == string.length || col + skipped >= goal)\n        { return pos + Math.min(skipped, goal - col) }\n      col += nextTab - pos;\n      col += tabSize - (col % tabSize);\n      pos = nextTab + 1;\n      if (col >= goal) { return pos }\n    }\n  }\n\n  var spaceStrs = [\"\"];\n  function spaceStr(n) {\n    while (spaceStrs.length <= n)\n      { spaceStrs.push(lst(spaceStrs) + \" \"); }\n    return spaceStrs[n]\n  }\n\n  function lst(arr) { return arr[arr.length-1] }\n\n  function map(array, f) {\n    var out = [];\n    for (var i = 0; i < array.length; i++) { out[i] = f(array[i], i); }\n    return out\n  }\n\n  function insertSorted(array, value, score) {\n    var pos = 0, priority = score(value);\n    while (pos < array.length && score(array[pos]) <= priority) { pos++; }\n    array.splice(pos, 0, value);\n  }\n\n  function nothing() {}\n\n  function createObj(base, props) {\n    var inst;\n    if (Object.create) {\n      inst = Object.create(base);\n    } else {\n      nothing.prototype = base;\n      inst = new nothing();\n    }\n    if (props) { copyObj(props, inst); }\n    return inst\n  }\n\n  var nonASCIISingleCaseWordChar = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\n  function isWordCharBasic(ch) {\n    return /\\w/.test(ch) || ch > \"\\x80\" &&\n      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))\n  }\n  function isWordChar(ch, helper) {\n    if (!helper) { return isWordCharBasic(ch) }\n    if (helper.source.indexOf(\"\\\\w\") > -1 && isWordCharBasic(ch)) { return true }\n    return helper.test(ch)\n  }\n\n  function isEmpty(obj) {\n    for (var n in obj) { if (obj.hasOwnProperty(n) && obj[n]) { return false } }\n    return true\n  }\n\n  // Extending unicode characters. A series of a non-extending char +\n  // any number of extending chars is treated as a single unit as far\n  // as editing and measuring is concerned. This is not fully correct,\n  // since some scripts/fonts/browsers also treat other configurations\n  // of code points as a group.\n  var extendingChars = /[\\u0300-\\u036f\\u0483-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u065e\\u0670\\u06d6-\\u06dc\\u06de-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0900-\\u0902\\u093c\\u0941-\\u0948\\u094d\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2\\u09e3\\u0a01\\u0a02\\u0a3c\\u0a41\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70\\u0a71\\u0a75\\u0a81\\u0a82\\u0abc\\u0ac1-\\u0ac5\\u0ac7\\u0ac8\\u0acd\\u0ae2\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0d3e\\u0d41-\\u0d44\\u0d4d\\u0d57\\u0d62\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0f18\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86\\u0f87\\u0f90-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039\\u103a\\u103d\\u103e\\u1058\\u1059\\u105e-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108d\\u109d\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193b\\u1a17\\u1a18\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1b00-\\u1b03\\u1b34\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80\\u1b81\\u1ba2-\\u1ba5\\u1ba8\\u1ba9\\u1c2c-\\u1c33\\u1c36\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1dc0-\\u1de6\\u1dfd-\\u1dff\\u200c\\u200d\\u20d0-\\u20f0\\u2cef-\\u2cf1\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua66f-\\ua672\\ua67c\\ua67d\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua825\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc\\uaa29-\\uaa2e\\uaa31\\uaa32\\uaa35\\uaa36\\uaa43\\uaa4c\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uabe5\\uabe8\\uabed\\udc00-\\udfff\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe26\\uff9e\\uff9f]/;\n  function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch) }\n\n  // Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range.\n  function skipExtendingChars(str, pos, dir) {\n    while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) { pos += dir; }\n    return pos\n  }\n\n  // Returns the value from the range [`from`; `to`] that satisfies\n  // `pred` and is closest to `from`. Assumes that at least `to`\n  // satisfies `pred`. Supports `from` being greater than `to`.\n  function findFirst(pred, from, to) {\n    // At any point we are certain `to` satisfies `pred`, don't know\n    // whether `from` does.\n    var dir = from > to ? -1 : 1;\n    for (;;) {\n      if (from == to) { return from }\n      var midF = (from + to) / 2, mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);\n      if (mid == from) { return pred(mid) ? from : to }\n      if (pred(mid)) { to = mid; }\n      else { from = mid + dir; }\n    }\n  }\n\n  // The display handles the DOM integration, both for input reading\n  // and content drawing. It holds references to DOM nodes and\n  // display-related state.\n\n  function Display(place, doc, input) {\n    var d = this;\n    this.input = input;\n\n    // Covers bottom-right square when both scrollbars are present.\n    d.scrollbarFiller = elt(\"div\", null, \"CodeMirror-scrollbar-filler\");\n    d.scrollbarFiller.setAttribute(\"cm-not-content\", \"true\");\n    // Covers bottom of gutter when coverGutterNextToScrollbar is on\n    // and h scrollbar is present.\n    d.gutterFiller = elt(\"div\", null, \"CodeMirror-gutter-filler\");\n    d.gutterFiller.setAttribute(\"cm-not-content\", \"true\");\n    // Will contain the actual code, positioned to cover the viewport.\n    d.lineDiv = eltP(\"div\", null, \"CodeMirror-code\");\n    // Elements are added to these to represent selection and cursors.\n    d.selectionDiv = elt(\"div\", null, null, \"position: relative; z-index: 1\");\n    d.cursorDiv = elt(\"div\", null, \"CodeMirror-cursors\");\n    // A visibility: hidden element used to find the size of things.\n    d.measure = elt(\"div\", null, \"CodeMirror-measure\");\n    // When lines outside of the viewport are measured, they are drawn in this.\n    d.lineMeasure = elt(\"div\", null, \"CodeMirror-measure\");\n    // Wraps everything that needs to exist inside the vertically-padded coordinate system\n    d.lineSpace = eltP(\"div\", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],\n                      null, \"position: relative; outline: none\");\n    var lines = eltP(\"div\", [d.lineSpace], \"CodeMirror-lines\");\n    // Moved around its parent to cover visible view.\n    d.mover = elt(\"div\", [lines], null, \"position: relative\");\n    // Set to the height of the document, allowing scrolling.\n    d.sizer = elt(\"div\", [d.mover], \"CodeMirror-sizer\");\n    d.sizerWidth = null;\n    // Behavior of elts with overflow: auto and padding is\n    // inconsistent across browsers. This is used to ensure the\n    // scrollable area is big enough.\n    d.heightForcer = elt(\"div\", null, null, \"position: absolute; height: \" + scrollerGap + \"px; width: 1px;\");\n    // Will contain the gutters, if any.\n    d.gutters = elt(\"div\", null, \"CodeMirror-gutters\");\n    d.lineGutter = null;\n    // Actual scrollable element.\n    d.scroller = elt(\"div\", [d.sizer, d.heightForcer, d.gutters], \"CodeMirror-scroll\");\n    d.scroller.setAttribute(\"tabIndex\", \"-1\");\n    // The element in which the editor lives.\n    d.wrapper = elt(\"div\", [d.scrollbarFiller, d.gutterFiller, d.scroller], \"CodeMirror\");\n\n    // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)\n    if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }\n    if (!webkit && !(gecko && mobile)) { d.scroller.draggable = true; }\n\n    if (place) {\n      if (place.appendChild) { place.appendChild(d.wrapper); }\n      else { place(d.wrapper); }\n    }\n\n    // Current rendered range (may be bigger than the view window).\n    d.viewFrom = d.viewTo = doc.first;\n    d.reportedViewFrom = d.reportedViewTo = doc.first;\n    // Information about the rendered lines.\n    d.view = [];\n    d.renderedView = null;\n    // Holds info about a single rendered line when it was rendered\n    // for measurement, while not in view.\n    d.externalMeasured = null;\n    // Empty space (in pixels) above the view\n    d.viewOffset = 0;\n    d.lastWrapHeight = d.lastWrapWidth = 0;\n    d.updateLineNumbers = null;\n\n    d.nativeBarWidth = d.barHeight = d.barWidth = 0;\n    d.scrollbarsClipped = false;\n\n    // Used to only resize the line number gutter when necessary (when\n    // the amount of lines crosses a boundary that makes its width change)\n    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;\n    // Set to true when a non-horizontal-scrolling line widget is\n    // added. As an optimization, line widget aligning is skipped when\n    // this is false.\n    d.alignWidgets = false;\n\n    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n\n    // Tracks the maximum line length so that the horizontal scrollbar\n    // can be kept static when scrolling.\n    d.maxLine = null;\n    d.maxLineLength = 0;\n    d.maxLineChanged = false;\n\n    // Used for measuring wheel scrolling granularity\n    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;\n\n    // True when shift is held down.\n    d.shift = false;\n\n    // Used to track whether anything happened since the context menu\n    // was opened.\n    d.selForContextMenu = null;\n\n    d.activeTouch = null;\n\n    input.init(d);\n  }\n\n  // Find the line object corresponding to the given line number.\n  function getLine(doc, n) {\n    n -= doc.first;\n    if (n < 0 || n >= doc.size) { throw new Error(\"There is no line \" + (n + doc.first) + \" in the document.\") }\n    var chunk = doc;\n    while (!chunk.lines) {\n      for (var i = 0;; ++i) {\n        var child = chunk.children[i], sz = child.chunkSize();\n        if (n < sz) { chunk = child; break }\n        n -= sz;\n      }\n    }\n    return chunk.lines[n]\n  }\n\n  // Get the part of a document between two positions, as an array of\n  // strings.\n  function getBetween(doc, start, end) {\n    var out = [], n = start.line;\n    doc.iter(start.line, end.line + 1, function (line) {\n      var text = line.text;\n      if (n == end.line) { text = text.slice(0, end.ch); }\n      if (n == start.line) { text = text.slice(start.ch); }\n      out.push(text);\n      ++n;\n    });\n    return out\n  }\n  // Get the lines between from and to, as array of strings.\n  function getLines(doc, from, to) {\n    var out = [];\n    doc.iter(from, to, function (line) { out.push(line.text); }); // iter aborts when callback returns truthy value\n    return out\n  }\n\n  // Update the height of a line, propagating the height change\n  // upwards to parent nodes.\n  function updateLineHeight(line, height) {\n    var diff = height - line.height;\n    if (diff) { for (var n = line; n; n = n.parent) { n.height += diff; } }\n  }\n\n  // Given a line object, find its line number by walking up through\n  // its parent links.\n  function lineNo(line) {\n    if (line.parent == null) { return null }\n    var cur = line.parent, no = indexOf(cur.lines, line);\n    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {\n      for (var i = 0;; ++i) {\n        if (chunk.children[i] == cur) { break }\n        no += chunk.children[i].chunkSize();\n      }\n    }\n    return no + cur.first\n  }\n\n  // Find the line at the given vertical position, using the height\n  // information in the document tree.\n  function lineAtHeight(chunk, h) {\n    var n = chunk.first;\n    outer: do {\n      for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {\n        var child = chunk.children[i$1], ch = child.height;\n        if (h < ch) { chunk = child; continue outer }\n        h -= ch;\n        n += child.chunkSize();\n      }\n      return n\n    } while (!chunk.lines)\n    var i = 0;\n    for (; i < chunk.lines.length; ++i) {\n      var line = chunk.lines[i], lh = line.height;\n      if (h < lh) { break }\n      h -= lh;\n    }\n    return n + i\n  }\n\n  function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size}\n\n  function lineNumberFor(options, i) {\n    return String(options.lineNumberFormatter(i + options.firstLineNumber))\n  }\n\n  // A Pos instance represents a position within the text.\n  function Pos(line, ch, sticky) {\n    if ( sticky === void 0 ) sticky = null;\n\n    if (!(this instanceof Pos)) { return new Pos(line, ch, sticky) }\n    this.line = line;\n    this.ch = ch;\n    this.sticky = sticky;\n  }\n\n  // Compare two positions, return 0 if they are the same, a negative\n  // number when a is less, and a positive number otherwise.\n  function cmp(a, b) { return a.line - b.line || a.ch - b.ch }\n\n  function equalCursorPos(a, b) { return a.sticky == b.sticky && cmp(a, b) == 0 }\n\n  function copyPos(x) {return Pos(x.line, x.ch)}\n  function maxPos(a, b) { return cmp(a, b) < 0 ? b : a }\n  function minPos(a, b) { return cmp(a, b) < 0 ? a : b }\n\n  // Most of the external API clips given positions to make sure they\n  // actually exist within the document.\n  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1))}\n  function clipPos(doc, pos) {\n    if (pos.line < doc.first) { return Pos(doc.first, 0) }\n    var last = doc.first + doc.size - 1;\n    if (pos.line > last) { return Pos(last, getLine(doc, last).text.length) }\n    return clipToLen(pos, getLine(doc, pos.line).text.length)\n  }\n  function clipToLen(pos, linelen) {\n    var ch = pos.ch;\n    if (ch == null || ch > linelen) { return Pos(pos.line, linelen) }\n    else if (ch < 0) { return Pos(pos.line, 0) }\n    else { return pos }\n  }\n  function clipPosArray(doc, array) {\n    var out = [];\n    for (var i = 0; i < array.length; i++) { out[i] = clipPos(doc, array[i]); }\n    return out\n  }\n\n  // Optimize some code when these features are not used.\n  var sawReadOnlySpans = false, sawCollapsedSpans = false;\n\n  function seeReadOnlySpans() {\n    sawReadOnlySpans = true;\n  }\n\n  function seeCollapsedSpans() {\n    sawCollapsedSpans = true;\n  }\n\n  // TEXTMARKER SPANS\n\n  function MarkedSpan(marker, from, to) {\n    this.marker = marker;\n    this.from = from; this.to = to;\n  }\n\n  // Search an array of spans for a span matching the given marker.\n  function getMarkedSpanFor(spans, marker) {\n    if (spans) { for (var i = 0; i < spans.length; ++i) {\n      var span = spans[i];\n      if (span.marker == marker) { return span }\n    } }\n  }\n  // Remove a span from an array, returning undefined if no spans are\n  // left (we don't store arrays for lines without spans).\n  function removeMarkedSpan(spans, span) {\n    var r;\n    for (var i = 0; i < spans.length; ++i)\n      { if (spans[i] != span) { (r || (r = [])).push(spans[i]); } }\n    return r\n  }\n  // Add a span to a line.\n  function addMarkedSpan(line, span) {\n    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];\n    span.marker.attachLine(line);\n  }\n\n  // Used for the algorithm that adjusts markers for a change in the\n  // document. These functions cut an array of spans at a given\n  // character position, returning an array of remaining chunks (or\n  // undefined if nothing remains).\n  function markedSpansBefore(old, startCh, isInsert) {\n    var nw;\n    if (old) { for (var i = 0; i < old.length; ++i) {\n      var span = old[i], marker = span.marker;\n      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);\n      if (startsBefore || span.from == startCh && marker.type == \"bookmark\" && (!isInsert || !span.marker.insertLeft)) {\n        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh)\n        ;(nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));\n      }\n    } }\n    return nw\n  }\n  function markedSpansAfter(old, endCh, isInsert) {\n    var nw;\n    if (old) { for (var i = 0; i < old.length; ++i) {\n      var span = old[i], marker = span.marker;\n      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);\n      if (endsAfter || span.from == endCh && marker.type == \"bookmark\" && (!isInsert || span.marker.insertLeft)) {\n        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh)\n        ;(nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,\n                                              span.to == null ? null : span.to - endCh));\n      }\n    } }\n    return nw\n  }\n\n  // Given a change object, compute the new set of marker spans that\n  // cover the line in which the change took place. Removes spans\n  // entirely within the change, reconnects spans belonging to the\n  // same marker that appear on both sides of the change, and cuts off\n  // spans partially within the change. Returns an array of span\n  // arrays with one element for each line in (after) the change.\n  function stretchSpansOverChange(doc, change) {\n    if (change.full) { return null }\n    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;\n    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;\n    if (!oldFirst && !oldLast) { return null }\n\n    var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;\n    // Get the spans that 'stick out' on both sides\n    var first = markedSpansBefore(oldFirst, startCh, isInsert);\n    var last = markedSpansAfter(oldLast, endCh, isInsert);\n\n    // Next, merge those two ends\n    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);\n    if (first) {\n      // Fix up .to properties of first\n      for (var i = 0; i < first.length; ++i) {\n        var span = first[i];\n        if (span.to == null) {\n          var found = getMarkedSpanFor(last, span.marker);\n          if (!found) { span.to = startCh; }\n          else if (sameLine) { span.to = found.to == null ? null : found.to + offset; }\n        }\n      }\n    }\n    if (last) {\n      // Fix up .from in last (or move them into first in case of sameLine)\n      for (var i$1 = 0; i$1 < last.length; ++i$1) {\n        var span$1 = last[i$1];\n        if (span$1.to != null) { span$1.to += offset; }\n        if (span$1.from == null) {\n          var found$1 = getMarkedSpanFor(first, span$1.marker);\n          if (!found$1) {\n            span$1.from = offset;\n            if (sameLine) { (first || (first = [])).push(span$1); }\n          }\n        } else {\n          span$1.from += offset;\n          if (sameLine) { (first || (first = [])).push(span$1); }\n        }\n      }\n    }\n    // Make sure we didn't create any zero-length spans\n    if (first) { first = clearEmptySpans(first); }\n    if (last && last != first) { last = clearEmptySpans(last); }\n\n    var newMarkers = [first];\n    if (!sameLine) {\n      // Fill gap with whole-line-spans\n      var gap = change.text.length - 2, gapMarkers;\n      if (gap > 0 && first)\n        { for (var i$2 = 0; i$2 < first.length; ++i$2)\n          { if (first[i$2].to == null)\n            { (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null)); } } }\n      for (var i$3 = 0; i$3 < gap; ++i$3)\n        { newMarkers.push(gapMarkers); }\n      newMarkers.push(last);\n    }\n    return newMarkers\n  }\n\n  // Remove spans that are empty and don't have a clearWhenEmpty\n  // option of false.\n  function clearEmptySpans(spans) {\n    for (var i = 0; i < spans.length; ++i) {\n      var span = spans[i];\n      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)\n        { spans.splice(i--, 1); }\n    }\n    if (!spans.length) { return null }\n    return spans\n  }\n\n  // Used to 'clip' out readOnly ranges when making a change.\n  function removeReadOnlyRanges(doc, from, to) {\n    var markers = null;\n    doc.iter(from.line, to.line + 1, function (line) {\n      if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {\n        var mark = line.markedSpans[i].marker;\n        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))\n          { (markers || (markers = [])).push(mark); }\n      } }\n    });\n    if (!markers) { return null }\n    var parts = [{from: from, to: to}];\n    for (var i = 0; i < markers.length; ++i) {\n      var mk = markers[i], m = mk.find(0);\n      for (var j = 0; j < parts.length; ++j) {\n        var p = parts[j];\n        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) { continue }\n        var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);\n        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)\n          { newParts.push({from: p.from, to: m.from}); }\n        if (dto > 0 || !mk.inclusiveRight && !dto)\n          { newParts.push({from: m.to, to: p.to}); }\n        parts.splice.apply(parts, newParts);\n        j += newParts.length - 3;\n      }\n    }\n    return parts\n  }\n\n  // Connect or disconnect spans from a line.\n  function detachMarkedSpans(line) {\n    var spans = line.markedSpans;\n    if (!spans) { return }\n    for (var i = 0; i < spans.length; ++i)\n      { spans[i].marker.detachLine(line); }\n    line.markedSpans = null;\n  }\n  function attachMarkedSpans(line, spans) {\n    if (!spans) { return }\n    for (var i = 0; i < spans.length; ++i)\n      { spans[i].marker.attachLine(line); }\n    line.markedSpans = spans;\n  }\n\n  // Helpers used when computing which overlapping collapsed span\n  // counts as the larger one.\n  function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0 }\n  function extraRight(marker) { return marker.inclusiveRight ? 1 : 0 }\n\n  // Returns a number indicating which of two overlapping collapsed\n  // spans is larger (and thus includes the other). Falls back to\n  // comparing ids when the spans cover exactly the same range.\n  function compareCollapsedMarkers(a, b) {\n    var lenDiff = a.lines.length - b.lines.length;\n    if (lenDiff != 0) { return lenDiff }\n    var aPos = a.find(), bPos = b.find();\n    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);\n    if (fromCmp) { return -fromCmp }\n    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);\n    if (toCmp) { return toCmp }\n    return b.id - a.id\n  }\n\n  // Find out whether a line ends or starts in a collapsed span. If\n  // so, return the marker for that span.\n  function collapsedSpanAtSide(line, start) {\n    var sps = sawCollapsedSpans && line.markedSpans, found;\n    if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {\n      sp = sps[i];\n      if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&\n          (!found || compareCollapsedMarkers(found, sp.marker) < 0))\n        { found = sp.marker; }\n    } }\n    return found\n  }\n  function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true) }\n  function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false) }\n\n  function collapsedSpanAround(line, ch) {\n    var sps = sawCollapsedSpans && line.markedSpans, found;\n    if (sps) { for (var i = 0; i < sps.length; ++i) {\n      var sp = sps[i];\n      if (sp.marker.collapsed && (sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) &&\n          (!found || compareCollapsedMarkers(found, sp.marker) < 0)) { found = sp.marker; }\n    } }\n    return found\n  }\n\n  // Test whether there exists a collapsed span that partially\n  // overlaps (covers the start or end, but not both) of a new span.\n  // Such overlap is not allowed.\n  function conflictingCollapsedRange(doc, lineNo$$1, from, to, marker) {\n    var line = getLine(doc, lineNo$$1);\n    var sps = sawCollapsedSpans && line.markedSpans;\n    if (sps) { for (var i = 0; i < sps.length; ++i) {\n      var sp = sps[i];\n      if (!sp.marker.collapsed) { continue }\n      var found = sp.marker.find(0);\n      var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);\n      var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);\n      if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) { continue }\n      if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) ||\n          fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))\n        { return true }\n    } }\n  }\n\n  // A visual line is a line as drawn on the screen. Folding, for\n  // example, can cause multiple logical lines to appear on the same\n  // visual line. This finds the start of the visual line that the\n  // given line is part of (usually that is the line itself).\n  function visualLine(line) {\n    var merged;\n    while (merged = collapsedSpanAtStart(line))\n      { line = merged.find(-1, true).line; }\n    return line\n  }\n\n  function visualLineEnd(line) {\n    var merged;\n    while (merged = collapsedSpanAtEnd(line))\n      { line = merged.find(1, true).line; }\n    return line\n  }\n\n  // Returns an array of logical lines that continue the visual line\n  // started by the argument, or undefined if there are no such lines.\n  function visualLineContinued(line) {\n    var merged, lines;\n    while (merged = collapsedSpanAtEnd(line)) {\n      line = merged.find(1, true).line\n      ;(lines || (lines = [])).push(line);\n    }\n    return lines\n  }\n\n  // Get the line number of the start of the visual line that the\n  // given line number is part of.\n  function visualLineNo(doc, lineN) {\n    var line = getLine(doc, lineN), vis = visualLine(line);\n    if (line == vis) { return lineN }\n    return lineNo(vis)\n  }\n\n  // Get the line number of the start of the next visual line after\n  // the given line.\n  function visualLineEndNo(doc, lineN) {\n    if (lineN > doc.lastLine()) { return lineN }\n    var line = getLine(doc, lineN), merged;\n    if (!lineIsHidden(doc, line)) { return lineN }\n    while (merged = collapsedSpanAtEnd(line))\n      { line = merged.find(1, true).line; }\n    return lineNo(line) + 1\n  }\n\n  // Compute whether a line is hidden. Lines count as hidden when they\n  // are part of a visual line that starts with another line, or when\n  // they are entirely covered by collapsed, non-widget span.\n  function lineIsHidden(doc, line) {\n    var sps = sawCollapsedSpans && line.markedSpans;\n    if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {\n      sp = sps[i];\n      if (!sp.marker.collapsed) { continue }\n      if (sp.from == null) { return true }\n      if (sp.marker.widgetNode) { continue }\n      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))\n        { return true }\n    } }\n  }\n  function lineIsHiddenInner(doc, line, span) {\n    if (span.to == null) {\n      var end = span.marker.find(1, true);\n      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker))\n    }\n    if (span.marker.inclusiveRight && span.to == line.text.length)\n      { return true }\n    for (var sp = (void 0), i = 0; i < line.markedSpans.length; ++i) {\n      sp = line.markedSpans[i];\n      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&\n          (sp.to == null || sp.to != span.from) &&\n          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&\n          lineIsHiddenInner(doc, line, sp)) { return true }\n    }\n  }\n\n  // Find the height above the given line.\n  function heightAtLine(lineObj) {\n    lineObj = visualLine(lineObj);\n\n    var h = 0, chunk = lineObj.parent;\n    for (var i = 0; i < chunk.lines.length; ++i) {\n      var line = chunk.lines[i];\n      if (line == lineObj) { break }\n      else { h += line.height; }\n    }\n    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {\n      for (var i$1 = 0; i$1 < p.children.length; ++i$1) {\n        var cur = p.children[i$1];\n        if (cur == chunk) { break }\n        else { h += cur.height; }\n      }\n    }\n    return h\n  }\n\n  // Compute the character length of a line, taking into account\n  // collapsed ranges (see markText) that might hide parts, and join\n  // other lines onto it.\n  function lineLength(line) {\n    if (line.height == 0) { return 0 }\n    var len = line.text.length, merged, cur = line;\n    while (merged = collapsedSpanAtStart(cur)) {\n      var found = merged.find(0, true);\n      cur = found.from.line;\n      len += found.from.ch - found.to.ch;\n    }\n    cur = line;\n    while (merged = collapsedSpanAtEnd(cur)) {\n      var found$1 = merged.find(0, true);\n      len -= cur.text.length - found$1.from.ch;\n      cur = found$1.to.line;\n      len += cur.text.length - found$1.to.ch;\n    }\n    return len\n  }\n\n  // Find the longest line in the document.\n  function findMaxLine(cm) {\n    var d = cm.display, doc = cm.doc;\n    d.maxLine = getLine(doc, doc.first);\n    d.maxLineLength = lineLength(d.maxLine);\n    d.maxLineChanged = true;\n    doc.iter(function (line) {\n      var len = lineLength(line);\n      if (len > d.maxLineLength) {\n        d.maxLineLength = len;\n        d.maxLine = line;\n      }\n    });\n  }\n\n  // BIDI HELPERS\n\n  function iterateBidiSections(order, from, to, f) {\n    if (!order) { return f(from, to, \"ltr\", 0) }\n    var found = false;\n    for (var i = 0; i < order.length; ++i) {\n      var part = order[i];\n      if (part.from < to && part.to > from || from == to && part.to == from) {\n        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? \"rtl\" : \"ltr\", i);\n        found = true;\n      }\n    }\n    if (!found) { f(from, to, \"ltr\"); }\n  }\n\n  var bidiOther = null;\n  function getBidiPartAt(order, ch, sticky) {\n    var found;\n    bidiOther = null;\n    for (var i = 0; i < order.length; ++i) {\n      var cur = order[i];\n      if (cur.from < ch && cur.to > ch) { return i }\n      if (cur.to == ch) {\n        if (cur.from != cur.to && sticky == \"before\") { found = i; }\n        else { bidiOther = i; }\n      }\n      if (cur.from == ch) {\n        if (cur.from != cur.to && sticky != \"before\") { found = i; }\n        else { bidiOther = i; }\n      }\n    }\n    return found != null ? found : bidiOther\n  }\n\n  // Bidirectional ordering algorithm\n  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm\n  // that this (partially) implements.\n\n  // One-char codes used for character types:\n  // L (L):   Left-to-Right\n  // R (R):   Right-to-Left\n  // r (AL):  Right-to-Left Arabic\n  // 1 (EN):  European Number\n  // + (ES):  European Number Separator\n  // % (ET):  European Number Terminator\n  // n (AN):  Arabic Number\n  // , (CS):  Common Number Separator\n  // m (NSM): Non-Spacing Mark\n  // b (BN):  Boundary Neutral\n  // s (B):   Paragraph Separator\n  // t (S):   Segment Separator\n  // w (WS):  Whitespace\n  // N (ON):  Other Neutrals\n\n  // Returns null if characters are ordered as they appear\n  // (left-to-right), or an array of sections ({from, to, level}\n  // objects) in the order in which they occur visually.\n  var bidiOrdering = (function() {\n    // Character types for codepoints 0 to 0xff\n    var lowTypes = \"bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN\";\n    // Character types for codepoints 0x600 to 0x6f9\n    var arabicTypes = \"nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111\";\n    function charType(code) {\n      if (code <= 0xf7) { return lowTypes.charAt(code) }\n      else if (0x590 <= code && code <= 0x5f4) { return \"R\" }\n      else if (0x600 <= code && code <= 0x6f9) { return arabicTypes.charAt(code - 0x600) }\n      else if (0x6ee <= code && code <= 0x8ac) { return \"r\" }\n      else if (0x2000 <= code && code <= 0x200b) { return \"w\" }\n      else if (code == 0x200c) { return \"b\" }\n      else { return \"L\" }\n    }\n\n    var bidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\n    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;\n\n    function BidiSpan(level, from, to) {\n      this.level = level;\n      this.from = from; this.to = to;\n    }\n\n    return function(str, direction) {\n      var outerType = direction == \"ltr\" ? \"L\" : \"R\";\n\n      if (str.length == 0 || direction == \"ltr\" && !bidiRE.test(str)) { return false }\n      var len = str.length, types = [];\n      for (var i = 0; i < len; ++i)\n        { types.push(charType(str.charCodeAt(i))); }\n\n      // W1. Examine each non-spacing mark (NSM) in the level run, and\n      // change the type of the NSM to the type of the previous\n      // character. If the NSM is at the start of the level run, it will\n      // get the type of sor.\n      for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {\n        var type = types[i$1];\n        if (type == \"m\") { types[i$1] = prev; }\n        else { prev = type; }\n      }\n\n      // W2. Search backwards from each instance of a European number\n      // until the first strong type (R, L, AL, or sor) is found. If an\n      // AL is found, change the type of the European number to Arabic\n      // number.\n      // W3. Change all ALs to R.\n      for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {\n        var type$1 = types[i$2];\n        if (type$1 == \"1\" && cur == \"r\") { types[i$2] = \"n\"; }\n        else if (isStrong.test(type$1)) { cur = type$1; if (type$1 == \"r\") { types[i$2] = \"R\"; } }\n      }\n\n      // W4. A single European separator between two European numbers\n      // changes to a European number. A single common separator between\n      // two numbers of the same type changes to that type.\n      for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {\n        var type$2 = types[i$3];\n        if (type$2 == \"+\" && prev$1 == \"1\" && types[i$3+1] == \"1\") { types[i$3] = \"1\"; }\n        else if (type$2 == \",\" && prev$1 == types[i$3+1] &&\n                 (prev$1 == \"1\" || prev$1 == \"n\")) { types[i$3] = prev$1; }\n        prev$1 = type$2;\n      }\n\n      // W5. A sequence of European terminators adjacent to European\n      // numbers changes to all European numbers.\n      // W6. Otherwise, separators and terminators change to Other\n      // Neutral.\n      for (var i$4 = 0; i$4 < len; ++i$4) {\n        var type$3 = types[i$4];\n        if (type$3 == \",\") { types[i$4] = \"N\"; }\n        else if (type$3 == \"%\") {\n          var end = (void 0);\n          for (end = i$4 + 1; end < len && types[end] == \"%\"; ++end) {}\n          var replace = (i$4 && types[i$4-1] == \"!\") || (end < len && types[end] == \"1\") ? \"1\" : \"N\";\n          for (var j = i$4; j < end; ++j) { types[j] = replace; }\n          i$4 = end - 1;\n        }\n      }\n\n      // W7. Search backwards from each instance of a European number\n      // until the first strong type (R, L, or sor) is found. If an L is\n      // found, then change the type of the European number to L.\n      for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {\n        var type$4 = types[i$5];\n        if (cur$1 == \"L\" && type$4 == \"1\") { types[i$5] = \"L\"; }\n        else if (isStrong.test(type$4)) { cur$1 = type$4; }\n      }\n\n      // N1. A sequence of neutrals takes the direction of the\n      // surrounding strong text if the text on both sides has the same\n      // direction. European and Arabic numbers act as if they were R in\n      // terms of their influence on neutrals. Start-of-level-run (sor)\n      // and end-of-level-run (eor) are used at level run boundaries.\n      // N2. Any remaining neutrals take the embedding direction.\n      for (var i$6 = 0; i$6 < len; ++i$6) {\n        if (isNeutral.test(types[i$6])) {\n          var end$1 = (void 0);\n          for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {}\n          var before = (i$6 ? types[i$6-1] : outerType) == \"L\";\n          var after = (end$1 < len ? types[end$1] : outerType) == \"L\";\n          var replace$1 = before == after ? (before ? \"L\" : \"R\") : outerType;\n          for (var j$1 = i$6; j$1 < end$1; ++j$1) { types[j$1] = replace$1; }\n          i$6 = end$1 - 1;\n        }\n      }\n\n      // Here we depart from the documented algorithm, in order to avoid\n      // building up an actual levels array. Since there are only three\n      // levels (0, 1, 2) in an implementation that doesn't take\n      // explicit embedding into account, we can build up the order on\n      // the fly, without following the level-based algorithm.\n      var order = [], m;\n      for (var i$7 = 0; i$7 < len;) {\n        if (countsAsLeft.test(types[i$7])) {\n          var start = i$7;\n          for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {}\n          order.push(new BidiSpan(0, start, i$7));\n        } else {\n          var pos = i$7, at = order.length;\n          for (++i$7; i$7 < len && types[i$7] != \"L\"; ++i$7) {}\n          for (var j$2 = pos; j$2 < i$7;) {\n            if (countsAsNum.test(types[j$2])) {\n              if (pos < j$2) { order.splice(at, 0, new BidiSpan(1, pos, j$2)); }\n              var nstart = j$2;\n              for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {}\n              order.splice(at, 0, new BidiSpan(2, nstart, j$2));\n              pos = j$2;\n            } else { ++j$2; }\n          }\n          if (pos < i$7) { order.splice(at, 0, new BidiSpan(1, pos, i$7)); }\n        }\n      }\n      if (direction == \"ltr\") {\n        if (order[0].level == 1 && (m = str.match(/^\\s+/))) {\n          order[0].from = m[0].length;\n          order.unshift(new BidiSpan(0, 0, m[0].length));\n        }\n        if (lst(order).level == 1 && (m = str.match(/\\s+$/))) {\n          lst(order).to -= m[0].length;\n          order.push(new BidiSpan(0, len - m[0].length, len));\n        }\n      }\n\n      return direction == \"rtl\" ? order.reverse() : order\n    }\n  })();\n\n  // Get the bidi ordering for the given line (and cache it). Returns\n  // false for lines that are fully left-to-right, and an array of\n  // BidiSpan objects otherwise.\n  function getOrder(line, direction) {\n    var order = line.order;\n    if (order == null) { order = line.order = bidiOrdering(line.text, direction); }\n    return order\n  }\n\n  // EVENT HANDLING\n\n  // Lightweight event framework. on/off also work on DOM nodes,\n  // registering native DOM handlers.\n\n  var noHandlers = [];\n\n  var on = function(emitter, type, f) {\n    if (emitter.addEventListener) {\n      emitter.addEventListener(type, f, false);\n    } else if (emitter.attachEvent) {\n      emitter.attachEvent(\"on\" + type, f);\n    } else {\n      var map$$1 = emitter._handlers || (emitter._handlers = {});\n      map$$1[type] = (map$$1[type] || noHandlers).concat(f);\n    }\n  };\n\n  function getHandlers(emitter, type) {\n    return emitter._handlers && emitter._handlers[type] || noHandlers\n  }\n\n  function off(emitter, type, f) {\n    if (emitter.removeEventListener) {\n      emitter.removeEventListener(type, f, false);\n    } else if (emitter.detachEvent) {\n      emitter.detachEvent(\"on\" + type, f);\n    } else {\n      var map$$1 = emitter._handlers, arr = map$$1 && map$$1[type];\n      if (arr) {\n        var index = indexOf(arr, f);\n        if (index > -1)\n          { map$$1[type] = arr.slice(0, index).concat(arr.slice(index + 1)); }\n      }\n    }\n  }\n\n  function signal(emitter, type /*, values...*/) {\n    var handlers = getHandlers(emitter, type);\n    if (!handlers.length) { return }\n    var args = Array.prototype.slice.call(arguments, 2);\n    for (var i = 0; i < handlers.length; ++i) { handlers[i].apply(null, args); }\n  }\n\n  // The DOM events that CodeMirror handles can be overridden by\n  // registering a (non-DOM) handler on the editor for the event name,\n  // and preventDefault-ing the event in that handler.\n  function signalDOMEvent(cm, e, override) {\n    if (typeof e == \"string\")\n      { e = {type: e, preventDefault: function() { this.defaultPrevented = true; }}; }\n    signal(cm, override || e.type, cm, e);\n    return e_defaultPrevented(e) || e.codemirrorIgnore\n  }\n\n  function signalCursorActivity(cm) {\n    var arr = cm._handlers && cm._handlers.cursorActivity;\n    if (!arr) { return }\n    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);\n    for (var i = 0; i < arr.length; ++i) { if (indexOf(set, arr[i]) == -1)\n      { set.push(arr[i]); } }\n  }\n\n  function hasHandler(emitter, type) {\n    return getHandlers(emitter, type).length > 0\n  }\n\n  // Add on and off methods to a constructor's prototype, to make\n  // registering events on such objects more convenient.\n  function eventMixin(ctor) {\n    ctor.prototype.on = function(type, f) {on(this, type, f);};\n    ctor.prototype.off = function(type, f) {off(this, type, f);};\n  }\n\n  // Due to the fact that we still support jurassic IE versions, some\n  // compatibility wrappers are needed.\n\n  function e_preventDefault(e) {\n    if (e.preventDefault) { e.preventDefault(); }\n    else { e.returnValue = false; }\n  }\n  function e_stopPropagation(e) {\n    if (e.stopPropagation) { e.stopPropagation(); }\n    else { e.cancelBubble = true; }\n  }\n  function e_defaultPrevented(e) {\n    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false\n  }\n  function e_stop(e) {e_preventDefault(e); e_stopPropagation(e);}\n\n  function e_target(e) {return e.target || e.srcElement}\n  function e_button(e) {\n    var b = e.which;\n    if (b == null) {\n      if (e.button & 1) { b = 1; }\n      else if (e.button & 2) { b = 3; }\n      else if (e.button & 4) { b = 2; }\n    }\n    if (mac && e.ctrlKey && b == 1) { b = 3; }\n    return b\n  }\n\n  // Detect drag-and-drop\n  var dragAndDrop = function() {\n    // There is *some* kind of drag-and-drop support in IE6-8, but I\n    // couldn't get it to work yet.\n    if (ie && ie_version < 9) { return false }\n    var div = elt('div');\n    return \"draggable\" in div || \"dragDrop\" in div\n  }();\n\n  var zwspSupported;\n  function zeroWidthElement(measure) {\n    if (zwspSupported == null) {\n      var test = elt(\"span\", \"\\u200b\");\n      removeChildrenAndAdd(measure, elt(\"span\", [test, document.createTextNode(\"x\")]));\n      if (measure.firstChild.offsetHeight != 0)\n        { zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8); }\n    }\n    var node = zwspSupported ? elt(\"span\", \"\\u200b\") :\n      elt(\"span\", \"\\u00a0\", null, \"display: inline-block; width: 1px; margin-right: -1px\");\n    node.setAttribute(\"cm-text\", \"\");\n    return node\n  }\n\n  // Feature-detect IE's crummy client rect reporting for bidi text\n  var badBidiRects;\n  function hasBadBidiRects(measure) {\n    if (badBidiRects != null) { return badBidiRects }\n    var txt = removeChildrenAndAdd(measure, document.createTextNode(\"A\\u062eA\"));\n    var r0 = range(txt, 0, 1).getBoundingClientRect();\n    var r1 = range(txt, 1, 2).getBoundingClientRect();\n    removeChildren(measure);\n    if (!r0 || r0.left == r0.right) { return false } // Safari returns null in some cases (#2780)\n    return badBidiRects = (r1.right - r0.right < 3)\n  }\n\n  // See if \"\".split is the broken IE version, if so, provide an\n  // alternative way to split lines.\n  var splitLinesAuto = \"\\n\\nb\".split(/\\n/).length != 3 ? function (string) {\n    var pos = 0, result = [], l = string.length;\n    while (pos <= l) {\n      var nl = string.indexOf(\"\\n\", pos);\n      if (nl == -1) { nl = string.length; }\n      var line = string.slice(pos, string.charAt(nl - 1) == \"\\r\" ? nl - 1 : nl);\n      var rt = line.indexOf(\"\\r\");\n      if (rt != -1) {\n        result.push(line.slice(0, rt));\n        pos += rt + 1;\n      } else {\n        result.push(line);\n        pos = nl + 1;\n      }\n    }\n    return result\n  } : function (string) { return string.split(/\\r\\n?|\\n/); };\n\n  var hasSelection = window.getSelection ? function (te) {\n    try { return te.selectionStart != te.selectionEnd }\n    catch(e) { return false }\n  } : function (te) {\n    var range$$1;\n    try {range$$1 = te.ownerDocument.selection.createRange();}\n    catch(e) {}\n    if (!range$$1 || range$$1.parentElement() != te) { return false }\n    return range$$1.compareEndPoints(\"StartToEnd\", range$$1) != 0\n  };\n\n  var hasCopyEvent = (function () {\n    var e = elt(\"div\");\n    if (\"oncopy\" in e) { return true }\n    e.setAttribute(\"oncopy\", \"return;\");\n    return typeof e.oncopy == \"function\"\n  })();\n\n  var badZoomedRects = null;\n  function hasBadZoomedRects(measure) {\n    if (badZoomedRects != null) { return badZoomedRects }\n    var node = removeChildrenAndAdd(measure, elt(\"span\", \"x\"));\n    var normal = node.getBoundingClientRect();\n    var fromRange = range(node, 0, 1).getBoundingClientRect();\n    return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1\n  }\n\n  // Known modes, by name and by MIME\n  var modes = {}, mimeModes = {};\n\n  // Extra arguments are stored as the mode's dependencies, which is\n  // used by (legacy) mechanisms like loadmode.js to automatically\n  // load a mode. (Preferred mechanism is the require/define calls.)\n  function defineMode(name, mode) {\n    if (arguments.length > 2)\n      { mode.dependencies = Array.prototype.slice.call(arguments, 2); }\n    modes[name] = mode;\n  }\n\n  function defineMIME(mime, spec) {\n    mimeModes[mime] = spec;\n  }\n\n  // Given a MIME type, a {name, ...options} config object, or a name\n  // string, return a mode config object.\n  function resolveMode(spec) {\n    if (typeof spec == \"string\" && mimeModes.hasOwnProperty(spec)) {\n      spec = mimeModes[spec];\n    } else if (spec && typeof spec.name == \"string\" && mimeModes.hasOwnProperty(spec.name)) {\n      var found = mimeModes[spec.name];\n      if (typeof found == \"string\") { found = {name: found}; }\n      spec = createObj(found, spec);\n      spec.name = found.name;\n    } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+xml$/.test(spec)) {\n      return resolveMode(\"application/xml\")\n    } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+json$/.test(spec)) {\n      return resolveMode(\"application/json\")\n    }\n    if (typeof spec == \"string\") { return {name: spec} }\n    else { return spec || {name: \"null\"} }\n  }\n\n  // Given a mode spec (anything that resolveMode accepts), find and\n  // initialize an actual mode object.\n  function getMode(options, spec) {\n    spec = resolveMode(spec);\n    var mfactory = modes[spec.name];\n    if (!mfactory) { return getMode(options, \"text/plain\") }\n    var modeObj = mfactory(options, spec);\n    if (modeExtensions.hasOwnProperty(spec.name)) {\n      var exts = modeExtensions[spec.name];\n      for (var prop in exts) {\n        if (!exts.hasOwnProperty(prop)) { continue }\n        if (modeObj.hasOwnProperty(prop)) { modeObj[\"_\" + prop] = modeObj[prop]; }\n        modeObj[prop] = exts[prop];\n      }\n    }\n    modeObj.name = spec.name;\n    if (spec.helperType) { modeObj.helperType = spec.helperType; }\n    if (spec.modeProps) { for (var prop$1 in spec.modeProps)\n      { modeObj[prop$1] = spec.modeProps[prop$1]; } }\n\n    return modeObj\n  }\n\n  // This can be used to attach properties to mode objects from\n  // outside the actual mode definition.\n  var modeExtensions = {};\n  function extendMode(mode, properties) {\n    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});\n    copyObj(properties, exts);\n  }\n\n  function copyState(mode, state) {\n    if (state === true) { return state }\n    if (mode.copyState) { return mode.copyState(state) }\n    var nstate = {};\n    for (var n in state) {\n      var val = state[n];\n      if (val instanceof Array) { val = val.concat([]); }\n      nstate[n] = val;\n    }\n    return nstate\n  }\n\n  // Given a mode and a state (for that mode), find the inner mode and\n  // state at the position that the state refers to.\n  function innerMode(mode, state) {\n    var info;\n    while (mode.innerMode) {\n      info = mode.innerMode(state);\n      if (!info || info.mode == mode) { break }\n      state = info.state;\n      mode = info.mode;\n    }\n    return info || {mode: mode, state: state}\n  }\n\n  function startState(mode, a1, a2) {\n    return mode.startState ? mode.startState(a1, a2) : true\n  }\n\n  // STRING STREAM\n\n  // Fed to the mode parsers, provides helper functions to make\n  // parsers more succinct.\n\n  var StringStream = function(string, tabSize, lineOracle) {\n    this.pos = this.start = 0;\n    this.string = string;\n    this.tabSize = tabSize || 8;\n    this.lastColumnPos = this.lastColumnValue = 0;\n    this.lineStart = 0;\n    this.lineOracle = lineOracle;\n  };\n\n  StringStream.prototype.eol = function () {return this.pos >= this.string.length};\n  StringStream.prototype.sol = function () {return this.pos == this.lineStart};\n  StringStream.prototype.peek = function () {return this.string.charAt(this.pos) || undefined};\n  StringStream.prototype.next = function () {\n    if (this.pos < this.string.length)\n      { return this.string.charAt(this.pos++) }\n  };\n  StringStream.prototype.eat = function (match) {\n    var ch = this.string.charAt(this.pos);\n    var ok;\n    if (typeof match == \"string\") { ok = ch == match; }\n    else { ok = ch && (match.test ? match.test(ch) : match(ch)); }\n    if (ok) {++this.pos; return ch}\n  };\n  StringStream.prototype.eatWhile = function (match) {\n    var start = this.pos;\n    while (this.eat(match)){}\n    return this.pos > start\n  };\n  StringStream.prototype.eatSpace = function () {\n      var this$1 = this;\n\n    var start = this.pos;\n    while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) { ++this$1.pos; }\n    return this.pos > start\n  };\n  StringStream.prototype.skipToEnd = function () {this.pos = this.string.length;};\n  StringStream.prototype.skipTo = function (ch) {\n    var found = this.string.indexOf(ch, this.pos);\n    if (found > -1) {this.pos = found; return true}\n  };\n  StringStream.prototype.backUp = function (n) {this.pos -= n;};\n  StringStream.prototype.column = function () {\n    if (this.lastColumnPos < this.start) {\n      this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n      this.lastColumnPos = this.start;\n    }\n    return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)\n  };\n  StringStream.prototype.indentation = function () {\n    return countColumn(this.string, null, this.tabSize) -\n      (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)\n  };\n  StringStream.prototype.match = function (pattern, consume, caseInsensitive) {\n    if (typeof pattern == \"string\") {\n      var cased = function (str) { return caseInsensitive ? str.toLowerCase() : str; };\n      var substr = this.string.substr(this.pos, pattern.length);\n      if (cased(substr) == cased(pattern)) {\n        if (consume !== false) { this.pos += pattern.length; }\n        return true\n      }\n    } else {\n      var match = this.string.slice(this.pos).match(pattern);\n      if (match && match.index > 0) { return null }\n      if (match && consume !== false) { this.pos += match[0].length; }\n      return match\n    }\n  };\n  StringStream.prototype.current = function (){return this.string.slice(this.start, this.pos)};\n  StringStream.prototype.hideFirstChars = function (n, inner) {\n    this.lineStart += n;\n    try { return inner() }\n    finally { this.lineStart -= n; }\n  };\n  StringStream.prototype.lookAhead = function (n) {\n    var oracle = this.lineOracle;\n    return oracle && oracle.lookAhead(n)\n  };\n  StringStream.prototype.baseToken = function () {\n    var oracle = this.lineOracle;\n    return oracle && oracle.baseToken(this.pos)\n  };\n\n  var SavedContext = function(state, lookAhead) {\n    this.state = state;\n    this.lookAhead = lookAhead;\n  };\n\n  var Context = function(doc, state, line, lookAhead) {\n    this.state = state;\n    this.doc = doc;\n    this.line = line;\n    this.maxLookAhead = lookAhead || 0;\n    this.baseTokens = null;\n    this.baseTokenPos = 1;\n  };\n\n  Context.prototype.lookAhead = function (n) {\n    var line = this.doc.getLine(this.line + n);\n    if (line != null && n > this.maxLookAhead) { this.maxLookAhead = n; }\n    return line\n  };\n\n  Context.prototype.baseToken = function (n) {\n      var this$1 = this;\n\n    if (!this.baseTokens) { return null }\n    while (this.baseTokens[this.baseTokenPos] <= n)\n      { this$1.baseTokenPos += 2; }\n    var type = this.baseTokens[this.baseTokenPos + 1];\n    return {type: type && type.replace(/( |^)overlay .*/, \"\"),\n            size: this.baseTokens[this.baseTokenPos] - n}\n  };\n\n  Context.prototype.nextLine = function () {\n    this.line++;\n    if (this.maxLookAhead > 0) { this.maxLookAhead--; }\n  };\n\n  Context.fromSaved = function (doc, saved, line) {\n    if (saved instanceof SavedContext)\n      { return new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead) }\n    else\n      { return new Context(doc, copyState(doc.mode, saved), line) }\n  };\n\n  Context.prototype.save = function (copy) {\n    var state = copy !== false ? copyState(this.doc.mode, this.state) : this.state;\n    return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state\n  };\n\n\n  // Compute a style array (an array starting with a mode generation\n  // -- for invalidation -- followed by pairs of end positions and\n  // style strings), which is used to highlight the tokens on the\n  // line.\n  function highlightLine(cm, line, context, forceToEnd) {\n    // A styles array always starts with a number identifying the\n    // mode/overlays that it is based on (for easy invalidation).\n    var st = [cm.state.modeGen], lineClasses = {};\n    // Compute the base array of styles\n    runMode(cm, line.text, cm.doc.mode, context, function (end, style) { return st.push(end, style); },\n            lineClasses, forceToEnd);\n    var state = context.state;\n\n    // Run overlays, adjust style array.\n    var loop = function ( o ) {\n      context.baseTokens = st;\n      var overlay = cm.state.overlays[o], i = 1, at = 0;\n      context.state = true;\n      runMode(cm, line.text, overlay.mode, context, function (end, style) {\n        var start = i;\n        // Ensure there's a token end at the current position, and that i points at it\n        while (at < end) {\n          var i_end = st[i];\n          if (i_end > end)\n            { st.splice(i, 1, end, st[i+1], i_end); }\n          i += 2;\n          at = Math.min(end, i_end);\n        }\n        if (!style) { return }\n        if (overlay.opaque) {\n          st.splice(start, i - start, end, \"overlay \" + style);\n          i = start + 2;\n        } else {\n          for (; start < i; start += 2) {\n            var cur = st[start+1];\n            st[start+1] = (cur ? cur + \" \" : \"\") + \"overlay \" + style;\n          }\n        }\n      }, lineClasses);\n      context.state = state;\n      context.baseTokens = null;\n      context.baseTokenPos = 1;\n    };\n\n    for (var o = 0; o < cm.state.overlays.length; ++o) loop( o );\n\n    return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null}\n  }\n\n  function getLineStyles(cm, line, updateFrontier) {\n    if (!line.styles || line.styles[0] != cm.state.modeGen) {\n      var context = getContextBefore(cm, lineNo(line));\n      var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);\n      var result = highlightLine(cm, line, context);\n      if (resetState) { context.state = resetState; }\n      line.stateAfter = context.save(!resetState);\n      line.styles = result.styles;\n      if (result.classes) { line.styleClasses = result.classes; }\n      else if (line.styleClasses) { line.styleClasses = null; }\n      if (updateFrontier === cm.doc.highlightFrontier)\n        { cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier); }\n    }\n    return line.styles\n  }\n\n  function getContextBefore(cm, n, precise) {\n    var doc = cm.doc, display = cm.display;\n    if (!doc.mode.startState) { return new Context(doc, true, n) }\n    var start = findStartLine(cm, n, precise);\n    var saved = start > doc.first && getLine(doc, start - 1).stateAfter;\n    var context = saved ? Context.fromSaved(doc, saved, start) : new Context(doc, startState(doc.mode), start);\n\n    doc.iter(start, n, function (line) {\n      processLine(cm, line.text, context);\n      var pos = context.line;\n      line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;\n      context.nextLine();\n    });\n    if (precise) { doc.modeFrontier = context.line; }\n    return context\n  }\n\n  // Lightweight form of highlight -- proceed over this line and\n  // update state, but don't save a style array. Used for lines that\n  // aren't currently visible.\n  function processLine(cm, text, context, startAt) {\n    var mode = cm.doc.mode;\n    var stream = new StringStream(text, cm.options.tabSize, context);\n    stream.start = stream.pos = startAt || 0;\n    if (text == \"\") { callBlankLine(mode, context.state); }\n    while (!stream.eol()) {\n      readToken(mode, stream, context.state);\n      stream.start = stream.pos;\n    }\n  }\n\n  function callBlankLine(mode, state) {\n    if (mode.blankLine) { return mode.blankLine(state) }\n    if (!mode.innerMode) { return }\n    var inner = innerMode(mode, state);\n    if (inner.mode.blankLine) { return inner.mode.blankLine(inner.state) }\n  }\n\n  function readToken(mode, stream, state, inner) {\n    for (var i = 0; i < 10; i++) {\n      if (inner) { inner[0] = innerMode(mode, state).mode; }\n      var style = mode.token(stream, state);\n      if (stream.pos > stream.start) { return style }\n    }\n    throw new Error(\"Mode \" + mode.name + \" failed to advance stream.\")\n  }\n\n  var Token = function(stream, type, state) {\n    this.start = stream.start; this.end = stream.pos;\n    this.string = stream.current();\n    this.type = type || null;\n    this.state = state;\n  };\n\n  // Utility for getTokenAt and getLineTokens\n  function takeToken(cm, pos, precise, asArray) {\n    var doc = cm.doc, mode = doc.mode, style;\n    pos = clipPos(doc, pos);\n    var line = getLine(doc, pos.line), context = getContextBefore(cm, pos.line, precise);\n    var stream = new StringStream(line.text, cm.options.tabSize, context), tokens;\n    if (asArray) { tokens = []; }\n    while ((asArray || stream.pos < pos.ch) && !stream.eol()) {\n      stream.start = stream.pos;\n      style = readToken(mode, stream, context.state);\n      if (asArray) { tokens.push(new Token(stream, style, copyState(doc.mode, context.state))); }\n    }\n    return asArray ? tokens : new Token(stream, style, context.state)\n  }\n\n  function extractLineClasses(type, output) {\n    if (type) { for (;;) {\n      var lineClass = type.match(/(?:^|\\s+)line-(background-)?(\\S+)/);\n      if (!lineClass) { break }\n      type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);\n      var prop = lineClass[1] ? \"bgClass\" : \"textClass\";\n      if (output[prop] == null)\n        { output[prop] = lineClass[2]; }\n      else if (!(new RegExp(\"(?:^|\\s)\" + lineClass[2] + \"(?:$|\\s)\")).test(output[prop]))\n        { output[prop] += \" \" + lineClass[2]; }\n    } }\n    return type\n  }\n\n  // Run the given mode's parser over a line, calling f for each token.\n  function runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {\n    var flattenSpans = mode.flattenSpans;\n    if (flattenSpans == null) { flattenSpans = cm.options.flattenSpans; }\n    var curStart = 0, curStyle = null;\n    var stream = new StringStream(text, cm.options.tabSize, context), style;\n    var inner = cm.options.addModeClass && [null];\n    if (text == \"\") { extractLineClasses(callBlankLine(mode, context.state), lineClasses); }\n    while (!stream.eol()) {\n      if (stream.pos > cm.options.maxHighlightLength) {\n        flattenSpans = false;\n        if (forceToEnd) { processLine(cm, text, context, stream.pos); }\n        stream.pos = text.length;\n        style = null;\n      } else {\n        style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);\n      }\n      if (inner) {\n        var mName = inner[0].name;\n        if (mName) { style = \"m-\" + (style ? mName + \" \" + style : mName); }\n      }\n      if (!flattenSpans || curStyle != style) {\n        while (curStart < stream.start) {\n          curStart = Math.min(stream.start, curStart + 5000);\n          f(curStart, curStyle);\n        }\n        curStyle = style;\n      }\n      stream.start = stream.pos;\n    }\n    while (curStart < stream.pos) {\n      // Webkit seems to refuse to render text nodes longer than 57444\n      // characters, and returns inaccurate measurements in nodes\n      // starting around 5000 chars.\n      var pos = Math.min(stream.pos, curStart + 5000);\n      f(pos, curStyle);\n      curStart = pos;\n    }\n  }\n\n  // Finds the line to start with when starting a parse. Tries to\n  // find a line with a stateAfter, so that it can start with a\n  // valid state. If that fails, it returns the line with the\n  // smallest indentation, which tends to need the least context to\n  // parse correctly.\n  function findStartLine(cm, n, precise) {\n    var minindent, minline, doc = cm.doc;\n    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);\n    for (var search = n; search > lim; --search) {\n      if (search <= doc.first) { return doc.first }\n      var line = getLine(doc, search - 1), after = line.stateAfter;\n      if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier))\n        { return search }\n      var indented = countColumn(line.text, null, cm.options.tabSize);\n      if (minline == null || minindent > indented) {\n        minline = search - 1;\n        minindent = indented;\n      }\n    }\n    return minline\n  }\n\n  function retreatFrontier(doc, n) {\n    doc.modeFrontier = Math.min(doc.modeFrontier, n);\n    if (doc.highlightFrontier < n - 10) { return }\n    var start = doc.first;\n    for (var line = n - 1; line > start; line--) {\n      var saved = getLine(doc, line).stateAfter;\n      // change is on 3\n      // state on line 1 looked ahead 2 -- so saw 3\n      // test 1 + 2 < 3 should cover this\n      if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {\n        start = line + 1;\n        break\n      }\n    }\n    doc.highlightFrontier = Math.min(doc.highlightFrontier, start);\n  }\n\n  // LINE DATA STRUCTURE\n\n  // Line objects. These hold state related to a line, including\n  // highlighting info (the styles array).\n  var Line = function(text, markedSpans, estimateHeight) {\n    this.text = text;\n    attachMarkedSpans(this, markedSpans);\n    this.height = estimateHeight ? estimateHeight(this) : 1;\n  };\n\n  Line.prototype.lineNo = function () { return lineNo(this) };\n  eventMixin(Line);\n\n  // Change the content (text, markers) of a line. Automatically\n  // invalidates cached information and tries to re-estimate the\n  // line's height.\n  function updateLine(line, text, markedSpans, estimateHeight) {\n    line.text = text;\n    if (line.stateAfter) { line.stateAfter = null; }\n    if (line.styles) { line.styles = null; }\n    if (line.order != null) { line.order = null; }\n    detachMarkedSpans(line);\n    attachMarkedSpans(line, markedSpans);\n    var estHeight = estimateHeight ? estimateHeight(line) : 1;\n    if (estHeight != line.height) { updateLineHeight(line, estHeight); }\n  }\n\n  // Detach a line from the document tree and its markers.\n  function cleanUpLine(line) {\n    line.parent = null;\n    detachMarkedSpans(line);\n  }\n\n  // Convert a style as returned by a mode (either null, or a string\n  // containing one or more styles) to a CSS style. This is cached,\n  // and also looks for line-wide styles.\n  var styleToClassCache = {}, styleToClassCacheWithMode = {};\n  function interpretTokenStyle(style, options) {\n    if (!style || /^\\s*$/.test(style)) { return null }\n    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;\n    return cache[style] ||\n      (cache[style] = style.replace(/\\S+/g, \"cm-$&\"))\n  }\n\n  // Render the DOM representation of the text of a line. Also builds\n  // up a 'line map', which points at the DOM nodes that represent\n  // specific stretches of text, and is used by the measuring code.\n  // The returned object contains the DOM node, this map, and\n  // information about line-wide styles that were set by the mode.\n  function buildLineContent(cm, lineView) {\n    // The padding-right forces the element to have a 'border', which\n    // is needed on Webkit to be able to get line-level bounding\n    // rectangles for it (in measureChar).\n    var content = eltP(\"span\", null, null, webkit ? \"padding-right: .1px\" : null);\n    var builder = {pre: eltP(\"pre\", [content], \"CodeMirror-line\"), content: content,\n                   col: 0, pos: 0, cm: cm,\n                   trailingSpace: false,\n                   splitSpaces: cm.getOption(\"lineWrapping\")};\n    lineView.measure = {};\n\n    // Iterate over the logical lines that make up this visual line.\n    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {\n      var line = i ? lineView.rest[i - 1] : lineView.line, order = (void 0);\n      builder.pos = 0;\n      builder.addToken = buildToken;\n      // Optionally wire in some hacks into the token-rendering\n      // algorithm, to deal with browser quirks.\n      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction)))\n        { builder.addToken = buildTokenBadBidi(builder.addToken, order); }\n      builder.map = [];\n      var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);\n      insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));\n      if (line.styleClasses) {\n        if (line.styleClasses.bgClass)\n          { builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || \"\"); }\n        if (line.styleClasses.textClass)\n          { builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || \"\"); }\n      }\n\n      // Ensure at least a single node is present, for measuring.\n      if (builder.map.length == 0)\n        { builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure))); }\n\n      // Store the map and a cache object for the current logical line\n      if (i == 0) {\n        lineView.measure.map = builder.map;\n        lineView.measure.cache = {};\n      } else {\n  (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map)\n        ;(lineView.measure.caches || (lineView.measure.caches = [])).push({});\n      }\n    }\n\n    // See issue #2901\n    if (webkit) {\n      var last = builder.content.lastChild;\n      if (/\\bcm-tab\\b/.test(last.className) || (last.querySelector && last.querySelector(\".cm-tab\")))\n        { builder.content.className = \"cm-tab-wrap-hack\"; }\n    }\n\n    signal(cm, \"renderLine\", cm, lineView.line, builder.pre);\n    if (builder.pre.className)\n      { builder.textClass = joinClasses(builder.pre.className, builder.textClass || \"\"); }\n\n    return builder\n  }\n\n  function defaultSpecialCharPlaceholder(ch) {\n    var token = elt(\"span\", \"\\u2022\", \"cm-invalidchar\");\n    token.title = \"\\\\u\" + ch.charCodeAt(0).toString(16);\n    token.setAttribute(\"aria-label\", token.title);\n    return token\n  }\n\n  // Build up the DOM representation for a single token, and add it to\n  // the line map. Takes care to render special characters separately.\n  function buildToken(builder, text, style, startStyle, endStyle, css, attributes) {\n    if (!text) { return }\n    var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;\n    var special = builder.cm.state.specialChars, mustWrap = false;\n    var content;\n    if (!special.test(text)) {\n      builder.col += text.length;\n      content = document.createTextNode(displayText);\n      builder.map.push(builder.pos, builder.pos + text.length, content);\n      if (ie && ie_version < 9) { mustWrap = true; }\n      builder.pos += text.length;\n    } else {\n      content = document.createDocumentFragment();\n      var pos = 0;\n      while (true) {\n        special.lastIndex = pos;\n        var m = special.exec(text);\n        var skipped = m ? m.index - pos : text.length - pos;\n        if (skipped) {\n          var txt = document.createTextNode(displayText.slice(pos, pos + skipped));\n          if (ie && ie_version < 9) { content.appendChild(elt(\"span\", [txt])); }\n          else { content.appendChild(txt); }\n          builder.map.push(builder.pos, builder.pos + skipped, txt);\n          builder.col += skipped;\n          builder.pos += skipped;\n        }\n        if (!m) { break }\n        pos += skipped + 1;\n        var txt$1 = (void 0);\n        if (m[0] == \"\\t\") {\n          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;\n          txt$1 = content.appendChild(elt(\"span\", spaceStr(tabWidth), \"cm-tab\"));\n          txt$1.setAttribute(\"role\", \"presentation\");\n          txt$1.setAttribute(\"cm-text\", \"\\t\");\n          builder.col += tabWidth;\n        } else if (m[0] == \"\\r\" || m[0] == \"\\n\") {\n          txt$1 = content.appendChild(elt(\"span\", m[0] == \"\\r\" ? \"\\u240d\" : \"\\u2424\", \"cm-invalidchar\"));\n          txt$1.setAttribute(\"cm-text\", m[0]);\n          builder.col += 1;\n        } else {\n          txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);\n          txt$1.setAttribute(\"cm-text\", m[0]);\n          if (ie && ie_version < 9) { content.appendChild(elt(\"span\", [txt$1])); }\n          else { content.appendChild(txt$1); }\n          builder.col += 1;\n        }\n        builder.map.push(builder.pos, builder.pos + 1, txt$1);\n        builder.pos++;\n      }\n    }\n    builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;\n    if (style || startStyle || endStyle || mustWrap || css) {\n      var fullStyle = style || \"\";\n      if (startStyle) { fullStyle += startStyle; }\n      if (endStyle) { fullStyle += endStyle; }\n      var token = elt(\"span\", [content], fullStyle, css);\n      if (attributes) {\n        for (var attr in attributes) { if (attributes.hasOwnProperty(attr) && attr != \"style\" && attr != \"class\")\n          { token.setAttribute(attr, attributes[attr]); } }\n      }\n      return builder.content.appendChild(token)\n    }\n    builder.content.appendChild(content);\n  }\n\n  // Change some spaces to NBSP to prevent the browser from collapsing\n  // trailing spaces at the end of a line when rendering text (issue #1362).\n  function splitSpaces(text, trailingBefore) {\n    if (text.length > 1 && !/  /.test(text)) { return text }\n    var spaceBefore = trailingBefore, result = \"\";\n    for (var i = 0; i < text.length; i++) {\n      var ch = text.charAt(i);\n      if (ch == \" \" && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32))\n        { ch = \"\\u00a0\"; }\n      result += ch;\n      spaceBefore = ch == \" \";\n    }\n    return result\n  }\n\n  // Work around nonsense dimensions being reported for stretches of\n  // right-to-left text.\n  function buildTokenBadBidi(inner, order) {\n    return function (builder, text, style, startStyle, endStyle, css, attributes) {\n      style = style ? style + \" cm-force-border\" : \"cm-force-border\";\n      var start = builder.pos, end = start + text.length;\n      for (;;) {\n        // Find the part that overlaps with the start of this text\n        var part = (void 0);\n        for (var i = 0; i < order.length; i++) {\n          part = order[i];\n          if (part.to > start && part.from <= start) { break }\n        }\n        if (part.to >= end) { return inner(builder, text, style, startStyle, endStyle, css, attributes) }\n        inner(builder, text.slice(0, part.to - start), style, startStyle, null, css, attributes);\n        startStyle = null;\n        text = text.slice(part.to - start);\n        start = part.to;\n      }\n    }\n  }\n\n  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {\n    var widget = !ignoreWidget && marker.widgetNode;\n    if (widget) { builder.map.push(builder.pos, builder.pos + size, widget); }\n    if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {\n      if (!widget)\n        { widget = builder.content.appendChild(document.createElement(\"span\")); }\n      widget.setAttribute(\"cm-marker\", marker.id);\n    }\n    if (widget) {\n      builder.cm.display.input.setUneditable(widget);\n      builder.content.appendChild(widget);\n    }\n    builder.pos += size;\n    builder.trailingSpace = false;\n  }\n\n  // Outputs a number of spans to make up a line, taking highlighting\n  // and marked text into account.\n  function insertLineContent(line, builder, styles) {\n    var spans = line.markedSpans, allText = line.text, at = 0;\n    if (!spans) {\n      for (var i$1 = 1; i$1 < styles.length; i$1+=2)\n        { builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1+1], builder.cm.options)); }\n      return\n    }\n\n    var len = allText.length, pos = 0, i = 1, text = \"\", style, css;\n    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, collapsed, attributes;\n    for (;;) {\n      if (nextChange == pos) { // Update current marker set\n        spanStyle = spanEndStyle = spanStartStyle = css = \"\";\n        attributes = null;\n        collapsed = null; nextChange = Infinity;\n        var foundBookmarks = [], endStyles = (void 0);\n        for (var j = 0; j < spans.length; ++j) {\n          var sp = spans[j], m = sp.marker;\n          if (m.type == \"bookmark\" && sp.from == pos && m.widgetNode) {\n            foundBookmarks.push(m);\n          } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {\n            if (sp.to != null && sp.to != pos && nextChange > sp.to) {\n              nextChange = sp.to;\n              spanEndStyle = \"\";\n            }\n            if (m.className) { spanStyle += \" \" + m.className; }\n            if (m.css) { css = (css ? css + \";\" : \"\") + m.css; }\n            if (m.startStyle && sp.from == pos) { spanStartStyle += \" \" + m.startStyle; }\n            if (m.endStyle && sp.to == nextChange) { (endStyles || (endStyles = [])).push(m.endStyle, sp.to); }\n            // support for the old title property\n            // https://github.com/codemirror/CodeMirror/pull/5673\n            if (m.title) { (attributes || (attributes = {})).title = m.title; }\n            if (m.attributes) {\n              for (var attr in m.attributes)\n                { (attributes || (attributes = {}))[attr] = m.attributes[attr]; }\n            }\n            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))\n              { collapsed = sp; }\n          } else if (sp.from > pos && nextChange > sp.from) {\n            nextChange = sp.from;\n          }\n        }\n        if (endStyles) { for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2)\n          { if (endStyles[j$1 + 1] == nextChange) { spanEndStyle += \" \" + endStyles[j$1]; } } }\n\n        if (!collapsed || collapsed.from == pos) { for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2)\n          { buildCollapsedSpan(builder, 0, foundBookmarks[j$2]); } }\n        if (collapsed && (collapsed.from || 0) == pos) {\n          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,\n                             collapsed.marker, collapsed.from == null);\n          if (collapsed.to == null) { return }\n          if (collapsed.to == pos) { collapsed = false; }\n        }\n      }\n      if (pos >= len) { break }\n\n      var upto = Math.min(len, nextChange);\n      while (true) {\n        if (text) {\n          var end = pos + text.length;\n          if (!collapsed) {\n            var tokenText = end > upto ? text.slice(0, upto - pos) : text;\n            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,\n                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : \"\", css, attributes);\n          }\n          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break}\n          pos = end;\n          spanStartStyle = \"\";\n        }\n        text = allText.slice(at, at = styles[i++]);\n        style = interpretTokenStyle(styles[i++], builder.cm.options);\n      }\n    }\n  }\n\n\n  // These objects are used to represent the visible (currently drawn)\n  // part of the document. A LineView may correspond to multiple\n  // logical lines, if those are connected by collapsed ranges.\n  function LineView(doc, line, lineN) {\n    // The starting line\n    this.line = line;\n    // Continuing lines, if any\n    this.rest = visualLineContinued(line);\n    // Number of logical lines in this visual line\n    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;\n    this.node = this.text = null;\n    this.hidden = lineIsHidden(doc, line);\n  }\n\n  // Create a range of LineView objects for the given lines.\n  function buildViewArray(cm, from, to) {\n    var array = [], nextPos;\n    for (var pos = from; pos < to; pos = nextPos) {\n      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);\n      nextPos = pos + view.size;\n      array.push(view);\n    }\n    return array\n  }\n\n  var operationGroup = null;\n\n  function pushOperation(op) {\n    if (operationGroup) {\n      operationGroup.ops.push(op);\n    } else {\n      op.ownsGroup = operationGroup = {\n        ops: [op],\n        delayedCallbacks: []\n      };\n    }\n  }\n\n  function fireCallbacksForOps(group) {\n    // Calls delayed callbacks and cursorActivity handlers until no\n    // new ones appear\n    var callbacks = group.delayedCallbacks, i = 0;\n    do {\n      for (; i < callbacks.length; i++)\n        { callbacks[i].call(null); }\n      for (var j = 0; j < group.ops.length; j++) {\n        var op = group.ops[j];\n        if (op.cursorActivityHandlers)\n          { while (op.cursorActivityCalled < op.cursorActivityHandlers.length)\n            { op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm); } }\n      }\n    } while (i < callbacks.length)\n  }\n\n  function finishOperation(op, endCb) {\n    var group = op.ownsGroup;\n    if (!group) { return }\n\n    try { fireCallbacksForOps(group); }\n    finally {\n      operationGroup = null;\n      endCb(group);\n    }\n  }\n\n  var orphanDelayedCallbacks = null;\n\n  // Often, we want to signal events at a point where we are in the\n  // middle of some work, but don't want the handler to start calling\n  // other methods on the editor, which might be in an inconsistent\n  // state or simply not expect any other events to happen.\n  // signalLater looks whether there are any handlers, and schedules\n  // them to be executed when the last operation ends, or, if no\n  // operation is active, when a timeout fires.\n  function signalLater(emitter, type /*, values...*/) {\n    var arr = getHandlers(emitter, type);\n    if (!arr.length) { return }\n    var args = Array.prototype.slice.call(arguments, 2), list;\n    if (operationGroup) {\n      list = operationGroup.delayedCallbacks;\n    } else if (orphanDelayedCallbacks) {\n      list = orphanDelayedCallbacks;\n    } else {\n      list = orphanDelayedCallbacks = [];\n      setTimeout(fireOrphanDelayed, 0);\n    }\n    var loop = function ( i ) {\n      list.push(function () { return arr[i].apply(null, args); });\n    };\n\n    for (var i = 0; i < arr.length; ++i)\n      loop( i );\n  }\n\n  function fireOrphanDelayed() {\n    var delayed = orphanDelayedCallbacks;\n    orphanDelayedCallbacks = null;\n    for (var i = 0; i < delayed.length; ++i) { delayed[i](); }\n  }\n\n  // When an aspect of a line changes, a string is added to\n  // lineView.changes. This updates the relevant part of the line's\n  // DOM structure.\n  function updateLineForChanges(cm, lineView, lineN, dims) {\n    for (var j = 0; j < lineView.changes.length; j++) {\n      var type = lineView.changes[j];\n      if (type == \"text\") { updateLineText(cm, lineView); }\n      else if (type == \"gutter\") { updateLineGutter(cm, lineView, lineN, dims); }\n      else if (type == \"class\") { updateLineClasses(cm, lineView); }\n      else if (type == \"widget\") { updateLineWidgets(cm, lineView, dims); }\n    }\n    lineView.changes = null;\n  }\n\n  // Lines with gutter elements, widgets or a background class need to\n  // be wrapped, and have the extra elements added to the wrapper div\n  function ensureLineWrapped(lineView) {\n    if (lineView.node == lineView.text) {\n      lineView.node = elt(\"div\", null, null, \"position: relative\");\n      if (lineView.text.parentNode)\n        { lineView.text.parentNode.replaceChild(lineView.node, lineView.text); }\n      lineView.node.appendChild(lineView.text);\n      if (ie && ie_version < 8) { lineView.node.style.zIndex = 2; }\n    }\n    return lineView.node\n  }\n\n  function updateLineBackground(cm, lineView) {\n    var cls = lineView.bgClass ? lineView.bgClass + \" \" + (lineView.line.bgClass || \"\") : lineView.line.bgClass;\n    if (cls) { cls += \" CodeMirror-linebackground\"; }\n    if (lineView.background) {\n      if (cls) { lineView.background.className = cls; }\n      else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }\n    } else if (cls) {\n      var wrap = ensureLineWrapped(lineView);\n      lineView.background = wrap.insertBefore(elt(\"div\", null, cls), wrap.firstChild);\n      cm.display.input.setUneditable(lineView.background);\n    }\n  }\n\n  // Wrapper around buildLineContent which will reuse the structure\n  // in display.externalMeasured when possible.\n  function getLineContent(cm, lineView) {\n    var ext = cm.display.externalMeasured;\n    if (ext && ext.line == lineView.line) {\n      cm.display.externalMeasured = null;\n      lineView.measure = ext.measure;\n      return ext.built\n    }\n    return buildLineContent(cm, lineView)\n  }\n\n  // Redraw the line's text. Interacts with the background and text\n  // classes because the mode may output tokens that influence these\n  // classes.\n  function updateLineText(cm, lineView) {\n    var cls = lineView.text.className;\n    var built = getLineContent(cm, lineView);\n    if (lineView.text == lineView.node) { lineView.node = built.pre; }\n    lineView.text.parentNode.replaceChild(built.pre, lineView.text);\n    lineView.text = built.pre;\n    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {\n      lineView.bgClass = built.bgClass;\n      lineView.textClass = built.textClass;\n      updateLineClasses(cm, lineView);\n    } else if (cls) {\n      lineView.text.className = cls;\n    }\n  }\n\n  function updateLineClasses(cm, lineView) {\n    updateLineBackground(cm, lineView);\n    if (lineView.line.wrapClass)\n      { ensureLineWrapped(lineView).className = lineView.line.wrapClass; }\n    else if (lineView.node != lineView.text)\n      { lineView.node.className = \"\"; }\n    var textClass = lineView.textClass ? lineView.textClass + \" \" + (lineView.line.textClass || \"\") : lineView.line.textClass;\n    lineView.text.className = textClass || \"\";\n  }\n\n  function updateLineGutter(cm, lineView, lineN, dims) {\n    if (lineView.gutter) {\n      lineView.node.removeChild(lineView.gutter);\n      lineView.gutter = null;\n    }\n    if (lineView.gutterBackground) {\n      lineView.node.removeChild(lineView.gutterBackground);\n      lineView.gutterBackground = null;\n    }\n    if (lineView.line.gutterClass) {\n      var wrap = ensureLineWrapped(lineView);\n      lineView.gutterBackground = elt(\"div\", null, \"CodeMirror-gutter-background \" + lineView.line.gutterClass,\n                                      (\"left: \" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px; width: \" + (dims.gutterTotalWidth) + \"px\"));\n      cm.display.input.setUneditable(lineView.gutterBackground);\n      wrap.insertBefore(lineView.gutterBackground, lineView.text);\n    }\n    var markers = lineView.line.gutterMarkers;\n    if (cm.options.lineNumbers || markers) {\n      var wrap$1 = ensureLineWrapped(lineView);\n      var gutterWrap = lineView.gutter = elt(\"div\", null, \"CodeMirror-gutter-wrapper\", (\"left: \" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px\"));\n      cm.display.input.setUneditable(gutterWrap);\n      wrap$1.insertBefore(gutterWrap, lineView.text);\n      if (lineView.line.gutterClass)\n        { gutterWrap.className += \" \" + lineView.line.gutterClass; }\n      if (cm.options.lineNumbers && (!markers || !markers[\"CodeMirror-linenumbers\"]))\n        { lineView.lineNumber = gutterWrap.appendChild(\n          elt(\"div\", lineNumberFor(cm.options, lineN),\n              \"CodeMirror-linenumber CodeMirror-gutter-elt\",\n              (\"left: \" + (dims.gutterLeft[\"CodeMirror-linenumbers\"]) + \"px; width: \" + (cm.display.lineNumInnerWidth) + \"px\"))); }\n      if (markers) { for (var k = 0; k < cm.options.gutters.length; ++k) {\n        var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];\n        if (found)\n          { gutterWrap.appendChild(elt(\"div\", [found], \"CodeMirror-gutter-elt\",\n                                     (\"left: \" + (dims.gutterLeft[id]) + \"px; width: \" + (dims.gutterWidth[id]) + \"px\"))); }\n      } }\n    }\n  }\n\n  function updateLineWidgets(cm, lineView, dims) {\n    if (lineView.alignable) { lineView.alignable = null; }\n    for (var node = lineView.node.firstChild, next = (void 0); node; node = next) {\n      next = node.nextSibling;\n      if (node.className == \"CodeMirror-linewidget\")\n        { lineView.node.removeChild(node); }\n    }\n    insertLineWidgets(cm, lineView, dims);\n  }\n\n  // Build a line's DOM representation from scratch\n  function buildLineElement(cm, lineView, lineN, dims) {\n    var built = getLineContent(cm, lineView);\n    lineView.text = lineView.node = built.pre;\n    if (built.bgClass) { lineView.bgClass = built.bgClass; }\n    if (built.textClass) { lineView.textClass = built.textClass; }\n\n    updateLineClasses(cm, lineView);\n    updateLineGutter(cm, lineView, lineN, dims);\n    insertLineWidgets(cm, lineView, dims);\n    return lineView.node\n  }\n\n  // A lineView may contain multiple logical lines (when merged by\n  // collapsed spans). The widgets for all of them need to be drawn.\n  function insertLineWidgets(cm, lineView, dims) {\n    insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);\n    if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)\n      { insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false); } }\n  }\n\n  function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {\n    if (!line.widgets) { return }\n    var wrap = ensureLineWrapped(lineView);\n    for (var i = 0, ws = line.widgets; i < ws.length; ++i) {\n      var widget = ws[i], node = elt(\"div\", [widget.node], \"CodeMirror-linewidget\");\n      if (!widget.handleMouseEvents) { node.setAttribute(\"cm-ignore-events\", \"true\"); }\n      positionLineWidget(widget, node, lineView, dims);\n      cm.display.input.setUneditable(node);\n      if (allowAbove && widget.above)\n        { wrap.insertBefore(node, lineView.gutter || lineView.text); }\n      else\n        { wrap.appendChild(node); }\n      signalLater(widget, \"redraw\");\n    }\n  }\n\n  function positionLineWidget(widget, node, lineView, dims) {\n    if (widget.noHScroll) {\n  (lineView.alignable || (lineView.alignable = [])).push(node);\n      var width = dims.wrapperWidth;\n      node.style.left = dims.fixedPos + \"px\";\n      if (!widget.coverGutter) {\n        width -= dims.gutterTotalWidth;\n        node.style.paddingLeft = dims.gutterTotalWidth + \"px\";\n      }\n      node.style.width = width + \"px\";\n    }\n    if (widget.coverGutter) {\n      node.style.zIndex = 5;\n      node.style.position = \"relative\";\n      if (!widget.noHScroll) { node.style.marginLeft = -dims.gutterTotalWidth + \"px\"; }\n    }\n  }\n\n  function widgetHeight(widget) {\n    if (widget.height != null) { return widget.height }\n    var cm = widget.doc.cm;\n    if (!cm) { return 0 }\n    if (!contains(document.body, widget.node)) {\n      var parentStyle = \"position: relative;\";\n      if (widget.coverGutter)\n        { parentStyle += \"margin-left: -\" + cm.display.gutters.offsetWidth + \"px;\"; }\n      if (widget.noHScroll)\n        { parentStyle += \"width: \" + cm.display.wrapper.clientWidth + \"px;\"; }\n      removeChildrenAndAdd(cm.display.measure, elt(\"div\", [widget.node], null, parentStyle));\n    }\n    return widget.height = widget.node.parentNode.offsetHeight\n  }\n\n  // Return true when the given mouse event happened in a widget\n  function eventInWidget(display, e) {\n    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {\n      if (!n || (n.nodeType == 1 && n.getAttribute(\"cm-ignore-events\") == \"true\") ||\n          (n.parentNode == display.sizer && n != display.mover))\n        { return true }\n    }\n  }\n\n  // POSITION MEASUREMENT\n\n  function paddingTop(display) {return display.lineSpace.offsetTop}\n  function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight}\n  function paddingH(display) {\n    if (display.cachedPaddingH) { return display.cachedPaddingH }\n    var e = removeChildrenAndAdd(display.measure, elt(\"pre\", \"x\"));\n    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;\n    var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};\n    if (!isNaN(data.left) && !isNaN(data.right)) { display.cachedPaddingH = data; }\n    return data\n  }\n\n  function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth }\n  function displayWidth(cm) {\n    return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth\n  }\n  function displayHeight(cm) {\n    return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight\n  }\n\n  // Ensure the lineView.wrapping.heights array is populated. This is\n  // an array of bottom offsets for the lines that make up a drawn\n  // line. When lineWrapping is on, there might be more than one\n  // height.\n  function ensureLineHeights(cm, lineView, rect) {\n    var wrapping = cm.options.lineWrapping;\n    var curWidth = wrapping && displayWidth(cm);\n    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {\n      var heights = lineView.measure.heights = [];\n      if (wrapping) {\n        lineView.measure.width = curWidth;\n        var rects = lineView.text.firstChild.getClientRects();\n        for (var i = 0; i < rects.length - 1; i++) {\n          var cur = rects[i], next = rects[i + 1];\n          if (Math.abs(cur.bottom - next.bottom) > 2)\n            { heights.push((cur.bottom + next.top) / 2 - rect.top); }\n        }\n      }\n      heights.push(rect.bottom - rect.top);\n    }\n  }\n\n  // Find a line map (mapping character offsets to text nodes) and a\n  // measurement cache for the given line number. (A line view might\n  // contain multiple lines when collapsed ranges are present.)\n  function mapFromLineView(lineView, line, lineN) {\n    if (lineView.line == line)\n      { return {map: lineView.measure.map, cache: lineView.measure.cache} }\n    for (var i = 0; i < lineView.rest.length; i++)\n      { if (lineView.rest[i] == line)\n        { return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]} } }\n    for (var i$1 = 0; i$1 < lineView.rest.length; i$1++)\n      { if (lineNo(lineView.rest[i$1]) > lineN)\n        { return {map: lineView.measure.maps[i$1], cache: lineView.measure.caches[i$1], before: true} } }\n  }\n\n  // Render a line into the hidden node display.externalMeasured. Used\n  // when measurement is needed for a line that's not in the viewport.\n  function updateExternalMeasurement(cm, line) {\n    line = visualLine(line);\n    var lineN = lineNo(line);\n    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);\n    view.lineN = lineN;\n    var built = view.built = buildLineContent(cm, view);\n    view.text = built.pre;\n    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);\n    return view\n  }\n\n  // Get a {top, bottom, left, right} box (in line-local coordinates)\n  // for a given character.\n  function measureChar(cm, line, ch, bias) {\n    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias)\n  }\n\n  // Find a line view that corresponds to the given line number.\n  function findViewForLine(cm, lineN) {\n    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)\n      { return cm.display.view[findViewIndex(cm, lineN)] }\n    var ext = cm.display.externalMeasured;\n    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)\n      { return ext }\n  }\n\n  // Measurement can be split in two steps, the set-up work that\n  // applies to the whole line, and the measurement of the actual\n  // character. Functions like coordsChar, that need to do a lot of\n  // measurements in a row, can thus ensure that the set-up work is\n  // only done once.\n  function prepareMeasureForLine(cm, line) {\n    var lineN = lineNo(line);\n    var view = findViewForLine(cm, lineN);\n    if (view && !view.text) {\n      view = null;\n    } else if (view && view.changes) {\n      updateLineForChanges(cm, view, lineN, getDimensions(cm));\n      cm.curOp.forceUpdate = true;\n    }\n    if (!view)\n      { view = updateExternalMeasurement(cm, line); }\n\n    var info = mapFromLineView(view, line, lineN);\n    return {\n      line: line, view: view, rect: null,\n      map: info.map, cache: info.cache, before: info.before,\n      hasHeights: false\n    }\n  }\n\n  // Given a prepared measurement object, measures the position of an\n  // actual character (or fetches it from the cache).\n  function measureCharPrepared(cm, prepared, ch, bias, varHeight) {\n    if (prepared.before) { ch = -1; }\n    var key = ch + (bias || \"\"), found;\n    if (prepared.cache.hasOwnProperty(key)) {\n      found = prepared.cache[key];\n    } else {\n      if (!prepared.rect)\n        { prepared.rect = prepared.view.text.getBoundingClientRect(); }\n      if (!prepared.hasHeights) {\n        ensureLineHeights(cm, prepared.view, prepared.rect);\n        prepared.hasHeights = true;\n      }\n      found = measureCharInner(cm, prepared, ch, bias);\n      if (!found.bogus) { prepared.cache[key] = found; }\n    }\n    return {left: found.left, right: found.right,\n            top: varHeight ? found.rtop : found.top,\n            bottom: varHeight ? found.rbottom : found.bottom}\n  }\n\n  var nullRect = {left: 0, right: 0, top: 0, bottom: 0};\n\n  function nodeAndOffsetInLineMap(map$$1, ch, bias) {\n    var node, start, end, collapse, mStart, mEnd;\n    // First, search the line map for the text node corresponding to,\n    // or closest to, the target character.\n    for (var i = 0; i < map$$1.length; i += 3) {\n      mStart = map$$1[i];\n      mEnd = map$$1[i + 1];\n      if (ch < mStart) {\n        start = 0; end = 1;\n        collapse = \"left\";\n      } else if (ch < mEnd) {\n        start = ch - mStart;\n        end = start + 1;\n      } else if (i == map$$1.length - 3 || ch == mEnd && map$$1[i + 3] > ch) {\n        end = mEnd - mStart;\n        start = end - 1;\n        if (ch >= mEnd) { collapse = \"right\"; }\n      }\n      if (start != null) {\n        node = map$$1[i + 2];\n        if (mStart == mEnd && bias == (node.insertLeft ? \"left\" : \"right\"))\n          { collapse = bias; }\n        if (bias == \"left\" && start == 0)\n          { while (i && map$$1[i - 2] == map$$1[i - 3] && map$$1[i - 1].insertLeft) {\n            node = map$$1[(i -= 3) + 2];\n            collapse = \"left\";\n          } }\n        if (bias == \"right\" && start == mEnd - mStart)\n          { while (i < map$$1.length - 3 && map$$1[i + 3] == map$$1[i + 4] && !map$$1[i + 5].insertLeft) {\n            node = map$$1[(i += 3) + 2];\n            collapse = \"right\";\n          } }\n        break\n      }\n    }\n    return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd}\n  }\n\n  function getUsefulRect(rects, bias) {\n    var rect = nullRect;\n    if (bias == \"left\") { for (var i = 0; i < rects.length; i++) {\n      if ((rect = rects[i]).left != rect.right) { break }\n    } } else { for (var i$1 = rects.length - 1; i$1 >= 0; i$1--) {\n      if ((rect = rects[i$1]).left != rect.right) { break }\n    } }\n    return rect\n  }\n\n  function measureCharInner(cm, prepared, ch, bias) {\n    var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);\n    var node = place.node, start = place.start, end = place.end, collapse = place.collapse;\n\n    var rect;\n    if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.\n      for (var i$1 = 0; i$1 < 4; i$1++) { // Retry a maximum of 4 times when nonsense rectangles are returned\n        while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) { --start; }\n        while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) { ++end; }\n        if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart)\n          { rect = node.parentNode.getBoundingClientRect(); }\n        else\n          { rect = getUsefulRect(range(node, start, end).getClientRects(), bias); }\n        if (rect.left || rect.right || start == 0) { break }\n        end = start;\n        start = start - 1;\n        collapse = \"right\";\n      }\n      if (ie && ie_version < 11) { rect = maybeUpdateRectForZooming(cm.display.measure, rect); }\n    } else { // If it is a widget, simply get the box for the whole widget.\n      if (start > 0) { collapse = bias = \"right\"; }\n      var rects;\n      if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)\n        { rect = rects[bias == \"right\" ? rects.length - 1 : 0]; }\n      else\n        { rect = node.getBoundingClientRect(); }\n    }\n    if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {\n      var rSpan = node.parentNode.getClientRects()[0];\n      if (rSpan)\n        { rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom}; }\n      else\n        { rect = nullRect; }\n    }\n\n    var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;\n    var mid = (rtop + rbot) / 2;\n    var heights = prepared.view.measure.heights;\n    var i = 0;\n    for (; i < heights.length - 1; i++)\n      { if (mid < heights[i]) { break } }\n    var top = i ? heights[i - 1] : 0, bot = heights[i];\n    var result = {left: (collapse == \"right\" ? rect.right : rect.left) - prepared.rect.left,\n                  right: (collapse == \"left\" ? rect.left : rect.right) - prepared.rect.left,\n                  top: top, bottom: bot};\n    if (!rect.left && !rect.right) { result.bogus = true; }\n    if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }\n\n    return result\n  }\n\n  // Work around problem with bounding client rects on ranges being\n  // returned incorrectly when zoomed on IE10 and below.\n  function maybeUpdateRectForZooming(measure, rect) {\n    if (!window.screen || screen.logicalXDPI == null ||\n        screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))\n      { return rect }\n    var scaleX = screen.logicalXDPI / screen.deviceXDPI;\n    var scaleY = screen.logicalYDPI / screen.deviceYDPI;\n    return {left: rect.left * scaleX, right: rect.right * scaleX,\n            top: rect.top * scaleY, bottom: rect.bottom * scaleY}\n  }\n\n  function clearLineMeasurementCacheFor(lineView) {\n    if (lineView.measure) {\n      lineView.measure.cache = {};\n      lineView.measure.heights = null;\n      if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)\n        { lineView.measure.caches[i] = {}; } }\n    }\n  }\n\n  function clearLineMeasurementCache(cm) {\n    cm.display.externalMeasure = null;\n    removeChildren(cm.display.lineMeasure);\n    for (var i = 0; i < cm.display.view.length; i++)\n      { clearLineMeasurementCacheFor(cm.display.view[i]); }\n  }\n\n  function clearCaches(cm) {\n    clearLineMeasurementCache(cm);\n    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;\n    if (!cm.options.lineWrapping) { cm.display.maxLineChanged = true; }\n    cm.display.lineNumChars = null;\n  }\n\n  function pageScrollX() {\n    // Work around https://bugs.chromium.org/p/chromium/issues/detail?id=489206\n    // which causes page_Offset and bounding client rects to use\n    // different reference viewports and invalidate our calculations.\n    if (chrome && android) { return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft)) }\n    return window.pageXOffset || (document.documentElement || document.body).scrollLeft\n  }\n  function pageScrollY() {\n    if (chrome && android) { return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop)) }\n    return window.pageYOffset || (document.documentElement || document.body).scrollTop\n  }\n\n  function widgetTopHeight(lineObj) {\n    var height = 0;\n    if (lineObj.widgets) { for (var i = 0; i < lineObj.widgets.length; ++i) { if (lineObj.widgets[i].above)\n      { height += widgetHeight(lineObj.widgets[i]); } } }\n    return height\n  }\n\n  // Converts a {top, bottom, left, right} box from line-local\n  // coordinates into another coordinate system. Context may be one of\n  // \"line\", \"div\" (display.lineDiv), \"local\"./null (editor), \"window\",\n  // or \"page\".\n  function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {\n    if (!includeWidgets) {\n      var height = widgetTopHeight(lineObj);\n      rect.top += height; rect.bottom += height;\n    }\n    if (context == \"line\") { return rect }\n    if (!context) { context = \"local\"; }\n    var yOff = heightAtLine(lineObj);\n    if (context == \"local\") { yOff += paddingTop(cm.display); }\n    else { yOff -= cm.display.viewOffset; }\n    if (context == \"page\" || context == \"window\") {\n      var lOff = cm.display.lineSpace.getBoundingClientRect();\n      yOff += lOff.top + (context == \"window\" ? 0 : pageScrollY());\n      var xOff = lOff.left + (context == \"window\" ? 0 : pageScrollX());\n      rect.left += xOff; rect.right += xOff;\n    }\n    rect.top += yOff; rect.bottom += yOff;\n    return rect\n  }\n\n  // Coverts a box from \"div\" coords to another coordinate system.\n  // Context may be \"window\", \"page\", \"div\", or \"local\"./null.\n  function fromCoordSystem(cm, coords, context) {\n    if (context == \"div\") { return coords }\n    var left = coords.left, top = coords.top;\n    // First move into \"page\" coordinate system\n    if (context == \"page\") {\n      left -= pageScrollX();\n      top -= pageScrollY();\n    } else if (context == \"local\" || !context) {\n      var localBox = cm.display.sizer.getBoundingClientRect();\n      left += localBox.left;\n      top += localBox.top;\n    }\n\n    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();\n    return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top}\n  }\n\n  function charCoords(cm, pos, context, lineObj, bias) {\n    if (!lineObj) { lineObj = getLine(cm.doc, pos.line); }\n    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context)\n  }\n\n  // Returns a box for a given cursor position, which may have an\n  // 'other' property containing the position of the secondary cursor\n  // on a bidi boundary.\n  // A cursor Pos(line, char, \"before\") is on the same visual line as `char - 1`\n  // and after `char - 1` in writing order of `char - 1`\n  // A cursor Pos(line, char, \"after\") is on the same visual line as `char`\n  // and before `char` in writing order of `char`\n  // Examples (upper-case letters are RTL, lower-case are LTR):\n  //     Pos(0, 1, ...)\n  //     before   after\n  // ab     a|b     a|b\n  // aB     a|B     aB|\n  // Ab     |Ab     A|b\n  // AB     B|A     B|A\n  // Every position after the last character on a line is considered to stick\n  // to the last character on the line.\n  function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {\n    lineObj = lineObj || getLine(cm.doc, pos.line);\n    if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }\n    function get(ch, right) {\n      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? \"right\" : \"left\", varHeight);\n      if (right) { m.left = m.right; } else { m.right = m.left; }\n      return intoCoordSystem(cm, lineObj, m, context)\n    }\n    var order = getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;\n    if (ch >= lineObj.text.length) {\n      ch = lineObj.text.length;\n      sticky = \"before\";\n    } else if (ch <= 0) {\n      ch = 0;\n      sticky = \"after\";\n    }\n    if (!order) { return get(sticky == \"before\" ? ch - 1 : ch, sticky == \"before\") }\n\n    function getBidi(ch, partPos, invert) {\n      var part = order[partPos], right = part.level == 1;\n      return get(invert ? ch - 1 : ch, right != invert)\n    }\n    var partPos = getBidiPartAt(order, ch, sticky);\n    var other = bidiOther;\n    var val = getBidi(ch, partPos, sticky == \"before\");\n    if (other != null) { val.other = getBidi(ch, other, sticky != \"before\"); }\n    return val\n  }\n\n  // Used to cheaply estimate the coordinates for a position. Used for\n  // intermediate scroll updates.\n  function estimateCoords(cm, pos) {\n    var left = 0;\n    pos = clipPos(cm.doc, pos);\n    if (!cm.options.lineWrapping) { left = charWidth(cm.display) * pos.ch; }\n    var lineObj = getLine(cm.doc, pos.line);\n    var top = heightAtLine(lineObj) + paddingTop(cm.display);\n    return {left: left, right: left, top: top, bottom: top + lineObj.height}\n  }\n\n  // Positions returned by coordsChar contain some extra information.\n  // xRel is the relative x position of the input coordinates compared\n  // to the found position (so xRel > 0 means the coordinates are to\n  // the right of the character position, for example). When outside\n  // is true, that means the coordinates lie outside the line's\n  // vertical range.\n  function PosWithInfo(line, ch, sticky, outside, xRel) {\n    var pos = Pos(line, ch, sticky);\n    pos.xRel = xRel;\n    if (outside) { pos.outside = true; }\n    return pos\n  }\n\n  // Compute the character position closest to the given coordinates.\n  // Input must be lineSpace-local (\"div\" coordinate system).\n  function coordsChar(cm, x, y) {\n    var doc = cm.doc;\n    y += cm.display.viewOffset;\n    if (y < 0) { return PosWithInfo(doc.first, 0, null, true, -1) }\n    var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;\n    if (lineN > last)\n      { return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, true, 1) }\n    if (x < 0) { x = 0; }\n\n    var lineObj = getLine(doc, lineN);\n    for (;;) {\n      var found = coordsCharInner(cm, lineObj, lineN, x, y);\n      var collapsed = collapsedSpanAround(lineObj, found.ch + (found.xRel > 0 ? 1 : 0));\n      if (!collapsed) { return found }\n      var rangeEnd = collapsed.find(1);\n      if (rangeEnd.line == lineN) { return rangeEnd }\n      lineObj = getLine(doc, lineN = rangeEnd.line);\n    }\n  }\n\n  function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {\n    y -= widgetTopHeight(lineObj);\n    var end = lineObj.text.length;\n    var begin = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y; }, end, 0);\n    end = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch).top > y; }, begin, end);\n    return {begin: begin, end: end}\n  }\n\n  function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {\n    if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }\n    var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), \"line\").top;\n    return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop)\n  }\n\n  // Returns true if the given side of a box is after the given\n  // coordinates, in top-to-bottom, left-to-right order.\n  function boxIsAfter(box, x, y, left) {\n    return box.bottom <= y ? false : box.top > y ? true : (left ? box.left : box.right) > x\n  }\n\n  function coordsCharInner(cm, lineObj, lineNo$$1, x, y) {\n    // Move y into line-local coordinate space\n    y -= heightAtLine(lineObj);\n    var preparedMeasure = prepareMeasureForLine(cm, lineObj);\n    // When directly calling `measureCharPrepared`, we have to adjust\n    // for the widgets at this line.\n    var widgetHeight$$1 = widgetTopHeight(lineObj);\n    var begin = 0, end = lineObj.text.length, ltr = true;\n\n    var order = getOrder(lineObj, cm.doc.direction);\n    // If the line isn't plain left-to-right text, first figure out\n    // which bidi section the coordinates fall into.\n    if (order) {\n      var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)\n                   (cm, lineObj, lineNo$$1, preparedMeasure, order, x, y);\n      ltr = part.level != 1;\n      // The awkward -1 offsets are needed because findFirst (called\n      // on these below) will treat its first bound as inclusive,\n      // second as exclusive, but we want to actually address the\n      // characters in the part's range\n      begin = ltr ? part.from : part.to - 1;\n      end = ltr ? part.to : part.from - 1;\n    }\n\n    // A binary search to find the first character whose bounding box\n    // starts after the coordinates. If we run across any whose box wrap\n    // the coordinates, store that.\n    var chAround = null, boxAround = null;\n    var ch = findFirst(function (ch) {\n      var box = measureCharPrepared(cm, preparedMeasure, ch);\n      box.top += widgetHeight$$1; box.bottom += widgetHeight$$1;\n      if (!boxIsAfter(box, x, y, false)) { return false }\n      if (box.top <= y && box.left <= x) {\n        chAround = ch;\n        boxAround = box;\n      }\n      return true\n    }, begin, end);\n\n    var baseX, sticky, outside = false;\n    // If a box around the coordinates was found, use that\n    if (boxAround) {\n      // Distinguish coordinates nearer to the left or right side of the box\n      var atLeft = x - boxAround.left < boxAround.right - x, atStart = atLeft == ltr;\n      ch = chAround + (atStart ? 0 : 1);\n      sticky = atStart ? \"after\" : \"before\";\n      baseX = atLeft ? boxAround.left : boxAround.right;\n    } else {\n      // (Adjust for extended bound, if necessary.)\n      if (!ltr && (ch == end || ch == begin)) { ch++; }\n      // To determine which side to associate with, get the box to the\n      // left of the character and compare it's vertical position to the\n      // coordinates\n      sticky = ch == 0 ? \"after\" : ch == lineObj.text.length ? \"before\" :\n        (measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight$$1 <= y) == ltr ?\n        \"after\" : \"before\";\n      // Now get accurate coordinates for this place, in order to get a\n      // base X position\n      var coords = cursorCoords(cm, Pos(lineNo$$1, ch, sticky), \"line\", lineObj, preparedMeasure);\n      baseX = coords.left;\n      outside = y < coords.top || y >= coords.bottom;\n    }\n\n    ch = skipExtendingChars(lineObj.text, ch, 1);\n    return PosWithInfo(lineNo$$1, ch, sticky, outside, x - baseX)\n  }\n\n  function coordsBidiPart(cm, lineObj, lineNo$$1, preparedMeasure, order, x, y) {\n    // Bidi parts are sorted left-to-right, and in a non-line-wrapping\n    // situation, we can take this ordering to correspond to the visual\n    // ordering. This finds the first part whose end is after the given\n    // coordinates.\n    var index = findFirst(function (i) {\n      var part = order[i], ltr = part.level != 1;\n      return boxIsAfter(cursorCoords(cm, Pos(lineNo$$1, ltr ? part.to : part.from, ltr ? \"before\" : \"after\"),\n                                     \"line\", lineObj, preparedMeasure), x, y, true)\n    }, 0, order.length - 1);\n    var part = order[index];\n    // If this isn't the first part, the part's start is also after\n    // the coordinates, and the coordinates aren't on the same line as\n    // that start, move one part back.\n    if (index > 0) {\n      var ltr = part.level != 1;\n      var start = cursorCoords(cm, Pos(lineNo$$1, ltr ? part.from : part.to, ltr ? \"after\" : \"before\"),\n                               \"line\", lineObj, preparedMeasure);\n      if (boxIsAfter(start, x, y, true) && start.top > y)\n        { part = order[index - 1]; }\n    }\n    return part\n  }\n\n  function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {\n    // In a wrapped line, rtl text on wrapping boundaries can do things\n    // that don't correspond to the ordering in our `order` array at\n    // all, so a binary search doesn't work, and we want to return a\n    // part that only spans one line so that the binary search in\n    // coordsCharInner is safe. As such, we first find the extent of the\n    // wrapped line, and then do a flat search in which we discard any\n    // spans that aren't on the line.\n    var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y);\n    var begin = ref.begin;\n    var end = ref.end;\n    if (/\\s/.test(lineObj.text.charAt(end - 1))) { end--; }\n    var part = null, closestDist = null;\n    for (var i = 0; i < order.length; i++) {\n      var p = order[i];\n      if (p.from >= end || p.to <= begin) { continue }\n      var ltr = p.level != 1;\n      var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right;\n      // Weigh against spans ending before this, so that they are only\n      // picked if nothing ends after\n      var dist = endX < x ? x - endX + 1e9 : endX - x;\n      if (!part || closestDist > dist) {\n        part = p;\n        closestDist = dist;\n      }\n    }\n    if (!part) { part = order[order.length - 1]; }\n    // Clip the part to the wrapped line.\n    if (part.from < begin) { part = {from: begin, to: part.to, level: part.level}; }\n    if (part.to > end) { part = {from: part.from, to: end, level: part.level}; }\n    return part\n  }\n\n  var measureText;\n  // Compute the default text height.\n  function textHeight(display) {\n    if (display.cachedTextHeight != null) { return display.cachedTextHeight }\n    if (measureText == null) {\n      measureText = elt(\"pre\");\n      // Measure a bunch of lines, for browsers that compute\n      // fractional heights.\n      for (var i = 0; i < 49; ++i) {\n        measureText.appendChild(document.createTextNode(\"x\"));\n        measureText.appendChild(elt(\"br\"));\n      }\n      measureText.appendChild(document.createTextNode(\"x\"));\n    }\n    removeChildrenAndAdd(display.measure, measureText);\n    var height = measureText.offsetHeight / 50;\n    if (height > 3) { display.cachedTextHeight = height; }\n    removeChildren(display.measure);\n    return height || 1\n  }\n\n  // Compute the default character width.\n  function charWidth(display) {\n    if (display.cachedCharWidth != null) { return display.cachedCharWidth }\n    var anchor = elt(\"span\", \"xxxxxxxxxx\");\n    var pre = elt(\"pre\", [anchor]);\n    removeChildrenAndAdd(display.measure, pre);\n    var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;\n    if (width > 2) { display.cachedCharWidth = width; }\n    return width || 10\n  }\n\n  // Do a bulk-read of the DOM positions and sizes needed to draw the\n  // view, so that we don't interleave reading and writing to the DOM.\n  function getDimensions(cm) {\n    var d = cm.display, left = {}, width = {};\n    var gutterLeft = d.gutters.clientLeft;\n    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {\n      left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft;\n      width[cm.options.gutters[i]] = n.clientWidth;\n    }\n    return {fixedPos: compensateForHScroll(d),\n            gutterTotalWidth: d.gutters.offsetWidth,\n            gutterLeft: left,\n            gutterWidth: width,\n            wrapperWidth: d.wrapper.clientWidth}\n  }\n\n  // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,\n  // but using getBoundingClientRect to get a sub-pixel-accurate\n  // result.\n  function compensateForHScroll(display) {\n    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left\n  }\n\n  // Returns a function that estimates the height of a line, to use as\n  // first approximation until the line becomes visible (and is thus\n  // properly measurable).\n  function estimateHeight(cm) {\n    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;\n    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);\n    return function (line) {\n      if (lineIsHidden(cm.doc, line)) { return 0 }\n\n      var widgetsHeight = 0;\n      if (line.widgets) { for (var i = 0; i < line.widgets.length; i++) {\n        if (line.widgets[i].height) { widgetsHeight += line.widgets[i].height; }\n      } }\n\n      if (wrapping)\n        { return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th }\n      else\n        { return widgetsHeight + th }\n    }\n  }\n\n  function estimateLineHeights(cm) {\n    var doc = cm.doc, est = estimateHeight(cm);\n    doc.iter(function (line) {\n      var estHeight = est(line);\n      if (estHeight != line.height) { updateLineHeight(line, estHeight); }\n    });\n  }\n\n  // Given a mouse event, find the corresponding position. If liberal\n  // is false, it checks whether a gutter or scrollbar was clicked,\n  // and returns null if it was. forRect is used by rectangular\n  // selections, and tries to estimate a character position even for\n  // coordinates beyond the right of the text.\n  function posFromMouse(cm, e, liberal, forRect) {\n    var display = cm.display;\n    if (!liberal && e_target(e).getAttribute(\"cm-not-content\") == \"true\") { return null }\n\n    var x, y, space = display.lineSpace.getBoundingClientRect();\n    // Fails unpredictably on IE[67] when mouse is dragged around quickly.\n    try { x = e.clientX - space.left; y = e.clientY - space.top; }\n    catch (e) { return null }\n    var coords = coordsChar(cm, x, y), line;\n    if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {\n      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;\n      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));\n    }\n    return coords\n  }\n\n  // Find the view element corresponding to a given line. Return null\n  // when the line isn't visible.\n  function findViewIndex(cm, n) {\n    if (n >= cm.display.viewTo) { return null }\n    n -= cm.display.viewFrom;\n    if (n < 0) { return null }\n    var view = cm.display.view;\n    for (var i = 0; i < view.length; i++) {\n      n -= view[i].size;\n      if (n < 0) { return i }\n    }\n  }\n\n  function updateSelection(cm) {\n    cm.display.input.showSelection(cm.display.input.prepareSelection());\n  }\n\n  function prepareSelection(cm, primary) {\n    if ( primary === void 0 ) primary = true;\n\n    var doc = cm.doc, result = {};\n    var curFragment = result.cursors = document.createDocumentFragment();\n    var selFragment = result.selection = document.createDocumentFragment();\n\n    for (var i = 0; i < doc.sel.ranges.length; i++) {\n      if (!primary && i == doc.sel.primIndex) { continue }\n      var range$$1 = doc.sel.ranges[i];\n      if (range$$1.from().line >= cm.display.viewTo || range$$1.to().line < cm.display.viewFrom) { continue }\n      var collapsed = range$$1.empty();\n      if (collapsed || cm.options.showCursorWhenSelecting)\n        { drawSelectionCursor(cm, range$$1.head, curFragment); }\n      if (!collapsed)\n        { drawSelectionRange(cm, range$$1, selFragment); }\n    }\n    return result\n  }\n\n  // Draws a cursor for the given range\n  function drawSelectionCursor(cm, head, output) {\n    var pos = cursorCoords(cm, head, \"div\", null, null, !cm.options.singleCursorHeightPerLine);\n\n    var cursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor\"));\n    cursor.style.left = pos.left + \"px\";\n    cursor.style.top = pos.top + \"px\";\n    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + \"px\";\n\n    if (pos.other) {\n      // Secondary cursor, shown when on a 'jump' in bi-directional text\n      var otherCursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor CodeMirror-secondarycursor\"));\n      otherCursor.style.display = \"\";\n      otherCursor.style.left = pos.other.left + \"px\";\n      otherCursor.style.top = pos.other.top + \"px\";\n      otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + \"px\";\n    }\n  }\n\n  function cmpCoords(a, b) { return a.top - b.top || a.left - b.left }\n\n  // Draws the given range as a highlighted selection\n  function drawSelectionRange(cm, range$$1, output) {\n    var display = cm.display, doc = cm.doc;\n    var fragment = document.createDocumentFragment();\n    var padding = paddingH(cm.display), leftSide = padding.left;\n    var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;\n    var docLTR = doc.direction == \"ltr\";\n\n    function add(left, top, width, bottom) {\n      if (top < 0) { top = 0; }\n      top = Math.round(top);\n      bottom = Math.round(bottom);\n      fragment.appendChild(elt(\"div\", null, \"CodeMirror-selected\", (\"position: absolute; left: \" + left + \"px;\\n                             top: \" + top + \"px; width: \" + (width == null ? rightSide - left : width) + \"px;\\n                             height: \" + (bottom - top) + \"px\")));\n    }\n\n    function drawForLine(line, fromArg, toArg) {\n      var lineObj = getLine(doc, line);\n      var lineLen = lineObj.text.length;\n      var start, end;\n      function coords(ch, bias) {\n        return charCoords(cm, Pos(line, ch), \"div\", lineObj, bias)\n      }\n\n      function wrapX(pos, dir, side) {\n        var extent = wrappedLineExtentChar(cm, lineObj, null, pos);\n        var prop = (dir == \"ltr\") == (side == \"after\") ? \"left\" : \"right\";\n        var ch = side == \"after\" ? extent.begin : extent.end - (/\\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);\n        return coords(ch, prop)[prop]\n      }\n\n      var order = getOrder(lineObj, doc.direction);\n      iterateBidiSections(order, fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir, i) {\n        var ltr = dir == \"ltr\";\n        var fromPos = coords(from, ltr ? \"left\" : \"right\");\n        var toPos = coords(to - 1, ltr ? \"right\" : \"left\");\n\n        var openStart = fromArg == null && from == 0, openEnd = toArg == null && to == lineLen;\n        var first = i == 0, last = !order || i == order.length - 1;\n        if (toPos.top - fromPos.top <= 3) { // Single line\n          var openLeft = (docLTR ? openStart : openEnd) && first;\n          var openRight = (docLTR ? openEnd : openStart) && last;\n          var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;\n          var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;\n          add(left, fromPos.top, right - left, fromPos.bottom);\n        } else { // Multiple lines\n          var topLeft, topRight, botLeft, botRight;\n          if (ltr) {\n            topLeft = docLTR && openStart && first ? leftSide : fromPos.left;\n            topRight = docLTR ? rightSide : wrapX(from, dir, \"before\");\n            botLeft = docLTR ? leftSide : wrapX(to, dir, \"after\");\n            botRight = docLTR && openEnd && last ? rightSide : toPos.right;\n          } else {\n            topLeft = !docLTR ? leftSide : wrapX(from, dir, \"before\");\n            topRight = !docLTR && openStart && first ? rightSide : fromPos.right;\n            botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;\n            botRight = !docLTR ? rightSide : wrapX(to, dir, \"after\");\n          }\n          add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);\n          if (fromPos.bottom < toPos.top) { add(leftSide, fromPos.bottom, null, toPos.top); }\n          add(botLeft, toPos.top, botRight - botLeft, toPos.bottom);\n        }\n\n        if (!start || cmpCoords(fromPos, start) < 0) { start = fromPos; }\n        if (cmpCoords(toPos, start) < 0) { start = toPos; }\n        if (!end || cmpCoords(fromPos, end) < 0) { end = fromPos; }\n        if (cmpCoords(toPos, end) < 0) { end = toPos; }\n      });\n      return {start: start, end: end}\n    }\n\n    var sFrom = range$$1.from(), sTo = range$$1.to();\n    if (sFrom.line == sTo.line) {\n      drawForLine(sFrom.line, sFrom.ch, sTo.ch);\n    } else {\n      var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);\n      var singleVLine = visualLine(fromLine) == visualLine(toLine);\n      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;\n      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;\n      if (singleVLine) {\n        if (leftEnd.top < rightStart.top - 2) {\n          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);\n          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);\n        } else {\n          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);\n        }\n      }\n      if (leftEnd.bottom < rightStart.top)\n        { add(leftSide, leftEnd.bottom, null, rightStart.top); }\n    }\n\n    output.appendChild(fragment);\n  }\n\n  // Cursor-blinking\n  function restartBlink(cm) {\n    if (!cm.state.focused) { return }\n    var display = cm.display;\n    clearInterval(display.blinker);\n    var on = true;\n    display.cursorDiv.style.visibility = \"\";\n    if (cm.options.cursorBlinkRate > 0)\n      { display.blinker = setInterval(function () { return display.cursorDiv.style.visibility = (on = !on) ? \"\" : \"hidden\"; },\n        cm.options.cursorBlinkRate); }\n    else if (cm.options.cursorBlinkRate < 0)\n      { display.cursorDiv.style.visibility = \"hidden\"; }\n  }\n\n  function ensureFocus(cm) {\n    if (!cm.state.focused) { cm.display.input.focus(); onFocus(cm); }\n  }\n\n  function delayBlurEvent(cm) {\n    cm.state.delayingBlurEvent = true;\n    setTimeout(function () { if (cm.state.delayingBlurEvent) {\n      cm.state.delayingBlurEvent = false;\n      onBlur(cm);\n    } }, 100);\n  }\n\n  function onFocus(cm, e) {\n    if (cm.state.delayingBlurEvent) { cm.state.delayingBlurEvent = false; }\n\n    if (cm.options.readOnly == \"nocursor\") { return }\n    if (!cm.state.focused) {\n      signal(cm, \"focus\", cm, e);\n      cm.state.focused = true;\n      addClass(cm.display.wrapper, \"CodeMirror-focused\");\n      // This test prevents this from firing when a context\n      // menu is closed (since the input reset would kill the\n      // select-all detection hack)\n      if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {\n        cm.display.input.reset();\n        if (webkit) { setTimeout(function () { return cm.display.input.reset(true); }, 20); } // Issue #1730\n      }\n      cm.display.input.receivedFocus();\n    }\n    restartBlink(cm);\n  }\n  function onBlur(cm, e) {\n    if (cm.state.delayingBlurEvent) { return }\n\n    if (cm.state.focused) {\n      signal(cm, \"blur\", cm, e);\n      cm.state.focused = false;\n      rmClass(cm.display.wrapper, \"CodeMirror-focused\");\n    }\n    clearInterval(cm.display.blinker);\n    setTimeout(function () { if (!cm.state.focused) { cm.display.shift = false; } }, 150);\n  }\n\n  // Read the actual heights of the rendered lines, and update their\n  // stored heights to match.\n  function updateHeightsInViewport(cm) {\n    var display = cm.display;\n    var prevBottom = display.lineDiv.offsetTop;\n    for (var i = 0; i < display.view.length; i++) {\n      var cur = display.view[i], wrapping = cm.options.lineWrapping;\n      var height = (void 0), width = 0;\n      if (cur.hidden) { continue }\n      if (ie && ie_version < 8) {\n        var bot = cur.node.offsetTop + cur.node.offsetHeight;\n        height = bot - prevBottom;\n        prevBottom = bot;\n      } else {\n        var box = cur.node.getBoundingClientRect();\n        height = box.bottom - box.top;\n        // Check that lines don't extend past the right of the current\n        // editor width\n        if (!wrapping && cur.text.firstChild)\n          { width = cur.text.firstChild.getBoundingClientRect().right - box.left - 1; }\n      }\n      var diff = cur.line.height - height;\n      if (diff > .005 || diff < -.005) {\n        updateLineHeight(cur.line, height);\n        updateWidgetHeight(cur.line);\n        if (cur.rest) { for (var j = 0; j < cur.rest.length; j++)\n          { updateWidgetHeight(cur.rest[j]); } }\n      }\n      if (width > cm.display.sizerWidth) {\n        var chWidth = Math.ceil(width / charWidth(cm.display));\n        if (chWidth > cm.display.maxLineLength) {\n          cm.display.maxLineLength = chWidth;\n          cm.display.maxLine = cur.line;\n          cm.display.maxLineChanged = true;\n        }\n      }\n    }\n  }\n\n  // Read and store the height of line widgets associated with the\n  // given line.\n  function updateWidgetHeight(line) {\n    if (line.widgets) { for (var i = 0; i < line.widgets.length; ++i) {\n      var w = line.widgets[i], parent = w.node.parentNode;\n      if (parent) { w.height = parent.offsetHeight; }\n    } }\n  }\n\n  // Compute the lines that are visible in a given viewport (defaults\n  // the the current scroll position). viewport may contain top,\n  // height, and ensure (see op.scrollToPos) properties.\n  function visibleLines(display, doc, viewport) {\n    var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;\n    top = Math.floor(top - paddingTop(display));\n    var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;\n\n    var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);\n    // Ensure is a {from: {line, ch}, to: {line, ch}} object, and\n    // forces those lines into the viewport (if possible).\n    if (viewport && viewport.ensure) {\n      var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;\n      if (ensureFrom < from) {\n        from = ensureFrom;\n        to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);\n      } else if (Math.min(ensureTo, doc.lastLine()) >= to) {\n        from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);\n        to = ensureTo;\n      }\n    }\n    return {from: from, to: Math.max(to, from + 1)}\n  }\n\n  // Re-align line numbers and gutter marks to compensate for\n  // horizontal scrolling.\n  function alignHorizontally(cm) {\n    var display = cm.display, view = display.view;\n    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) { return }\n    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;\n    var gutterW = display.gutters.offsetWidth, left = comp + \"px\";\n    for (var i = 0; i < view.length; i++) { if (!view[i].hidden) {\n      if (cm.options.fixedGutter) {\n        if (view[i].gutter)\n          { view[i].gutter.style.left = left; }\n        if (view[i].gutterBackground)\n          { view[i].gutterBackground.style.left = left; }\n      }\n      var align = view[i].alignable;\n      if (align) { for (var j = 0; j < align.length; j++)\n        { align[j].style.left = left; } }\n    } }\n    if (cm.options.fixedGutter)\n      { display.gutters.style.left = (comp + gutterW) + \"px\"; }\n  }\n\n  // Used to ensure that the line number gutter is still the right\n  // size for the current document size. Returns true when an update\n  // is needed.\n  function maybeUpdateLineNumberWidth(cm) {\n    if (!cm.options.lineNumbers) { return false }\n    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;\n    if (last.length != display.lineNumChars) {\n      var test = display.measure.appendChild(elt(\"div\", [elt(\"div\", last)],\n                                                 \"CodeMirror-linenumber CodeMirror-gutter-elt\"));\n      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;\n      display.lineGutter.style.width = \"\";\n      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;\n      display.lineNumWidth = display.lineNumInnerWidth + padding;\n      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;\n      display.lineGutter.style.width = display.lineNumWidth + \"px\";\n      updateGutterSpace(cm);\n      return true\n    }\n    return false\n  }\n\n  // SCROLLING THINGS INTO VIEW\n\n  // If an editor sits on the top or bottom of the window, partially\n  // scrolled out of view, this ensures that the cursor is visible.\n  function maybeScrollWindow(cm, rect) {\n    if (signalDOMEvent(cm, \"scrollCursorIntoView\")) { return }\n\n    var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;\n    if (rect.top + box.top < 0) { doScroll = true; }\n    else if (rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) { doScroll = false; }\n    if (doScroll != null && !phantom) {\n      var scrollNode = elt(\"div\", \"\\u200b\", null, (\"position: absolute;\\n                         top: \" + (rect.top - display.viewOffset - paddingTop(cm.display)) + \"px;\\n                         height: \" + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + \"px;\\n                         left: \" + (rect.left) + \"px; width: \" + (Math.max(2, rect.right - rect.left)) + \"px;\"));\n      cm.display.lineSpace.appendChild(scrollNode);\n      scrollNode.scrollIntoView(doScroll);\n      cm.display.lineSpace.removeChild(scrollNode);\n    }\n  }\n\n  // Scroll a given position into view (immediately), verifying that\n  // it actually became visible (as line heights are accurately\n  // measured, the position of something may 'drift' during drawing).\n  function scrollPosIntoView(cm, pos, end, margin) {\n    if (margin == null) { margin = 0; }\n    var rect;\n    if (!cm.options.lineWrapping && pos == end) {\n      // Set pos and end to the cursor positions around the character pos sticks to\n      // If pos.sticky == \"before\", that is around pos.ch - 1, otherwise around pos.ch\n      // If pos == Pos(_, 0, \"before\"), pos and end are unchanged\n      pos = pos.ch ? Pos(pos.line, pos.sticky == \"before\" ? pos.ch - 1 : pos.ch, \"after\") : pos;\n      end = pos.sticky == \"before\" ? Pos(pos.line, pos.ch + 1, \"before\") : pos;\n    }\n    for (var limit = 0; limit < 5; limit++) {\n      var changed = false;\n      var coords = cursorCoords(cm, pos);\n      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);\n      rect = {left: Math.min(coords.left, endCoords.left),\n              top: Math.min(coords.top, endCoords.top) - margin,\n              right: Math.max(coords.left, endCoords.left),\n              bottom: Math.max(coords.bottom, endCoords.bottom) + margin};\n      var scrollPos = calculateScrollPos(cm, rect);\n      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;\n      if (scrollPos.scrollTop != null) {\n        updateScrollTop(cm, scrollPos.scrollTop);\n        if (Math.abs(cm.doc.scrollTop - startTop) > 1) { changed = true; }\n      }\n      if (scrollPos.scrollLeft != null) {\n        setScrollLeft(cm, scrollPos.scrollLeft);\n        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) { changed = true; }\n      }\n      if (!changed) { break }\n    }\n    return rect\n  }\n\n  // Scroll a given set of coordinates into view (immediately).\n  function scrollIntoView(cm, rect) {\n    var scrollPos = calculateScrollPos(cm, rect);\n    if (scrollPos.scrollTop != null) { updateScrollTop(cm, scrollPos.scrollTop); }\n    if (scrollPos.scrollLeft != null) { setScrollLeft(cm, scrollPos.scrollLeft); }\n  }\n\n  // Calculate a new scroll position needed to scroll the given\n  // rectangle into view. Returns an object with scrollTop and\n  // scrollLeft properties. When these are undefined, the\n  // vertical/horizontal position does not need to be adjusted.\n  function calculateScrollPos(cm, rect) {\n    var display = cm.display, snapMargin = textHeight(cm.display);\n    if (rect.top < 0) { rect.top = 0; }\n    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;\n    var screen = displayHeight(cm), result = {};\n    if (rect.bottom - rect.top > screen) { rect.bottom = rect.top + screen; }\n    var docBottom = cm.doc.height + paddingVert(display);\n    var atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin;\n    if (rect.top < screentop) {\n      result.scrollTop = atTop ? 0 : rect.top;\n    } else if (rect.bottom > screentop + screen) {\n      var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen);\n      if (newTop != screentop) { result.scrollTop = newTop; }\n    }\n\n    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;\n    var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);\n    var tooWide = rect.right - rect.left > screenw;\n    if (tooWide) { rect.right = rect.left + screenw; }\n    if (rect.left < 10)\n      { result.scrollLeft = 0; }\n    else if (rect.left < screenleft)\n      { result.scrollLeft = Math.max(0, rect.left - (tooWide ? 0 : 10)); }\n    else if (rect.right > screenw + screenleft - 3)\n      { result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw; }\n    return result\n  }\n\n  // Store a relative adjustment to the scroll position in the current\n  // operation (to be applied when the operation finishes).\n  function addToScrollTop(cm, top) {\n    if (top == null) { return }\n    resolveScrollToPos(cm);\n    cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;\n  }\n\n  // Make sure that at the end of the operation the current cursor is\n  // shown.\n  function ensureCursorVisible(cm) {\n    resolveScrollToPos(cm);\n    var cur = cm.getCursor();\n    cm.curOp.scrollToPos = {from: cur, to: cur, margin: cm.options.cursorScrollMargin};\n  }\n\n  function scrollToCoords(cm, x, y) {\n    if (x != null || y != null) { resolveScrollToPos(cm); }\n    if (x != null) { cm.curOp.scrollLeft = x; }\n    if (y != null) { cm.curOp.scrollTop = y; }\n  }\n\n  function scrollToRange(cm, range$$1) {\n    resolveScrollToPos(cm);\n    cm.curOp.scrollToPos = range$$1;\n  }\n\n  // When an operation has its scrollToPos property set, and another\n  // scroll action is applied before the end of the operation, this\n  // 'simulates' scrolling that position into view in a cheap way, so\n  // that the effect of intermediate scroll commands is not ignored.\n  function resolveScrollToPos(cm) {\n    var range$$1 = cm.curOp.scrollToPos;\n    if (range$$1) {\n      cm.curOp.scrollToPos = null;\n      var from = estimateCoords(cm, range$$1.from), to = estimateCoords(cm, range$$1.to);\n      scrollToCoordsRange(cm, from, to, range$$1.margin);\n    }\n  }\n\n  function scrollToCoordsRange(cm, from, to, margin) {\n    var sPos = calculateScrollPos(cm, {\n      left: Math.min(from.left, to.left),\n      top: Math.min(from.top, to.top) - margin,\n      right: Math.max(from.right, to.right),\n      bottom: Math.max(from.bottom, to.bottom) + margin\n    });\n    scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);\n  }\n\n  // Sync the scrollable area and scrollbars, ensure the viewport\n  // covers the visible area.\n  function updateScrollTop(cm, val) {\n    if (Math.abs(cm.doc.scrollTop - val) < 2) { return }\n    if (!gecko) { updateDisplaySimple(cm, {top: val}); }\n    setScrollTop(cm, val, true);\n    if (gecko) { updateDisplaySimple(cm); }\n    startWorker(cm, 100);\n  }\n\n  function setScrollTop(cm, val, forceScroll) {\n    val = Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val);\n    if (cm.display.scroller.scrollTop == val && !forceScroll) { return }\n    cm.doc.scrollTop = val;\n    cm.display.scrollbars.setScrollTop(val);\n    if (cm.display.scroller.scrollTop != val) { cm.display.scroller.scrollTop = val; }\n  }\n\n  // Sync scroller and scrollbar, ensure the gutter elements are\n  // aligned.\n  function setScrollLeft(cm, val, isScroller, forceScroll) {\n    val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);\n    if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) { return }\n    cm.doc.scrollLeft = val;\n    alignHorizontally(cm);\n    if (cm.display.scroller.scrollLeft != val) { cm.display.scroller.scrollLeft = val; }\n    cm.display.scrollbars.setScrollLeft(val);\n  }\n\n  // SCROLLBARS\n\n  // Prepare DOM reads needed to update the scrollbars. Done in one\n  // shot to minimize update/measure roundtrips.\n  function measureForScrollbars(cm) {\n    var d = cm.display, gutterW = d.gutters.offsetWidth;\n    var docH = Math.round(cm.doc.height + paddingVert(cm.display));\n    return {\n      clientHeight: d.scroller.clientHeight,\n      viewHeight: d.wrapper.clientHeight,\n      scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,\n      viewWidth: d.wrapper.clientWidth,\n      barLeft: cm.options.fixedGutter ? gutterW : 0,\n      docHeight: docH,\n      scrollHeight: docH + scrollGap(cm) + d.barHeight,\n      nativeBarWidth: d.nativeBarWidth,\n      gutterWidth: gutterW\n    }\n  }\n\n  var NativeScrollbars = function(place, scroll, cm) {\n    this.cm = cm;\n    var vert = this.vert = elt(\"div\", [elt(\"div\", null, null, \"min-width: 1px\")], \"CodeMirror-vscrollbar\");\n    var horiz = this.horiz = elt(\"div\", [elt(\"div\", null, null, \"height: 100%; min-height: 1px\")], \"CodeMirror-hscrollbar\");\n    vert.tabIndex = horiz.tabIndex = -1;\n    place(vert); place(horiz);\n\n    on(vert, \"scroll\", function () {\n      if (vert.clientHeight) { scroll(vert.scrollTop, \"vertical\"); }\n    });\n    on(horiz, \"scroll\", function () {\n      if (horiz.clientWidth) { scroll(horiz.scrollLeft, \"horizontal\"); }\n    });\n\n    this.checkedZeroWidth = false;\n    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).\n    if (ie && ie_version < 8) { this.horiz.style.minHeight = this.vert.style.minWidth = \"18px\"; }\n  };\n\n  NativeScrollbars.prototype.update = function (measure) {\n    var needsH = measure.scrollWidth > measure.clientWidth + 1;\n    var needsV = measure.scrollHeight > measure.clientHeight + 1;\n    var sWidth = measure.nativeBarWidth;\n\n    if (needsV) {\n      this.vert.style.display = \"block\";\n      this.vert.style.bottom = needsH ? sWidth + \"px\" : \"0\";\n      var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);\n      // A bug in IE8 can cause this value to be negative, so guard it.\n      this.vert.firstChild.style.height =\n        Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + \"px\";\n    } else {\n      this.vert.style.display = \"\";\n      this.vert.firstChild.style.height = \"0\";\n    }\n\n    if (needsH) {\n      this.horiz.style.display = \"block\";\n      this.horiz.style.right = needsV ? sWidth + \"px\" : \"0\";\n      this.horiz.style.left = measure.barLeft + \"px\";\n      var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);\n      this.horiz.firstChild.style.width =\n        Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + \"px\";\n    } else {\n      this.horiz.style.display = \"\";\n      this.horiz.firstChild.style.width = \"0\";\n    }\n\n    if (!this.checkedZeroWidth && measure.clientHeight > 0) {\n      if (sWidth == 0) { this.zeroWidthHack(); }\n      this.checkedZeroWidth = true;\n    }\n\n    return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0}\n  };\n\n  NativeScrollbars.prototype.setScrollLeft = function (pos) {\n    if (this.horiz.scrollLeft != pos) { this.horiz.scrollLeft = pos; }\n    if (this.disableHoriz) { this.enableZeroWidthBar(this.horiz, this.disableHoriz, \"horiz\"); }\n  };\n\n  NativeScrollbars.prototype.setScrollTop = function (pos) {\n    if (this.vert.scrollTop != pos) { this.vert.scrollTop = pos; }\n    if (this.disableVert) { this.enableZeroWidthBar(this.vert, this.disableVert, \"vert\"); }\n  };\n\n  NativeScrollbars.prototype.zeroWidthHack = function () {\n    var w = mac && !mac_geMountainLion ? \"12px\" : \"18px\";\n    this.horiz.style.height = this.vert.style.width = w;\n    this.horiz.style.pointerEvents = this.vert.style.pointerEvents = \"none\";\n    this.disableHoriz = new Delayed;\n    this.disableVert = new Delayed;\n  };\n\n  NativeScrollbars.prototype.enableZeroWidthBar = function (bar, delay, type) {\n    bar.style.pointerEvents = \"auto\";\n    function maybeDisable() {\n      // To find out whether the scrollbar is still visible, we\n      // check whether the element under the pixel in the bottom\n      // right corner of the scrollbar box is the scrollbar box\n      // itself (when the bar is still visible) or its filler child\n      // (when the bar is hidden). If it is still visible, we keep\n      // it enabled, if it's hidden, we disable pointer events.\n      var box = bar.getBoundingClientRect();\n      var elt$$1 = type == \"vert\" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2)\n          : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);\n      if (elt$$1 != bar) { bar.style.pointerEvents = \"none\"; }\n      else { delay.set(1000, maybeDisable); }\n    }\n    delay.set(1000, maybeDisable);\n  };\n\n  NativeScrollbars.prototype.clear = function () {\n    var parent = this.horiz.parentNode;\n    parent.removeChild(this.horiz);\n    parent.removeChild(this.vert);\n  };\n\n  var NullScrollbars = function () {};\n\n  NullScrollbars.prototype.update = function () { return {bottom: 0, right: 0} };\n  NullScrollbars.prototype.setScrollLeft = function () {};\n  NullScrollbars.prototype.setScrollTop = function () {};\n  NullScrollbars.prototype.clear = function () {};\n\n  function updateScrollbars(cm, measure) {\n    if (!measure) { measure = measureForScrollbars(cm); }\n    var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;\n    updateScrollbarsInner(cm, measure);\n    for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {\n      if (startWidth != cm.display.barWidth && cm.options.lineWrapping)\n        { updateHeightsInViewport(cm); }\n      updateScrollbarsInner(cm, measureForScrollbars(cm));\n      startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;\n    }\n  }\n\n  // Re-synchronize the fake scrollbars with the actual size of the\n  // content.\n  function updateScrollbarsInner(cm, measure) {\n    var d = cm.display;\n    var sizes = d.scrollbars.update(measure);\n\n    d.sizer.style.paddingRight = (d.barWidth = sizes.right) + \"px\";\n    d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + \"px\";\n    d.heightForcer.style.borderBottom = sizes.bottom + \"px solid transparent\";\n\n    if (sizes.right && sizes.bottom) {\n      d.scrollbarFiller.style.display = \"block\";\n      d.scrollbarFiller.style.height = sizes.bottom + \"px\";\n      d.scrollbarFiller.style.width = sizes.right + \"px\";\n    } else { d.scrollbarFiller.style.display = \"\"; }\n    if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {\n      d.gutterFiller.style.display = \"block\";\n      d.gutterFiller.style.height = sizes.bottom + \"px\";\n      d.gutterFiller.style.width = measure.gutterWidth + \"px\";\n    } else { d.gutterFiller.style.display = \"\"; }\n  }\n\n  var scrollbarModel = {\"native\": NativeScrollbars, \"null\": NullScrollbars};\n\n  function initScrollbars(cm) {\n    if (cm.display.scrollbars) {\n      cm.display.scrollbars.clear();\n      if (cm.display.scrollbars.addClass)\n        { rmClass(cm.display.wrapper, cm.display.scrollbars.addClass); }\n    }\n\n    cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {\n      cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);\n      // Prevent clicks in the scrollbars from killing focus\n      on(node, \"mousedown\", function () {\n        if (cm.state.focused) { setTimeout(function () { return cm.display.input.focus(); }, 0); }\n      });\n      node.setAttribute(\"cm-not-content\", \"true\");\n    }, function (pos, axis) {\n      if (axis == \"horizontal\") { setScrollLeft(cm, pos); }\n      else { updateScrollTop(cm, pos); }\n    }, cm);\n    if (cm.display.scrollbars.addClass)\n      { addClass(cm.display.wrapper, cm.display.scrollbars.addClass); }\n  }\n\n  // Operations are used to wrap a series of changes to the editor\n  // state in such a way that each change won't have to update the\n  // cursor and display (which would be awkward, slow, and\n  // error-prone). Instead, display updates are batched and then all\n  // combined and executed at once.\n\n  var nextOpId = 0;\n  // Start a new operation.\n  function startOperation(cm) {\n    cm.curOp = {\n      cm: cm,\n      viewChanged: false,      // Flag that indicates that lines might need to be redrawn\n      startHeight: cm.doc.height, // Used to detect need to update scrollbar\n      forceUpdate: false,      // Used to force a redraw\n      updateInput: 0,       // Whether to reset the input textarea\n      typing: false,           // Whether this reset should be careful to leave existing text (for compositing)\n      changeObjs: null,        // Accumulated changes, for firing change events\n      cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on\n      cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already\n      selectionChanged: false, // Whether the selection needs to be redrawn\n      updateMaxLine: false,    // Set when the widest line needs to be determined anew\n      scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet\n      scrollToPos: null,       // Used to scroll to a specific position\n      focus: false,\n      id: ++nextOpId           // Unique ID\n    };\n    pushOperation(cm.curOp);\n  }\n\n  // Finish an operation, updating the display and signalling delayed events\n  function endOperation(cm) {\n    var op = cm.curOp;\n    if (op) { finishOperation(op, function (group) {\n      for (var i = 0; i < group.ops.length; i++)\n        { group.ops[i].cm.curOp = null; }\n      endOperations(group);\n    }); }\n  }\n\n  // The DOM updates done when an operation finishes are batched so\n  // that the minimum number of relayouts are required.\n  function endOperations(group) {\n    var ops = group.ops;\n    for (var i = 0; i < ops.length; i++) // Read DOM\n      { endOperation_R1(ops[i]); }\n    for (var i$1 = 0; i$1 < ops.length; i$1++) // Write DOM (maybe)\n      { endOperation_W1(ops[i$1]); }\n    for (var i$2 = 0; i$2 < ops.length; i$2++) // Read DOM\n      { endOperation_R2(ops[i$2]); }\n    for (var i$3 = 0; i$3 < ops.length; i$3++) // Write DOM (maybe)\n      { endOperation_W2(ops[i$3]); }\n    for (var i$4 = 0; i$4 < ops.length; i$4++) // Read DOM\n      { endOperation_finish(ops[i$4]); }\n  }\n\n  function endOperation_R1(op) {\n    var cm = op.cm, display = cm.display;\n    maybeClipScrollbars(cm);\n    if (op.updateMaxLine) { findMaxLine(cm); }\n\n    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||\n      op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||\n                         op.scrollToPos.to.line >= display.viewTo) ||\n      display.maxLineChanged && cm.options.lineWrapping;\n    op.update = op.mustUpdate &&\n      new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);\n  }\n\n  function endOperation_W1(op) {\n    op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);\n  }\n\n  function endOperation_R2(op) {\n    var cm = op.cm, display = cm.display;\n    if (op.updatedDisplay) { updateHeightsInViewport(cm); }\n\n    op.barMeasure = measureForScrollbars(cm);\n\n    // If the max line changed since it was last measured, measure it,\n    // and ensure the document's width matches it.\n    // updateDisplay_W2 will use these properties to do the actual resizing\n    if (display.maxLineChanged && !cm.options.lineWrapping) {\n      op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;\n      cm.display.sizerWidth = op.adjustWidthTo;\n      op.barMeasure.scrollWidth =\n        Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);\n      op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));\n    }\n\n    if (op.updatedDisplay || op.selectionChanged)\n      { op.preparedSelection = display.input.prepareSelection(); }\n  }\n\n  function endOperation_W2(op) {\n    var cm = op.cm;\n\n    if (op.adjustWidthTo != null) {\n      cm.display.sizer.style.minWidth = op.adjustWidthTo + \"px\";\n      if (op.maxScrollLeft < cm.doc.scrollLeft)\n        { setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true); }\n      cm.display.maxLineChanged = false;\n    }\n\n    var takeFocus = op.focus && op.focus == activeElt();\n    if (op.preparedSelection)\n      { cm.display.input.showSelection(op.preparedSelection, takeFocus); }\n    if (op.updatedDisplay || op.startHeight != cm.doc.height)\n      { updateScrollbars(cm, op.barMeasure); }\n    if (op.updatedDisplay)\n      { setDocumentHeight(cm, op.barMeasure); }\n\n    if (op.selectionChanged) { restartBlink(cm); }\n\n    if (cm.state.focused && op.updateInput)\n      { cm.display.input.reset(op.typing); }\n    if (takeFocus) { ensureFocus(op.cm); }\n  }\n\n  function endOperation_finish(op) {\n    var cm = op.cm, display = cm.display, doc = cm.doc;\n\n    if (op.updatedDisplay) { postUpdateDisplay(cm, op.update); }\n\n    // Abort mouse wheel delta measurement, when scrolling explicitly\n    if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))\n      { display.wheelStartX = display.wheelStartY = null; }\n\n    // Propagate the scroll position to the actual DOM scroller\n    if (op.scrollTop != null) { setScrollTop(cm, op.scrollTop, op.forceScroll); }\n\n    if (op.scrollLeft != null) { setScrollLeft(cm, op.scrollLeft, true, true); }\n    // If we need to scroll a specific position into view, do so.\n    if (op.scrollToPos) {\n      var rect = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),\n                                   clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);\n      maybeScrollWindow(cm, rect);\n    }\n\n    // Fire events for markers that are hidden/unidden by editing or\n    // undoing\n    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;\n    if (hidden) { for (var i = 0; i < hidden.length; ++i)\n      { if (!hidden[i].lines.length) { signal(hidden[i], \"hide\"); } } }\n    if (unhidden) { for (var i$1 = 0; i$1 < unhidden.length; ++i$1)\n      { if (unhidden[i$1].lines.length) { signal(unhidden[i$1], \"unhide\"); } } }\n\n    if (display.wrapper.offsetHeight)\n      { doc.scrollTop = cm.display.scroller.scrollTop; }\n\n    // Fire change events, and delayed event handlers\n    if (op.changeObjs)\n      { signal(cm, \"changes\", cm, op.changeObjs); }\n    if (op.update)\n      { op.update.finish(); }\n  }\n\n  // Run the given function in an operation\n  function runInOp(cm, f) {\n    if (cm.curOp) { return f() }\n    startOperation(cm);\n    try { return f() }\n    finally { endOperation(cm); }\n  }\n  // Wraps a function in an operation. Returns the wrapped function.\n  function operation(cm, f) {\n    return function() {\n      if (cm.curOp) { return f.apply(cm, arguments) }\n      startOperation(cm);\n      try { return f.apply(cm, arguments) }\n      finally { endOperation(cm); }\n    }\n  }\n  // Used to add methods to editor and doc instances, wrapping them in\n  // operations.\n  function methodOp(f) {\n    return function() {\n      if (this.curOp) { return f.apply(this, arguments) }\n      startOperation(this);\n      try { return f.apply(this, arguments) }\n      finally { endOperation(this); }\n    }\n  }\n  function docMethodOp(f) {\n    return function() {\n      var cm = this.cm;\n      if (!cm || cm.curOp) { return f.apply(this, arguments) }\n      startOperation(cm);\n      try { return f.apply(this, arguments) }\n      finally { endOperation(cm); }\n    }\n  }\n\n  // Updates the display.view data structure for a given change to the\n  // document. From and to are in pre-change coordinates. Lendiff is\n  // the amount of lines added or subtracted by the change. This is\n  // used for changes that span multiple lines, or change the way\n  // lines are divided into visual lines. regLineChange (below)\n  // registers single-line changes.\n  function regChange(cm, from, to, lendiff) {\n    if (from == null) { from = cm.doc.first; }\n    if (to == null) { to = cm.doc.first + cm.doc.size; }\n    if (!lendiff) { lendiff = 0; }\n\n    var display = cm.display;\n    if (lendiff && to < display.viewTo &&\n        (display.updateLineNumbers == null || display.updateLineNumbers > from))\n      { display.updateLineNumbers = from; }\n\n    cm.curOp.viewChanged = true;\n\n    if (from >= display.viewTo) { // Change after\n      if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)\n        { resetView(cm); }\n    } else if (to <= display.viewFrom) { // Change before\n      if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {\n        resetView(cm);\n      } else {\n        display.viewFrom += lendiff;\n        display.viewTo += lendiff;\n      }\n    } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap\n      resetView(cm);\n    } else if (from <= display.viewFrom) { // Top overlap\n      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);\n      if (cut) {\n        display.view = display.view.slice(cut.index);\n        display.viewFrom = cut.lineN;\n        display.viewTo += lendiff;\n      } else {\n        resetView(cm);\n      }\n    } else if (to >= display.viewTo) { // Bottom overlap\n      var cut$1 = viewCuttingPoint(cm, from, from, -1);\n      if (cut$1) {\n        display.view = display.view.slice(0, cut$1.index);\n        display.viewTo = cut$1.lineN;\n      } else {\n        resetView(cm);\n      }\n    } else { // Gap in the middle\n      var cutTop = viewCuttingPoint(cm, from, from, -1);\n      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);\n      if (cutTop && cutBot) {\n        display.view = display.view.slice(0, cutTop.index)\n          .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))\n          .concat(display.view.slice(cutBot.index));\n        display.viewTo += lendiff;\n      } else {\n        resetView(cm);\n      }\n    }\n\n    var ext = display.externalMeasured;\n    if (ext) {\n      if (to < ext.lineN)\n        { ext.lineN += lendiff; }\n      else if (from < ext.lineN + ext.size)\n        { display.externalMeasured = null; }\n    }\n  }\n\n  // Register a change to a single line. Type must be one of \"text\",\n  // \"gutter\", \"class\", \"widget\"\n  function regLineChange(cm, line, type) {\n    cm.curOp.viewChanged = true;\n    var display = cm.display, ext = cm.display.externalMeasured;\n    if (ext && line >= ext.lineN && line < ext.lineN + ext.size)\n      { display.externalMeasured = null; }\n\n    if (line < display.viewFrom || line >= display.viewTo) { return }\n    var lineView = display.view[findViewIndex(cm, line)];\n    if (lineView.node == null) { return }\n    var arr = lineView.changes || (lineView.changes = []);\n    if (indexOf(arr, type) == -1) { arr.push(type); }\n  }\n\n  // Clear the view.\n  function resetView(cm) {\n    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;\n    cm.display.view = [];\n    cm.display.viewOffset = 0;\n  }\n\n  function viewCuttingPoint(cm, oldN, newN, dir) {\n    var index = findViewIndex(cm, oldN), diff, view = cm.display.view;\n    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)\n      { return {index: index, lineN: newN} }\n    var n = cm.display.viewFrom;\n    for (var i = 0; i < index; i++)\n      { n += view[i].size; }\n    if (n != oldN) {\n      if (dir > 0) {\n        if (index == view.length - 1) { return null }\n        diff = (n + view[index].size) - oldN;\n        index++;\n      } else {\n        diff = n - oldN;\n      }\n      oldN += diff; newN += diff;\n    }\n    while (visualLineNo(cm.doc, newN) != newN) {\n      if (index == (dir < 0 ? 0 : view.length - 1)) { return null }\n      newN += dir * view[index - (dir < 0 ? 1 : 0)].size;\n      index += dir;\n    }\n    return {index: index, lineN: newN}\n  }\n\n  // Force the view to cover a given range, adding empty view element\n  // or clipping off existing ones as needed.\n  function adjustView(cm, from, to) {\n    var display = cm.display, view = display.view;\n    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {\n      display.view = buildViewArray(cm, from, to);\n      display.viewFrom = from;\n    } else {\n      if (display.viewFrom > from)\n        { display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view); }\n      else if (display.viewFrom < from)\n        { display.view = display.view.slice(findViewIndex(cm, from)); }\n      display.viewFrom = from;\n      if (display.viewTo < to)\n        { display.view = display.view.concat(buildViewArray(cm, display.viewTo, to)); }\n      else if (display.viewTo > to)\n        { display.view = display.view.slice(0, findViewIndex(cm, to)); }\n    }\n    display.viewTo = to;\n  }\n\n  // Count the number of lines in the view whose DOM representation is\n  // out of date (or nonexistent).\n  function countDirtyView(cm) {\n    var view = cm.display.view, dirty = 0;\n    for (var i = 0; i < view.length; i++) {\n      var lineView = view[i];\n      if (!lineView.hidden && (!lineView.node || lineView.changes)) { ++dirty; }\n    }\n    return dirty\n  }\n\n  // HIGHLIGHT WORKER\n\n  function startWorker(cm, time) {\n    if (cm.doc.highlightFrontier < cm.display.viewTo)\n      { cm.state.highlight.set(time, bind(highlightWorker, cm)); }\n  }\n\n  function highlightWorker(cm) {\n    var doc = cm.doc;\n    if (doc.highlightFrontier >= cm.display.viewTo) { return }\n    var end = +new Date + cm.options.workTime;\n    var context = getContextBefore(cm, doc.highlightFrontier);\n    var changedLines = [];\n\n    doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {\n      if (context.line >= cm.display.viewFrom) { // Visible\n        var oldStyles = line.styles;\n        var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null;\n        var highlighted = highlightLine(cm, line, context, true);\n        if (resetState) { context.state = resetState; }\n        line.styles = highlighted.styles;\n        var oldCls = line.styleClasses, newCls = highlighted.classes;\n        if (newCls) { line.styleClasses = newCls; }\n        else if (oldCls) { line.styleClasses = null; }\n        var ischange = !oldStyles || oldStyles.length != line.styles.length ||\n          oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);\n        for (var i = 0; !ischange && i < oldStyles.length; ++i) { ischange = oldStyles[i] != line.styles[i]; }\n        if (ischange) { changedLines.push(context.line); }\n        line.stateAfter = context.save();\n        context.nextLine();\n      } else {\n        if (line.text.length <= cm.options.maxHighlightLength)\n          { processLine(cm, line.text, context); }\n        line.stateAfter = context.line % 5 == 0 ? context.save() : null;\n        context.nextLine();\n      }\n      if (+new Date > end) {\n        startWorker(cm, cm.options.workDelay);\n        return true\n      }\n    });\n    doc.highlightFrontier = context.line;\n    doc.modeFrontier = Math.max(doc.modeFrontier, context.line);\n    if (changedLines.length) { runInOp(cm, function () {\n      for (var i = 0; i < changedLines.length; i++)\n        { regLineChange(cm, changedLines[i], \"text\"); }\n    }); }\n  }\n\n  // DISPLAY DRAWING\n\n  var DisplayUpdate = function(cm, viewport, force) {\n    var display = cm.display;\n\n    this.viewport = viewport;\n    // Store some values that we'll need later (but don't want to force a relayout for)\n    this.visible = visibleLines(display, cm.doc, viewport);\n    this.editorIsHidden = !display.wrapper.offsetWidth;\n    this.wrapperHeight = display.wrapper.clientHeight;\n    this.wrapperWidth = display.wrapper.clientWidth;\n    this.oldDisplayWidth = displayWidth(cm);\n    this.force = force;\n    this.dims = getDimensions(cm);\n    this.events = [];\n  };\n\n  DisplayUpdate.prototype.signal = function (emitter, type) {\n    if (hasHandler(emitter, type))\n      { this.events.push(arguments); }\n  };\n  DisplayUpdate.prototype.finish = function () {\n      var this$1 = this;\n\n    for (var i = 0; i < this.events.length; i++)\n      { signal.apply(null, this$1.events[i]); }\n  };\n\n  function maybeClipScrollbars(cm) {\n    var display = cm.display;\n    if (!display.scrollbarsClipped && display.scroller.offsetWidth) {\n      display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;\n      display.heightForcer.style.height = scrollGap(cm) + \"px\";\n      display.sizer.style.marginBottom = -display.nativeBarWidth + \"px\";\n      display.sizer.style.borderRightWidth = scrollGap(cm) + \"px\";\n      display.scrollbarsClipped = true;\n    }\n  }\n\n  function selectionSnapshot(cm) {\n    if (cm.hasFocus()) { return null }\n    var active = activeElt();\n    if (!active || !contains(cm.display.lineDiv, active)) { return null }\n    var result = {activeElt: active};\n    if (window.getSelection) {\n      var sel = window.getSelection();\n      if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {\n        result.anchorNode = sel.anchorNode;\n        result.anchorOffset = sel.anchorOffset;\n        result.focusNode = sel.focusNode;\n        result.focusOffset = sel.focusOffset;\n      }\n    }\n    return result\n  }\n\n  function restoreSelection(snapshot) {\n    if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt()) { return }\n    snapshot.activeElt.focus();\n    if (snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {\n      var sel = window.getSelection(), range$$1 = document.createRange();\n      range$$1.setEnd(snapshot.anchorNode, snapshot.anchorOffset);\n      range$$1.collapse(false);\n      sel.removeAllRanges();\n      sel.addRange(range$$1);\n      sel.extend(snapshot.focusNode, snapshot.focusOffset);\n    }\n  }\n\n  // Does the actual updating of the line display. Bails out\n  // (returning false) when there is nothing to be done and forced is\n  // false.\n  function updateDisplayIfNeeded(cm, update) {\n    var display = cm.display, doc = cm.doc;\n\n    if (update.editorIsHidden) {\n      resetView(cm);\n      return false\n    }\n\n    // Bail out if the visible area is already rendered and nothing changed.\n    if (!update.force &&\n        update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&\n        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&\n        display.renderedView == display.view && countDirtyView(cm) == 0)\n      { return false }\n\n    if (maybeUpdateLineNumberWidth(cm)) {\n      resetView(cm);\n      update.dims = getDimensions(cm);\n    }\n\n    // Compute a suitable new viewport (from & to)\n    var end = doc.first + doc.size;\n    var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);\n    var to = Math.min(end, update.visible.to + cm.options.viewportMargin);\n    if (display.viewFrom < from && from - display.viewFrom < 20) { from = Math.max(doc.first, display.viewFrom); }\n    if (display.viewTo > to && display.viewTo - to < 20) { to = Math.min(end, display.viewTo); }\n    if (sawCollapsedSpans) {\n      from = visualLineNo(cm.doc, from);\n      to = visualLineEndNo(cm.doc, to);\n    }\n\n    var different = from != display.viewFrom || to != display.viewTo ||\n      display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;\n    adjustView(cm, from, to);\n\n    display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));\n    // Position the mover div to align with the current scroll position\n    cm.display.mover.style.top = display.viewOffset + \"px\";\n\n    var toUpdate = countDirtyView(cm);\n    if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&\n        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))\n      { return false }\n\n    // For big changes, we hide the enclosing element during the\n    // update, since that speeds up the operations on most browsers.\n    var selSnapshot = selectionSnapshot(cm);\n    if (toUpdate > 4) { display.lineDiv.style.display = \"none\"; }\n    patchDisplay(cm, display.updateLineNumbers, update.dims);\n    if (toUpdate > 4) { display.lineDiv.style.display = \"\"; }\n    display.renderedView = display.view;\n    // There might have been a widget with a focused element that got\n    // hidden or updated, if so re-focus it.\n    restoreSelection(selSnapshot);\n\n    // Prevent selection and cursors from interfering with the scroll\n    // width and height.\n    removeChildren(display.cursorDiv);\n    removeChildren(display.selectionDiv);\n    display.gutters.style.height = display.sizer.style.minHeight = 0;\n\n    if (different) {\n      display.lastWrapHeight = update.wrapperHeight;\n      display.lastWrapWidth = update.wrapperWidth;\n      startWorker(cm, 400);\n    }\n\n    display.updateLineNumbers = null;\n\n    return true\n  }\n\n  function postUpdateDisplay(cm, update) {\n    var viewport = update.viewport;\n\n    for (var first = true;; first = false) {\n      if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {\n        // Clip forced viewport to actual scrollable area.\n        if (viewport && viewport.top != null)\n          { viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)}; }\n        // Updated line heights might result in the drawn area not\n        // actually covering the viewport. Keep looping until it does.\n        update.visible = visibleLines(cm.display, cm.doc, viewport);\n        if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)\n          { break }\n      }\n      if (!updateDisplayIfNeeded(cm, update)) { break }\n      updateHeightsInViewport(cm);\n      var barMeasure = measureForScrollbars(cm);\n      updateSelection(cm);\n      updateScrollbars(cm, barMeasure);\n      setDocumentHeight(cm, barMeasure);\n      update.force = false;\n    }\n\n    update.signal(cm, \"update\", cm);\n    if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {\n      update.signal(cm, \"viewportChange\", cm, cm.display.viewFrom, cm.display.viewTo);\n      cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;\n    }\n  }\n\n  function updateDisplaySimple(cm, viewport) {\n    var update = new DisplayUpdate(cm, viewport);\n    if (updateDisplayIfNeeded(cm, update)) {\n      updateHeightsInViewport(cm);\n      postUpdateDisplay(cm, update);\n      var barMeasure = measureForScrollbars(cm);\n      updateSelection(cm);\n      updateScrollbars(cm, barMeasure);\n      setDocumentHeight(cm, barMeasure);\n      update.finish();\n    }\n  }\n\n  // Sync the actual display DOM structure with display.view, removing\n  // nodes for lines that are no longer in view, and creating the ones\n  // that are not there yet, and updating the ones that are out of\n  // date.\n  function patchDisplay(cm, updateNumbersFrom, dims) {\n    var display = cm.display, lineNumbers = cm.options.lineNumbers;\n    var container = display.lineDiv, cur = container.firstChild;\n\n    function rm(node) {\n      var next = node.nextSibling;\n      // Works around a throw-scroll bug in OS X Webkit\n      if (webkit && mac && cm.display.currentWheelTarget == node)\n        { node.style.display = \"none\"; }\n      else\n        { node.parentNode.removeChild(node); }\n      return next\n    }\n\n    var view = display.view, lineN = display.viewFrom;\n    // Loop over the elements in the view, syncing cur (the DOM nodes\n    // in display.lineDiv) with the view as we go.\n    for (var i = 0; i < view.length; i++) {\n      var lineView = view[i];\n      if (lineView.hidden) ; else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet\n        var node = buildLineElement(cm, lineView, lineN, dims);\n        container.insertBefore(node, cur);\n      } else { // Already drawn\n        while (cur != lineView.node) { cur = rm(cur); }\n        var updateNumber = lineNumbers && updateNumbersFrom != null &&\n          updateNumbersFrom <= lineN && lineView.lineNumber;\n        if (lineView.changes) {\n          if (indexOf(lineView.changes, \"gutter\") > -1) { updateNumber = false; }\n          updateLineForChanges(cm, lineView, lineN, dims);\n        }\n        if (updateNumber) {\n          removeChildren(lineView.lineNumber);\n          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));\n        }\n        cur = lineView.node.nextSibling;\n      }\n      lineN += lineView.size;\n    }\n    while (cur) { cur = rm(cur); }\n  }\n\n  function updateGutterSpace(cm) {\n    var width = cm.display.gutters.offsetWidth;\n    cm.display.sizer.style.marginLeft = width + \"px\";\n  }\n\n  function setDocumentHeight(cm, measure) {\n    cm.display.sizer.style.minHeight = measure.docHeight + \"px\";\n    cm.display.heightForcer.style.top = measure.docHeight + \"px\";\n    cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + \"px\";\n  }\n\n  // Rebuild the gutter elements, ensure the margin to the left of the\n  // code matches their width.\n  function updateGutters(cm) {\n    var gutters = cm.display.gutters, specs = cm.options.gutters;\n    removeChildren(gutters);\n    var i = 0;\n    for (; i < specs.length; ++i) {\n      var gutterClass = specs[i];\n      var gElt = gutters.appendChild(elt(\"div\", null, \"CodeMirror-gutter \" + gutterClass));\n      if (gutterClass == \"CodeMirror-linenumbers\") {\n        cm.display.lineGutter = gElt;\n        gElt.style.width = (cm.display.lineNumWidth || 1) + \"px\";\n      }\n    }\n    gutters.style.display = i ? \"\" : \"none\";\n    updateGutterSpace(cm);\n  }\n\n  // Make sure the gutters options contains the element\n  // \"CodeMirror-linenumbers\" when the lineNumbers option is true.\n  function setGuttersForLineNumbers(options) {\n    var found = indexOf(options.gutters, \"CodeMirror-linenumbers\");\n    if (found == -1 && options.lineNumbers) {\n      options.gutters = options.gutters.concat([\"CodeMirror-linenumbers\"]);\n    } else if (found > -1 && !options.lineNumbers) {\n      options.gutters = options.gutters.slice(0);\n      options.gutters.splice(found, 1);\n    }\n  }\n\n  // Since the delta values reported on mouse wheel events are\n  // unstandardized between browsers and even browser versions, and\n  // generally horribly unpredictable, this code starts by measuring\n  // the scroll effect that the first few mouse wheel events have,\n  // and, from that, detects the way it can convert deltas to pixel\n  // offsets afterwards.\n  //\n  // The reason we want to know the amount a wheel event will scroll\n  // is that it gives us a chance to update the display before the\n  // actual scrolling happens, reducing flickering.\n\n  var wheelSamples = 0, wheelPixelsPerUnit = null;\n  // Fill in a browser-detected starting value on browsers where we\n  // know one. These don't have to be accurate -- the result of them\n  // being wrong would just be a slight flicker on the first wheel\n  // scroll (if it is large enough).\n  if (ie) { wheelPixelsPerUnit = -.53; }\n  else if (gecko) { wheelPixelsPerUnit = 15; }\n  else if (chrome) { wheelPixelsPerUnit = -.7; }\n  else if (safari) { wheelPixelsPerUnit = -1/3; }\n\n  function wheelEventDelta(e) {\n    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;\n    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) { dx = e.detail; }\n    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) { dy = e.detail; }\n    else if (dy == null) { dy = e.wheelDelta; }\n    return {x: dx, y: dy}\n  }\n  function wheelEventPixels(e) {\n    var delta = wheelEventDelta(e);\n    delta.x *= wheelPixelsPerUnit;\n    delta.y *= wheelPixelsPerUnit;\n    return delta\n  }\n\n  function onScrollWheel(cm, e) {\n    var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;\n\n    var display = cm.display, scroll = display.scroller;\n    // Quit if there's nothing to scroll here\n    var canScrollX = scroll.scrollWidth > scroll.clientWidth;\n    var canScrollY = scroll.scrollHeight > scroll.clientHeight;\n    if (!(dx && canScrollX || dy && canScrollY)) { return }\n\n    // Webkit browsers on OS X abort momentum scrolls when the target\n    // of the scroll event is removed from the scrollable element.\n    // This hack (see related code in patchDisplay) makes sure the\n    // element is kept around.\n    if (dy && mac && webkit) {\n      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {\n        for (var i = 0; i < view.length; i++) {\n          if (view[i].node == cur) {\n            cm.display.currentWheelTarget = cur;\n            break outer\n          }\n        }\n      }\n    }\n\n    // On some browsers, horizontal scrolling will cause redraws to\n    // happen before the gutter has been realigned, causing it to\n    // wriggle around in a most unseemly way. When we have an\n    // estimated pixels/delta value, we just handle horizontal\n    // scrolling entirely here. It'll be slightly off from native, but\n    // better than glitching out.\n    if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {\n      if (dy && canScrollY)\n        { updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * wheelPixelsPerUnit)); }\n      setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * wheelPixelsPerUnit));\n      // Only prevent default scrolling if vertical scrolling is\n      // actually possible. Otherwise, it causes vertical scroll\n      // jitter on OSX trackpads when deltaX is small and deltaY\n      // is large (issue #3579)\n      if (!dy || (dy && canScrollY))\n        { e_preventDefault(e); }\n      display.wheelStartX = null; // Abort measurement, if in progress\n      return\n    }\n\n    // 'Project' the visible viewport to cover the area that is being\n    // scrolled into view (if we know enough to estimate it).\n    if (dy && wheelPixelsPerUnit != null) {\n      var pixels = dy * wheelPixelsPerUnit;\n      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;\n      if (pixels < 0) { top = Math.max(0, top + pixels - 50); }\n      else { bot = Math.min(cm.doc.height, bot + pixels + 50); }\n      updateDisplaySimple(cm, {top: top, bottom: bot});\n    }\n\n    if (wheelSamples < 20) {\n      if (display.wheelStartX == null) {\n        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;\n        display.wheelDX = dx; display.wheelDY = dy;\n        setTimeout(function () {\n          if (display.wheelStartX == null) { return }\n          var movedX = scroll.scrollLeft - display.wheelStartX;\n          var movedY = scroll.scrollTop - display.wheelStartY;\n          var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||\n            (movedX && display.wheelDX && movedX / display.wheelDX);\n          display.wheelStartX = display.wheelStartY = null;\n          if (!sample) { return }\n          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);\n          ++wheelSamples;\n        }, 200);\n      } else {\n        display.wheelDX += dx; display.wheelDY += dy;\n      }\n    }\n  }\n\n  // Selection objects are immutable. A new one is created every time\n  // the selection changes. A selection is one or more non-overlapping\n  // (and non-touching) ranges, sorted, and an integer that indicates\n  // which one is the primary selection (the one that's scrolled into\n  // view, that getCursor returns, etc).\n  var Selection = function(ranges, primIndex) {\n    this.ranges = ranges;\n    this.primIndex = primIndex;\n  };\n\n  Selection.prototype.primary = function () { return this.ranges[this.primIndex] };\n\n  Selection.prototype.equals = function (other) {\n      var this$1 = this;\n\n    if (other == this) { return true }\n    if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) { return false }\n    for (var i = 0; i < this.ranges.length; i++) {\n      var here = this$1.ranges[i], there = other.ranges[i];\n      if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) { return false }\n    }\n    return true\n  };\n\n  Selection.prototype.deepCopy = function () {\n      var this$1 = this;\n\n    var out = [];\n    for (var i = 0; i < this.ranges.length; i++)\n      { out[i] = new Range(copyPos(this$1.ranges[i].anchor), copyPos(this$1.ranges[i].head)); }\n    return new Selection(out, this.primIndex)\n  };\n\n  Selection.prototype.somethingSelected = function () {\n      var this$1 = this;\n\n    for (var i = 0; i < this.ranges.length; i++)\n      { if (!this$1.ranges[i].empty()) { return true } }\n    return false\n  };\n\n  Selection.prototype.contains = function (pos, end) {\n      var this$1 = this;\n\n    if (!end) { end = pos; }\n    for (var i = 0; i < this.ranges.length; i++) {\n      var range = this$1.ranges[i];\n      if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)\n        { return i }\n    }\n    return -1\n  };\n\n  var Range = function(anchor, head) {\n    this.anchor = anchor; this.head = head;\n  };\n\n  Range.prototype.from = function () { return minPos(this.anchor, this.head) };\n  Range.prototype.to = function () { return maxPos(this.anchor, this.head) };\n  Range.prototype.empty = function () { return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch };\n\n  // Take an unsorted, potentially overlapping set of ranges, and\n  // build a selection out of it. 'Consumes' ranges array (modifying\n  // it).\n  function normalizeSelection(cm, ranges, primIndex) {\n    var mayTouch = cm && cm.options.selectionsMayTouch;\n    var prim = ranges[primIndex];\n    ranges.sort(function (a, b) { return cmp(a.from(), b.from()); });\n    primIndex = indexOf(ranges, prim);\n    for (var i = 1; i < ranges.length; i++) {\n      var cur = ranges[i], prev = ranges[i - 1];\n      var diff = cmp(prev.to(), cur.from());\n      if (mayTouch && !cur.empty() ? diff > 0 : diff >= 0) {\n        var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());\n        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;\n        if (i <= primIndex) { --primIndex; }\n        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));\n      }\n    }\n    return new Selection(ranges, primIndex)\n  }\n\n  function simpleSelection(anchor, head) {\n    return new Selection([new Range(anchor, head || anchor)], 0)\n  }\n\n  // Compute the position of the end of a change (its 'to' property\n  // refers to the pre-change end).\n  function changeEnd(change) {\n    if (!change.text) { return change.to }\n    return Pos(change.from.line + change.text.length - 1,\n               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0))\n  }\n\n  // Adjust a position to refer to the post-change position of the\n  // same text, or the end of the change if the change covers it.\n  function adjustForChange(pos, change) {\n    if (cmp(pos, change.from) < 0) { return pos }\n    if (cmp(pos, change.to) <= 0) { return changeEnd(change) }\n\n    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;\n    if (pos.line == change.to.line) { ch += changeEnd(change).ch - change.to.ch; }\n    return Pos(line, ch)\n  }\n\n  function computeSelAfterChange(doc, change) {\n    var out = [];\n    for (var i = 0; i < doc.sel.ranges.length; i++) {\n      var range = doc.sel.ranges[i];\n      out.push(new Range(adjustForChange(range.anchor, change),\n                         adjustForChange(range.head, change)));\n    }\n    return normalizeSelection(doc.cm, out, doc.sel.primIndex)\n  }\n\n  function offsetPos(pos, old, nw) {\n    if (pos.line == old.line)\n      { return Pos(nw.line, pos.ch - old.ch + nw.ch) }\n    else\n      { return Pos(nw.line + (pos.line - old.line), pos.ch) }\n  }\n\n  // Used by replaceSelections to allow moving the selection to the\n  // start or around the replaced test. Hint may be \"start\" or \"around\".\n  function computeReplacedSel(doc, changes, hint) {\n    var out = [];\n    var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;\n    for (var i = 0; i < changes.length; i++) {\n      var change = changes[i];\n      var from = offsetPos(change.from, oldPrev, newPrev);\n      var to = offsetPos(changeEnd(change), oldPrev, newPrev);\n      oldPrev = change.to;\n      newPrev = to;\n      if (hint == \"around\") {\n        var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;\n        out[i] = new Range(inv ? to : from, inv ? from : to);\n      } else {\n        out[i] = new Range(from, from);\n      }\n    }\n    return new Selection(out, doc.sel.primIndex)\n  }\n\n  // Used to get the editor into a consistent state again when options change.\n\n  function loadMode(cm) {\n    cm.doc.mode = getMode(cm.options, cm.doc.modeOption);\n    resetModeState(cm);\n  }\n\n  function resetModeState(cm) {\n    cm.doc.iter(function (line) {\n      if (line.stateAfter) { line.stateAfter = null; }\n      if (line.styles) { line.styles = null; }\n    });\n    cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;\n    startWorker(cm, 100);\n    cm.state.modeGen++;\n    if (cm.curOp) { regChange(cm); }\n  }\n\n  // DOCUMENT DATA STRUCTURE\n\n  // By default, updates that start and end at the beginning of a line\n  // are treated specially, in order to make the association of line\n  // widgets and marker elements with the text behave more intuitive.\n  function isWholeLineUpdate(doc, change) {\n    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == \"\" &&\n      (!doc.cm || doc.cm.options.wholeLineUpdateBefore)\n  }\n\n  // Perform a change on the document data structure.\n  function updateDoc(doc, change, markedSpans, estimateHeight$$1) {\n    function spansFor(n) {return markedSpans ? markedSpans[n] : null}\n    function update(line, text, spans) {\n      updateLine(line, text, spans, estimateHeight$$1);\n      signalLater(line, \"change\", line, change);\n    }\n    function linesFor(start, end) {\n      var result = [];\n      for (var i = start; i < end; ++i)\n        { result.push(new Line(text[i], spansFor(i), estimateHeight$$1)); }\n      return result\n    }\n\n    var from = change.from, to = change.to, text = change.text;\n    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);\n    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;\n\n    // Adjust the line structure\n    if (change.full) {\n      doc.insert(0, linesFor(0, text.length));\n      doc.remove(text.length, doc.size - text.length);\n    } else if (isWholeLineUpdate(doc, change)) {\n      // This is a whole-line replace. Treated specially to make\n      // sure line objects move the way they are supposed to.\n      var added = linesFor(0, text.length - 1);\n      update(lastLine, lastLine.text, lastSpans);\n      if (nlines) { doc.remove(from.line, nlines); }\n      if (added.length) { doc.insert(from.line, added); }\n    } else if (firstLine == lastLine) {\n      if (text.length == 1) {\n        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);\n      } else {\n        var added$1 = linesFor(1, text.length - 1);\n        added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight$$1));\n        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n        doc.insert(from.line + 1, added$1);\n      }\n    } else if (text.length == 1) {\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));\n      doc.remove(from.line + 1, nlines);\n    } else {\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);\n      var added$2 = linesFor(1, text.length - 1);\n      if (nlines > 1) { doc.remove(from.line + 1, nlines - 1); }\n      doc.insert(from.line + 1, added$2);\n    }\n\n    signalLater(doc, \"change\", doc, change);\n  }\n\n  // Call f for all linked documents.\n  function linkedDocs(doc, f, sharedHistOnly) {\n    function propagate(doc, skip, sharedHist) {\n      if (doc.linked) { for (var i = 0; i < doc.linked.length; ++i) {\n        var rel = doc.linked[i];\n        if (rel.doc == skip) { continue }\n        var shared = sharedHist && rel.sharedHist;\n        if (sharedHistOnly && !shared) { continue }\n        f(rel.doc, shared);\n        propagate(rel.doc, doc, shared);\n      } }\n    }\n    propagate(doc, null, true);\n  }\n\n  // Attach a document to an editor.\n  function attachDoc(cm, doc) {\n    if (doc.cm) { throw new Error(\"This document is already in use.\") }\n    cm.doc = doc;\n    doc.cm = cm;\n    estimateLineHeights(cm);\n    loadMode(cm);\n    setDirectionClass(cm);\n    if (!cm.options.lineWrapping) { findMaxLine(cm); }\n    cm.options.mode = doc.modeOption;\n    regChange(cm);\n  }\n\n  function setDirectionClass(cm) {\n  (cm.doc.direction == \"rtl\" ? addClass : rmClass)(cm.display.lineDiv, \"CodeMirror-rtl\");\n  }\n\n  function directionChanged(cm) {\n    runInOp(cm, function () {\n      setDirectionClass(cm);\n      regChange(cm);\n    });\n  }\n\n  function History(startGen) {\n    // Arrays of change events and selections. Doing something adds an\n    // event to done and clears undo. Undoing moves events from done\n    // to undone, redoing moves them in the other direction.\n    this.done = []; this.undone = [];\n    this.undoDepth = Infinity;\n    // Used to track when changes can be merged into a single undo\n    // event\n    this.lastModTime = this.lastSelTime = 0;\n    this.lastOp = this.lastSelOp = null;\n    this.lastOrigin = this.lastSelOrigin = null;\n    // Used by the isClean() method\n    this.generation = this.maxGeneration = startGen || 1;\n  }\n\n  // Create a history change event from an updateDoc-style change\n  // object.\n  function historyChangeFromChange(doc, change) {\n    var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};\n    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);\n    linkedDocs(doc, function (doc) { return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1); }, true);\n    return histChange\n  }\n\n  // Pop all selection events off the end of a history array. Stop at\n  // a change event.\n  function clearSelectionEvents(array) {\n    while (array.length) {\n      var last = lst(array);\n      if (last.ranges) { array.pop(); }\n      else { break }\n    }\n  }\n\n  // Find the top change event in the history. Pop off selection\n  // events that are in the way.\n  function lastChangeEvent(hist, force) {\n    if (force) {\n      clearSelectionEvents(hist.done);\n      return lst(hist.done)\n    } else if (hist.done.length && !lst(hist.done).ranges) {\n      return lst(hist.done)\n    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {\n      hist.done.pop();\n      return lst(hist.done)\n    }\n  }\n\n  // Register a change in the history. Merges changes that are within\n  // a single operation, or are close together with an origin that\n  // allows merging (starting with \"+\") into a single event.\n  function addChangeToHistory(doc, change, selAfter, opId) {\n    var hist = doc.history;\n    hist.undone.length = 0;\n    var time = +new Date, cur;\n    var last;\n\n    if ((hist.lastOp == opId ||\n         hist.lastOrigin == change.origin && change.origin &&\n         ((change.origin.charAt(0) == \"+\" && hist.lastModTime > time - (doc.cm ? doc.cm.options.historyEventDelay : 500)) ||\n          change.origin.charAt(0) == \"*\")) &&\n        (cur = lastChangeEvent(hist, hist.lastOp == opId))) {\n      // Merge this change into the last event\n      last = lst(cur.changes);\n      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {\n        // Optimized case for simple insertion -- don't want to add\n        // new changesets for every character typed\n        last.to = changeEnd(change);\n      } else {\n        // Add new sub-event\n        cur.changes.push(historyChangeFromChange(doc, change));\n      }\n    } else {\n      // Can not be merged, start a new event.\n      var before = lst(hist.done);\n      if (!before || !before.ranges)\n        { pushSelectionToHistory(doc.sel, hist.done); }\n      cur = {changes: [historyChangeFromChange(doc, change)],\n             generation: hist.generation};\n      hist.done.push(cur);\n      while (hist.done.length > hist.undoDepth) {\n        hist.done.shift();\n        if (!hist.done[0].ranges) { hist.done.shift(); }\n      }\n    }\n    hist.done.push(selAfter);\n    hist.generation = ++hist.maxGeneration;\n    hist.lastModTime = hist.lastSelTime = time;\n    hist.lastOp = hist.lastSelOp = opId;\n    hist.lastOrigin = hist.lastSelOrigin = change.origin;\n\n    if (!last) { signal(doc, \"historyAdded\"); }\n  }\n\n  function selectionEventCanBeMerged(doc, origin, prev, sel) {\n    var ch = origin.charAt(0);\n    return ch == \"*\" ||\n      ch == \"+\" &&\n      prev.ranges.length == sel.ranges.length &&\n      prev.somethingSelected() == sel.somethingSelected() &&\n      new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500)\n  }\n\n  // Called whenever the selection changes, sets the new selection as\n  // the pending selection in the history, and pushes the old pending\n  // selection into the 'done' array when it was significantly\n  // different (in number of selected ranges, emptiness, or time).\n  function addSelectionToHistory(doc, sel, opId, options) {\n    var hist = doc.history, origin = options && options.origin;\n\n    // A new event is started when the previous origin does not match\n    // the current, or the origins don't allow matching. Origins\n    // starting with * are always merged, those starting with + are\n    // merged when similar and close together in time.\n    if (opId == hist.lastSelOp ||\n        (origin && hist.lastSelOrigin == origin &&\n         (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||\n          selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))\n      { hist.done[hist.done.length - 1] = sel; }\n    else\n      { pushSelectionToHistory(sel, hist.done); }\n\n    hist.lastSelTime = +new Date;\n    hist.lastSelOrigin = origin;\n    hist.lastSelOp = opId;\n    if (options && options.clearRedo !== false)\n      { clearSelectionEvents(hist.undone); }\n  }\n\n  function pushSelectionToHistory(sel, dest) {\n    var top = lst(dest);\n    if (!(top && top.ranges && top.equals(sel)))\n      { dest.push(sel); }\n  }\n\n  // Used to store marked span information in the history.\n  function attachLocalSpans(doc, change, from, to) {\n    var existing = change[\"spans_\" + doc.id], n = 0;\n    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {\n      if (line.markedSpans)\n        { (existing || (existing = change[\"spans_\" + doc.id] = {}))[n] = line.markedSpans; }\n      ++n;\n    });\n  }\n\n  // When un/re-doing restores text containing marked spans, those\n  // that have been explicitly cleared should not be restored.\n  function removeClearedSpans(spans) {\n    if (!spans) { return null }\n    var out;\n    for (var i = 0; i < spans.length; ++i) {\n      if (spans[i].marker.explicitlyCleared) { if (!out) { out = spans.slice(0, i); } }\n      else if (out) { out.push(spans[i]); }\n    }\n    return !out ? spans : out.length ? out : null\n  }\n\n  // Retrieve and filter the old marked spans stored in a change event.\n  function getOldSpans(doc, change) {\n    var found = change[\"spans_\" + doc.id];\n    if (!found) { return null }\n    var nw = [];\n    for (var i = 0; i < change.text.length; ++i)\n      { nw.push(removeClearedSpans(found[i])); }\n    return nw\n  }\n\n  // Used for un/re-doing changes from the history. Combines the\n  // result of computing the existing spans with the set of spans that\n  // existed in the history (so that deleting around a span and then\n  // undoing brings back the span).\n  function mergeOldSpans(doc, change) {\n    var old = getOldSpans(doc, change);\n    var stretched = stretchSpansOverChange(doc, change);\n    if (!old) { return stretched }\n    if (!stretched) { return old }\n\n    for (var i = 0; i < old.length; ++i) {\n      var oldCur = old[i], stretchCur = stretched[i];\n      if (oldCur && stretchCur) {\n        spans: for (var j = 0; j < stretchCur.length; ++j) {\n          var span = stretchCur[j];\n          for (var k = 0; k < oldCur.length; ++k)\n            { if (oldCur[k].marker == span.marker) { continue spans } }\n          oldCur.push(span);\n        }\n      } else if (stretchCur) {\n        old[i] = stretchCur;\n      }\n    }\n    return old\n  }\n\n  // Used both to provide a JSON-safe object in .getHistory, and, when\n  // detaching a document, to split the history in two\n  function copyHistoryArray(events, newGroup, instantiateSel) {\n    var copy = [];\n    for (var i = 0; i < events.length; ++i) {\n      var event = events[i];\n      if (event.ranges) {\n        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);\n        continue\n      }\n      var changes = event.changes, newChanges = [];\n      copy.push({changes: newChanges});\n      for (var j = 0; j < changes.length; ++j) {\n        var change = changes[j], m = (void 0);\n        newChanges.push({from: change.from, to: change.to, text: change.text});\n        if (newGroup) { for (var prop in change) { if (m = prop.match(/^spans_(\\d+)$/)) {\n          if (indexOf(newGroup, Number(m[1])) > -1) {\n            lst(newChanges)[prop] = change[prop];\n            delete change[prop];\n          }\n        } } }\n      }\n    }\n    return copy\n  }\n\n  // The 'scroll' parameter given to many of these indicated whether\n  // the new cursor position should be scrolled into view after\n  // modifying the selection.\n\n  // If shift is held or the extend flag is set, extends a range to\n  // include a given position (and optionally a second position).\n  // Otherwise, simply returns the range between the given positions.\n  // Used for cursor motion and such.\n  function extendRange(range, head, other, extend) {\n    if (extend) {\n      var anchor = range.anchor;\n      if (other) {\n        var posBefore = cmp(head, anchor) < 0;\n        if (posBefore != (cmp(other, anchor) < 0)) {\n          anchor = head;\n          head = other;\n        } else if (posBefore != (cmp(head, other) < 0)) {\n          head = other;\n        }\n      }\n      return new Range(anchor, head)\n    } else {\n      return new Range(other || head, head)\n    }\n  }\n\n  // Extend the primary selection range, discard the rest.\n  function extendSelection(doc, head, other, options, extend) {\n    if (extend == null) { extend = doc.cm && (doc.cm.display.shift || doc.extend); }\n    setSelection(doc, new Selection([extendRange(doc.sel.primary(), head, other, extend)], 0), options);\n  }\n\n  // Extend all selections (pos is an array of selections with length\n  // equal the number of selections)\n  function extendSelections(doc, heads, options) {\n    var out = [];\n    var extend = doc.cm && (doc.cm.display.shift || doc.extend);\n    for (var i = 0; i < doc.sel.ranges.length; i++)\n      { out[i] = extendRange(doc.sel.ranges[i], heads[i], null, extend); }\n    var newSel = normalizeSelection(doc.cm, out, doc.sel.primIndex);\n    setSelection(doc, newSel, options);\n  }\n\n  // Updates a single range in the selection.\n  function replaceOneSelection(doc, i, range, options) {\n    var ranges = doc.sel.ranges.slice(0);\n    ranges[i] = range;\n    setSelection(doc, normalizeSelection(doc.cm, ranges, doc.sel.primIndex), options);\n  }\n\n  // Reset the selection to a single range.\n  function setSimpleSelection(doc, anchor, head, options) {\n    setSelection(doc, simpleSelection(anchor, head), options);\n  }\n\n  // Give beforeSelectionChange handlers a change to influence a\n  // selection update.\n  function filterSelectionChange(doc, sel, options) {\n    var obj = {\n      ranges: sel.ranges,\n      update: function(ranges) {\n        var this$1 = this;\n\n        this.ranges = [];\n        for (var i = 0; i < ranges.length; i++)\n          { this$1.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),\n                                     clipPos(doc, ranges[i].head)); }\n      },\n      origin: options && options.origin\n    };\n    signal(doc, \"beforeSelectionChange\", doc, obj);\n    if (doc.cm) { signal(doc.cm, \"beforeSelectionChange\", doc.cm, obj); }\n    if (obj.ranges != sel.ranges) { return normalizeSelection(doc.cm, obj.ranges, obj.ranges.length - 1) }\n    else { return sel }\n  }\n\n  function setSelectionReplaceHistory(doc, sel, options) {\n    var done = doc.history.done, last = lst(done);\n    if (last && last.ranges) {\n      done[done.length - 1] = sel;\n      setSelectionNoUndo(doc, sel, options);\n    } else {\n      setSelection(doc, sel, options);\n    }\n  }\n\n  // Set a new selection.\n  function setSelection(doc, sel, options) {\n    setSelectionNoUndo(doc, sel, options);\n    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);\n  }\n\n  function setSelectionNoUndo(doc, sel, options) {\n    if (hasHandler(doc, \"beforeSelectionChange\") || doc.cm && hasHandler(doc.cm, \"beforeSelectionChange\"))\n      { sel = filterSelectionChange(doc, sel, options); }\n\n    var bias = options && options.bias ||\n      (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);\n    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));\n\n    if (!(options && options.scroll === false) && doc.cm)\n      { ensureCursorVisible(doc.cm); }\n  }\n\n  function setSelectionInner(doc, sel) {\n    if (sel.equals(doc.sel)) { return }\n\n    doc.sel = sel;\n\n    if (doc.cm) {\n      doc.cm.curOp.updateInput = 1;\n      doc.cm.curOp.selectionChanged = true;\n      signalCursorActivity(doc.cm);\n    }\n    signalLater(doc, \"cursorActivity\", doc);\n  }\n\n  // Verify that the selection does not partially select any atomic\n  // marked ranges.\n  function reCheckSelection(doc) {\n    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));\n  }\n\n  // Return a selection that does not partially select any atomic\n  // ranges.\n  function skipAtomicInSelection(doc, sel, bias, mayClear) {\n    var out;\n    for (var i = 0; i < sel.ranges.length; i++) {\n      var range = sel.ranges[i];\n      var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];\n      var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);\n      var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);\n      if (out || newAnchor != range.anchor || newHead != range.head) {\n        if (!out) { out = sel.ranges.slice(0, i); }\n        out[i] = new Range(newAnchor, newHead);\n      }\n    }\n    return out ? normalizeSelection(doc.cm, out, sel.primIndex) : sel\n  }\n\n  function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {\n    var line = getLine(doc, pos.line);\n    if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {\n      var sp = line.markedSpans[i], m = sp.marker;\n      if ((sp.from == null || (m.inclusiveLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&\n          (sp.to == null || (m.inclusiveRight ? sp.to >= pos.ch : sp.to > pos.ch))) {\n        if (mayClear) {\n          signal(m, \"beforeCursorEnter\");\n          if (m.explicitlyCleared) {\n            if (!line.markedSpans) { break }\n            else {--i; continue}\n          }\n        }\n        if (!m.atomic) { continue }\n\n        if (oldPos) {\n          var near = m.find(dir < 0 ? 1 : -1), diff = (void 0);\n          if (dir < 0 ? m.inclusiveRight : m.inclusiveLeft)\n            { near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null); }\n          if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))\n            { return skipAtomicInner(doc, near, pos, dir, mayClear) }\n        }\n\n        var far = m.find(dir < 0 ? -1 : 1);\n        if (dir < 0 ? m.inclusiveLeft : m.inclusiveRight)\n          { far = movePos(doc, far, dir, far.line == pos.line ? line : null); }\n        return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null\n      }\n    } }\n    return pos\n  }\n\n  // Ensure a given position is not inside an atomic range.\n  function skipAtomic(doc, pos, oldPos, bias, mayClear) {\n    var dir = bias || 1;\n    var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||\n        (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||\n        skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||\n        (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true));\n    if (!found) {\n      doc.cantEdit = true;\n      return Pos(doc.first, 0)\n    }\n    return found\n  }\n\n  function movePos(doc, pos, dir, line) {\n    if (dir < 0 && pos.ch == 0) {\n      if (pos.line > doc.first) { return clipPos(doc, Pos(pos.line - 1)) }\n      else { return null }\n    } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {\n      if (pos.line < doc.first + doc.size - 1) { return Pos(pos.line + 1, 0) }\n      else { return null }\n    } else {\n      return new Pos(pos.line, pos.ch + dir)\n    }\n  }\n\n  function selectAll(cm) {\n    cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);\n  }\n\n  // UPDATING\n\n  // Allow \"beforeChange\" event handlers to influence a change\n  function filterChange(doc, change, update) {\n    var obj = {\n      canceled: false,\n      from: change.from,\n      to: change.to,\n      text: change.text,\n      origin: change.origin,\n      cancel: function () { return obj.canceled = true; }\n    };\n    if (update) { obj.update = function (from, to, text, origin) {\n      if (from) { obj.from = clipPos(doc, from); }\n      if (to) { obj.to = clipPos(doc, to); }\n      if (text) { obj.text = text; }\n      if (origin !== undefined) { obj.origin = origin; }\n    }; }\n    signal(doc, \"beforeChange\", doc, obj);\n    if (doc.cm) { signal(doc.cm, \"beforeChange\", doc.cm, obj); }\n\n    if (obj.canceled) {\n      if (doc.cm) { doc.cm.curOp.updateInput = 2; }\n      return null\n    }\n    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin}\n  }\n\n  // Apply a change to a document, and add it to the document's\n  // history, and propagating it to all linked documents.\n  function makeChange(doc, change, ignoreReadOnly) {\n    if (doc.cm) {\n      if (!doc.cm.curOp) { return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly) }\n      if (doc.cm.state.suppressEdits) { return }\n    }\n\n    if (hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\")) {\n      change = filterChange(doc, change, true);\n      if (!change) { return }\n    }\n\n    // Possibly split or suppress the update based on the presence\n    // of read-only spans in its range.\n    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);\n    if (split) {\n      for (var i = split.length - 1; i >= 0; --i)\n        { makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [\"\"] : change.text, origin: change.origin}); }\n    } else {\n      makeChangeInner(doc, change);\n    }\n  }\n\n  function makeChangeInner(doc, change) {\n    if (change.text.length == 1 && change.text[0] == \"\" && cmp(change.from, change.to) == 0) { return }\n    var selAfter = computeSelAfterChange(doc, change);\n    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);\n\n    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));\n    var rebased = [];\n\n    linkedDocs(doc, function (doc, sharedHist) {\n      if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n        rebaseHist(doc.history, change);\n        rebased.push(doc.history);\n      }\n      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));\n    });\n  }\n\n  // Revert a change stored in a document's history.\n  function makeChangeFromHistory(doc, type, allowSelectionOnly) {\n    var suppress = doc.cm && doc.cm.state.suppressEdits;\n    if (suppress && !allowSelectionOnly) { return }\n\n    var hist = doc.history, event, selAfter = doc.sel;\n    var source = type == \"undo\" ? hist.done : hist.undone, dest = type == \"undo\" ? hist.undone : hist.done;\n\n    // Verify that there is a useable event (so that ctrl-z won't\n    // needlessly clear selection events)\n    var i = 0;\n    for (; i < source.length; i++) {\n      event = source[i];\n      if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)\n        { break }\n    }\n    if (i == source.length) { return }\n    hist.lastOrigin = hist.lastSelOrigin = null;\n\n    for (;;) {\n      event = source.pop();\n      if (event.ranges) {\n        pushSelectionToHistory(event, dest);\n        if (allowSelectionOnly && !event.equals(doc.sel)) {\n          setSelection(doc, event, {clearRedo: false});\n          return\n        }\n        selAfter = event;\n      } else if (suppress) {\n        source.push(event);\n        return\n      } else { break }\n    }\n\n    // Build up a reverse change object to add to the opposite history\n    // stack (redo when undoing, and vice versa).\n    var antiChanges = [];\n    pushSelectionToHistory(selAfter, dest);\n    dest.push({changes: antiChanges, generation: hist.generation});\n    hist.generation = event.generation || ++hist.maxGeneration;\n\n    var filter = hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\");\n\n    var loop = function ( i ) {\n      var change = event.changes[i];\n      change.origin = type;\n      if (filter && !filterChange(doc, change, false)) {\n        source.length = 0;\n        return {}\n      }\n\n      antiChanges.push(historyChangeFromChange(doc, change));\n\n      var after = i ? computeSelAfterChange(doc, change) : lst(source);\n      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));\n      if (!i && doc.cm) { doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)}); }\n      var rebased = [];\n\n      // Propagate to the linked documents\n      linkedDocs(doc, function (doc, sharedHist) {\n        if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n          rebaseHist(doc.history, change);\n          rebased.push(doc.history);\n        }\n        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));\n      });\n    };\n\n    for (var i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {\n      var returned = loop( i$1 );\n\n      if ( returned ) return returned.v;\n    }\n  }\n\n  // Sub-views need their line numbers shifted when text is added\n  // above or below them in the parent document.\n  function shiftDoc(doc, distance) {\n    if (distance == 0) { return }\n    doc.first += distance;\n    doc.sel = new Selection(map(doc.sel.ranges, function (range) { return new Range(\n      Pos(range.anchor.line + distance, range.anchor.ch),\n      Pos(range.head.line + distance, range.head.ch)\n    ); }), doc.sel.primIndex);\n    if (doc.cm) {\n      regChange(doc.cm, doc.first, doc.first - distance, distance);\n      for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)\n        { regLineChange(doc.cm, l, \"gutter\"); }\n    }\n  }\n\n  // More lower-level change function, handling only a single document\n  // (not linked ones).\n  function makeChangeSingleDoc(doc, change, selAfter, spans) {\n    if (doc.cm && !doc.cm.curOp)\n      { return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans) }\n\n    if (change.to.line < doc.first) {\n      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));\n      return\n    }\n    if (change.from.line > doc.lastLine()) { return }\n\n    // Clip the change to the size of this doc\n    if (change.from.line < doc.first) {\n      var shift = change.text.length - 1 - (doc.first - change.from.line);\n      shiftDoc(doc, shift);\n      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),\n                text: [lst(change.text)], origin: change.origin};\n    }\n    var last = doc.lastLine();\n    if (change.to.line > last) {\n      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),\n                text: [change.text[0]], origin: change.origin};\n    }\n\n    change.removed = getBetween(doc, change.from, change.to);\n\n    if (!selAfter) { selAfter = computeSelAfterChange(doc, change); }\n    if (doc.cm) { makeChangeSingleDocInEditor(doc.cm, change, spans); }\n    else { updateDoc(doc, change, spans); }\n    setSelectionNoUndo(doc, selAfter, sel_dontScroll);\n  }\n\n  // Handle the interaction of a change to a document with the editor\n  // that this document is part of.\n  function makeChangeSingleDocInEditor(cm, change, spans) {\n    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;\n\n    var recomputeMaxLength = false, checkWidthStart = from.line;\n    if (!cm.options.lineWrapping) {\n      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));\n      doc.iter(checkWidthStart, to.line + 1, function (line) {\n        if (line == display.maxLine) {\n          recomputeMaxLength = true;\n          return true\n        }\n      });\n    }\n\n    if (doc.sel.contains(change.from, change.to) > -1)\n      { signalCursorActivity(cm); }\n\n    updateDoc(doc, change, spans, estimateHeight(cm));\n\n    if (!cm.options.lineWrapping) {\n      doc.iter(checkWidthStart, from.line + change.text.length, function (line) {\n        var len = lineLength(line);\n        if (len > display.maxLineLength) {\n          display.maxLine = line;\n          display.maxLineLength = len;\n          display.maxLineChanged = true;\n          recomputeMaxLength = false;\n        }\n      });\n      if (recomputeMaxLength) { cm.curOp.updateMaxLine = true; }\n    }\n\n    retreatFrontier(doc, from.line);\n    startWorker(cm, 400);\n\n    var lendiff = change.text.length - (to.line - from.line) - 1;\n    // Remember that these lines changed, for updating the display\n    if (change.full)\n      { regChange(cm); }\n    else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))\n      { regLineChange(cm, from.line, \"text\"); }\n    else\n      { regChange(cm, from.line, to.line + 1, lendiff); }\n\n    var changesHandler = hasHandler(cm, \"changes\"), changeHandler = hasHandler(cm, \"change\");\n    if (changeHandler || changesHandler) {\n      var obj = {\n        from: from, to: to,\n        text: change.text,\n        removed: change.removed,\n        origin: change.origin\n      };\n      if (changeHandler) { signalLater(cm, \"change\", cm, obj); }\n      if (changesHandler) { (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj); }\n    }\n    cm.display.selForContextMenu = null;\n  }\n\n  function replaceRange(doc, code, from, to, origin) {\n    var assign;\n\n    if (!to) { to = from; }\n    if (cmp(to, from) < 0) { (assign = [to, from], from = assign[0], to = assign[1]); }\n    if (typeof code == \"string\") { code = doc.splitLines(code); }\n    makeChange(doc, {from: from, to: to, text: code, origin: origin});\n  }\n\n  // Rebasing/resetting history to deal with externally-sourced changes\n\n  function rebaseHistSelSingle(pos, from, to, diff) {\n    if (to < pos.line) {\n      pos.line += diff;\n    } else if (from < pos.line) {\n      pos.line = from;\n      pos.ch = 0;\n    }\n  }\n\n  // Tries to rebase an array of history events given a change in the\n  // document. If the change touches the same lines as the event, the\n  // event, and everything 'behind' it, is discarded. If the change is\n  // before the event, the event's positions are updated. Uses a\n  // copy-on-write scheme for the positions, to avoid having to\n  // reallocate them all on every rebase, but also avoid problems with\n  // shared position objects being unsafely updated.\n  function rebaseHistArray(array, from, to, diff) {\n    for (var i = 0; i < array.length; ++i) {\n      var sub = array[i], ok = true;\n      if (sub.ranges) {\n        if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }\n        for (var j = 0; j < sub.ranges.length; j++) {\n          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);\n          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);\n        }\n        continue\n      }\n      for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {\n        var cur = sub.changes[j$1];\n        if (to < cur.from.line) {\n          cur.from = Pos(cur.from.line + diff, cur.from.ch);\n          cur.to = Pos(cur.to.line + diff, cur.to.ch);\n        } else if (from <= cur.to.line) {\n          ok = false;\n          break\n        }\n      }\n      if (!ok) {\n        array.splice(0, i + 1);\n        i = 0;\n      }\n    }\n  }\n\n  function rebaseHist(hist, change) {\n    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;\n    rebaseHistArray(hist.done, from, to, diff);\n    rebaseHistArray(hist.undone, from, to, diff);\n  }\n\n  // Utility for applying a change to a line by handle or number,\n  // returning the number and optionally registering the line as\n  // changed.\n  function changeLine(doc, handle, changeType, op) {\n    var no = handle, line = handle;\n    if (typeof handle == \"number\") { line = getLine(doc, clipLine(doc, handle)); }\n    else { no = lineNo(handle); }\n    if (no == null) { return null }\n    if (op(line, no) && doc.cm) { regLineChange(doc.cm, no, changeType); }\n    return line\n  }\n\n  // The document is represented as a BTree consisting of leaves, with\n  // chunk of lines in them, and branches, with up to ten leaves or\n  // other branch nodes below them. The top node is always a branch\n  // node, and is the document object itself (meaning it has\n  // additional methods and properties).\n  //\n  // All nodes have parent links. The tree is used both to go from\n  // line numbers to line objects, and to go from objects to numbers.\n  // It also indexes by height, and is used to convert between height\n  // and line object, and to find the total height of the document.\n  //\n  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html\n\n  function LeafChunk(lines) {\n    var this$1 = this;\n\n    this.lines = lines;\n    this.parent = null;\n    var height = 0;\n    for (var i = 0; i < lines.length; ++i) {\n      lines[i].parent = this$1;\n      height += lines[i].height;\n    }\n    this.height = height;\n  }\n\n  LeafChunk.prototype = {\n    chunkSize: function() { return this.lines.length },\n\n    // Remove the n lines at offset 'at'.\n    removeInner: function(at, n) {\n      var this$1 = this;\n\n      for (var i = at, e = at + n; i < e; ++i) {\n        var line = this$1.lines[i];\n        this$1.height -= line.height;\n        cleanUpLine(line);\n        signalLater(line, \"delete\");\n      }\n      this.lines.splice(at, n);\n    },\n\n    // Helper used to collapse a small branch into a single leaf.\n    collapse: function(lines) {\n      lines.push.apply(lines, this.lines);\n    },\n\n    // Insert the given array of lines at offset 'at', count them as\n    // having the given height.\n    insertInner: function(at, lines, height) {\n      var this$1 = this;\n\n      this.height += height;\n      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));\n      for (var i = 0; i < lines.length; ++i) { lines[i].parent = this$1; }\n    },\n\n    // Used to iterate over a part of the tree.\n    iterN: function(at, n, op) {\n      var this$1 = this;\n\n      for (var e = at + n; at < e; ++at)\n        { if (op(this$1.lines[at])) { return true } }\n    }\n  };\n\n  function BranchChunk(children) {\n    var this$1 = this;\n\n    this.children = children;\n    var size = 0, height = 0;\n    for (var i = 0; i < children.length; ++i) {\n      var ch = children[i];\n      size += ch.chunkSize(); height += ch.height;\n      ch.parent = this$1;\n    }\n    this.size = size;\n    this.height = height;\n    this.parent = null;\n  }\n\n  BranchChunk.prototype = {\n    chunkSize: function() { return this.size },\n\n    removeInner: function(at, n) {\n      var this$1 = this;\n\n      this.size -= n;\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this$1.children[i], sz = child.chunkSize();\n        if (at < sz) {\n          var rm = Math.min(n, sz - at), oldHeight = child.height;\n          child.removeInner(at, rm);\n          this$1.height -= oldHeight - child.height;\n          if (sz == rm) { this$1.children.splice(i--, 1); child.parent = null; }\n          if ((n -= rm) == 0) { break }\n          at = 0;\n        } else { at -= sz; }\n      }\n      // If the result is smaller than 25 lines, ensure that it is a\n      // single leaf node.\n      if (this.size - n < 25 &&\n          (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {\n        var lines = [];\n        this.collapse(lines);\n        this.children = [new LeafChunk(lines)];\n        this.children[0].parent = this;\n      }\n    },\n\n    collapse: function(lines) {\n      var this$1 = this;\n\n      for (var i = 0; i < this.children.length; ++i) { this$1.children[i].collapse(lines); }\n    },\n\n    insertInner: function(at, lines, height) {\n      var this$1 = this;\n\n      this.size += lines.length;\n      this.height += height;\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this$1.children[i], sz = child.chunkSize();\n        if (at <= sz) {\n          child.insertInner(at, lines, height);\n          if (child.lines && child.lines.length > 50) {\n            // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.\n            // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.\n            var remaining = child.lines.length % 25 + 25;\n            for (var pos = remaining; pos < child.lines.length;) {\n              var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));\n              child.height -= leaf.height;\n              this$1.children.splice(++i, 0, leaf);\n              leaf.parent = this$1;\n            }\n            child.lines = child.lines.slice(0, remaining);\n            this$1.maybeSpill();\n          }\n          break\n        }\n        at -= sz;\n      }\n    },\n\n    // When a node has grown, check whether it should be split.\n    maybeSpill: function() {\n      if (this.children.length <= 10) { return }\n      var me = this;\n      do {\n        var spilled = me.children.splice(me.children.length - 5, 5);\n        var sibling = new BranchChunk(spilled);\n        if (!me.parent) { // Become the parent node\n          var copy = new BranchChunk(me.children);\n          copy.parent = me;\n          me.children = [copy, sibling];\n          me = copy;\n       } else {\n          me.size -= sibling.size;\n          me.height -= sibling.height;\n          var myIndex = indexOf(me.parent.children, me);\n          me.parent.children.splice(myIndex + 1, 0, sibling);\n        }\n        sibling.parent = me.parent;\n      } while (me.children.length > 10)\n      me.parent.maybeSpill();\n    },\n\n    iterN: function(at, n, op) {\n      var this$1 = this;\n\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this$1.children[i], sz = child.chunkSize();\n        if (at < sz) {\n          var used = Math.min(n, sz - at);\n          if (child.iterN(at, used, op)) { return true }\n          if ((n -= used) == 0) { break }\n          at = 0;\n        } else { at -= sz; }\n      }\n    }\n  };\n\n  // Line widgets are block elements displayed above or below a line.\n\n  var LineWidget = function(doc, node, options) {\n    var this$1 = this;\n\n    if (options) { for (var opt in options) { if (options.hasOwnProperty(opt))\n      { this$1[opt] = options[opt]; } } }\n    this.doc = doc;\n    this.node = node;\n  };\n\n  LineWidget.prototype.clear = function () {\n      var this$1 = this;\n\n    var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);\n    if (no == null || !ws) { return }\n    for (var i = 0; i < ws.length; ++i) { if (ws[i] == this$1) { ws.splice(i--, 1); } }\n    if (!ws.length) { line.widgets = null; }\n    var height = widgetHeight(this);\n    updateLineHeight(line, Math.max(0, line.height - height));\n    if (cm) {\n      runInOp(cm, function () {\n        adjustScrollWhenAboveVisible(cm, line, -height);\n        regLineChange(cm, no, \"widget\");\n      });\n      signalLater(cm, \"lineWidgetCleared\", cm, this, no);\n    }\n  };\n\n  LineWidget.prototype.changed = function () {\n      var this$1 = this;\n\n    var oldH = this.height, cm = this.doc.cm, line = this.line;\n    this.height = null;\n    var diff = widgetHeight(this) - oldH;\n    if (!diff) { return }\n    if (!lineIsHidden(this.doc, line)) { updateLineHeight(line, line.height + diff); }\n    if (cm) {\n      runInOp(cm, function () {\n        cm.curOp.forceUpdate = true;\n        adjustScrollWhenAboveVisible(cm, line, diff);\n        signalLater(cm, \"lineWidgetChanged\", cm, this$1, lineNo(line));\n      });\n    }\n  };\n  eventMixin(LineWidget);\n\n  function adjustScrollWhenAboveVisible(cm, line, diff) {\n    if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))\n      { addToScrollTop(cm, diff); }\n  }\n\n  function addLineWidget(doc, handle, node, options) {\n    var widget = new LineWidget(doc, node, options);\n    var cm = doc.cm;\n    if (cm && widget.noHScroll) { cm.display.alignWidgets = true; }\n    changeLine(doc, handle, \"widget\", function (line) {\n      var widgets = line.widgets || (line.widgets = []);\n      if (widget.insertAt == null) { widgets.push(widget); }\n      else { widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget); }\n      widget.line = line;\n      if (cm && !lineIsHidden(doc, line)) {\n        var aboveVisible = heightAtLine(line) < doc.scrollTop;\n        updateLineHeight(line, line.height + widgetHeight(widget));\n        if (aboveVisible) { addToScrollTop(cm, widget.height); }\n        cm.curOp.forceUpdate = true;\n      }\n      return true\n    });\n    if (cm) { signalLater(cm, \"lineWidgetAdded\", cm, widget, typeof handle == \"number\" ? handle : lineNo(handle)); }\n    return widget\n  }\n\n  // TEXTMARKERS\n\n  // Created with markText and setBookmark methods. A TextMarker is a\n  // handle that can be used to clear or find a marked position in the\n  // document. Line objects hold arrays (markedSpans) containing\n  // {from, to, marker} object pointing to such marker objects, and\n  // indicating that such a marker is present on that line. Multiple\n  // lines may point to the same marker when it spans across lines.\n  // The spans will have null for their from/to properties when the\n  // marker continues beyond the start/end of the line. Markers have\n  // links back to the lines they currently touch.\n\n  // Collapsed markers have unique ids, in order to be able to order\n  // them, which is needed for uniquely determining an outer marker\n  // when they overlap (they may nest, but not partially overlap).\n  var nextMarkerId = 0;\n\n  var TextMarker = function(doc, type) {\n    this.lines = [];\n    this.type = type;\n    this.doc = doc;\n    this.id = ++nextMarkerId;\n  };\n\n  // Clear the marker.\n  TextMarker.prototype.clear = function () {\n      var this$1 = this;\n\n    if (this.explicitlyCleared) { return }\n    var cm = this.doc.cm, withOp = cm && !cm.curOp;\n    if (withOp) { startOperation(cm); }\n    if (hasHandler(this, \"clear\")) {\n      var found = this.find();\n      if (found) { signalLater(this, \"clear\", found.from, found.to); }\n    }\n    var min = null, max = null;\n    for (var i = 0; i < this.lines.length; ++i) {\n      var line = this$1.lines[i];\n      var span = getMarkedSpanFor(line.markedSpans, this$1);\n      if (cm && !this$1.collapsed) { regLineChange(cm, lineNo(line), \"text\"); }\n      else if (cm) {\n        if (span.to != null) { max = lineNo(line); }\n        if (span.from != null) { min = lineNo(line); }\n      }\n      line.markedSpans = removeMarkedSpan(line.markedSpans, span);\n      if (span.from == null && this$1.collapsed && !lineIsHidden(this$1.doc, line) && cm)\n        { updateLineHeight(line, textHeight(cm.display)); }\n    }\n    if (cm && this.collapsed && !cm.options.lineWrapping) { for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {\n      var visual = visualLine(this$1.lines[i$1]), len = lineLength(visual);\n      if (len > cm.display.maxLineLength) {\n        cm.display.maxLine = visual;\n        cm.display.maxLineLength = len;\n        cm.display.maxLineChanged = true;\n      }\n    } }\n\n    if (min != null && cm && this.collapsed) { regChange(cm, min, max + 1); }\n    this.lines.length = 0;\n    this.explicitlyCleared = true;\n    if (this.atomic && this.doc.cantEdit) {\n      this.doc.cantEdit = false;\n      if (cm) { reCheckSelection(cm.doc); }\n    }\n    if (cm) { signalLater(cm, \"markerCleared\", cm, this, min, max); }\n    if (withOp) { endOperation(cm); }\n    if (this.parent) { this.parent.clear(); }\n  };\n\n  // Find the position of the marker in the document. Returns a {from,\n  // to} object by default. Side can be passed to get a specific side\n  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the\n  // Pos objects returned contain a line object, rather than a line\n  // number (used to prevent looking up the same line twice).\n  TextMarker.prototype.find = function (side, lineObj) {\n      var this$1 = this;\n\n    if (side == null && this.type == \"bookmark\") { side = 1; }\n    var from, to;\n    for (var i = 0; i < this.lines.length; ++i) {\n      var line = this$1.lines[i];\n      var span = getMarkedSpanFor(line.markedSpans, this$1);\n      if (span.from != null) {\n        from = Pos(lineObj ? line : lineNo(line), span.from);\n        if (side == -1) { return from }\n      }\n      if (span.to != null) {\n        to = Pos(lineObj ? line : lineNo(line), span.to);\n        if (side == 1) { return to }\n      }\n    }\n    return from && {from: from, to: to}\n  };\n\n  // Signals that the marker's widget changed, and surrounding layout\n  // should be recomputed.\n  TextMarker.prototype.changed = function () {\n      var this$1 = this;\n\n    var pos = this.find(-1, true), widget = this, cm = this.doc.cm;\n    if (!pos || !cm) { return }\n    runInOp(cm, function () {\n      var line = pos.line, lineN = lineNo(pos.line);\n      var view = findViewForLine(cm, lineN);\n      if (view) {\n        clearLineMeasurementCacheFor(view);\n        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;\n      }\n      cm.curOp.updateMaxLine = true;\n      if (!lineIsHidden(widget.doc, line) && widget.height != null) {\n        var oldHeight = widget.height;\n        widget.height = null;\n        var dHeight = widgetHeight(widget) - oldHeight;\n        if (dHeight)\n          { updateLineHeight(line, line.height + dHeight); }\n      }\n      signalLater(cm, \"markerChanged\", cm, this$1);\n    });\n  };\n\n  TextMarker.prototype.attachLine = function (line) {\n    if (!this.lines.length && this.doc.cm) {\n      var op = this.doc.cm.curOp;\n      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)\n        { (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this); }\n    }\n    this.lines.push(line);\n  };\n\n  TextMarker.prototype.detachLine = function (line) {\n    this.lines.splice(indexOf(this.lines, line), 1);\n    if (!this.lines.length && this.doc.cm) {\n      var op = this.doc.cm.curOp\n      ;(op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);\n    }\n  };\n  eventMixin(TextMarker);\n\n  // Create a marker, wire it up to the right lines, and\n  function markText(doc, from, to, options, type) {\n    // Shared markers (across linked documents) are handled separately\n    // (markTextShared will call out to this again, once per\n    // document).\n    if (options && options.shared) { return markTextShared(doc, from, to, options, type) }\n    // Ensure we are in an operation.\n    if (doc.cm && !doc.cm.curOp) { return operation(doc.cm, markText)(doc, from, to, options, type) }\n\n    var marker = new TextMarker(doc, type), diff = cmp(from, to);\n    if (options) { copyObj(options, marker, false); }\n    // Don't connect empty markers unless clearWhenEmpty is false\n    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)\n      { return marker }\n    if (marker.replacedWith) {\n      // Showing up as a widget implies collapsed (widget replaces text)\n      marker.collapsed = true;\n      marker.widgetNode = eltP(\"span\", [marker.replacedWith], \"CodeMirror-widget\");\n      if (!options.handleMouseEvents) { marker.widgetNode.setAttribute(\"cm-ignore-events\", \"true\"); }\n      if (options.insertLeft) { marker.widgetNode.insertLeft = true; }\n    }\n    if (marker.collapsed) {\n      if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||\n          from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))\n        { throw new Error(\"Inserting collapsed marker partially overlapping an existing one\") }\n      seeCollapsedSpans();\n    }\n\n    if (marker.addToHistory)\n      { addChangeToHistory(doc, {from: from, to: to, origin: \"markText\"}, doc.sel, NaN); }\n\n    var curLine = from.line, cm = doc.cm, updateMaxLine;\n    doc.iter(curLine, to.line + 1, function (line) {\n      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)\n        { updateMaxLine = true; }\n      if (marker.collapsed && curLine != from.line) { updateLineHeight(line, 0); }\n      addMarkedSpan(line, new MarkedSpan(marker,\n                                         curLine == from.line ? from.ch : null,\n                                         curLine == to.line ? to.ch : null));\n      ++curLine;\n    });\n    // lineIsHidden depends on the presence of the spans, so needs a second pass\n    if (marker.collapsed) { doc.iter(from.line, to.line + 1, function (line) {\n      if (lineIsHidden(doc, line)) { updateLineHeight(line, 0); }\n    }); }\n\n    if (marker.clearOnEnter) { on(marker, \"beforeCursorEnter\", function () { return marker.clear(); }); }\n\n    if (marker.readOnly) {\n      seeReadOnlySpans();\n      if (doc.history.done.length || doc.history.undone.length)\n        { doc.clearHistory(); }\n    }\n    if (marker.collapsed) {\n      marker.id = ++nextMarkerId;\n      marker.atomic = true;\n    }\n    if (cm) {\n      // Sync editor state\n      if (updateMaxLine) { cm.curOp.updateMaxLine = true; }\n      if (marker.collapsed)\n        { regChange(cm, from.line, to.line + 1); }\n      else if (marker.className || marker.startStyle || marker.endStyle || marker.css ||\n               marker.attributes || marker.title)\n        { for (var i = from.line; i <= to.line; i++) { regLineChange(cm, i, \"text\"); } }\n      if (marker.atomic) { reCheckSelection(cm.doc); }\n      signalLater(cm, \"markerAdded\", cm, marker);\n    }\n    return marker\n  }\n\n  // SHARED TEXTMARKERS\n\n  // A shared marker spans multiple linked documents. It is\n  // implemented as a meta-marker-object controlling multiple normal\n  // markers.\n  var SharedTextMarker = function(markers, primary) {\n    var this$1 = this;\n\n    this.markers = markers;\n    this.primary = primary;\n    for (var i = 0; i < markers.length; ++i)\n      { markers[i].parent = this$1; }\n  };\n\n  SharedTextMarker.prototype.clear = function () {\n      var this$1 = this;\n\n    if (this.explicitlyCleared) { return }\n    this.explicitlyCleared = true;\n    for (var i = 0; i < this.markers.length; ++i)\n      { this$1.markers[i].clear(); }\n    signalLater(this, \"clear\");\n  };\n\n  SharedTextMarker.prototype.find = function (side, lineObj) {\n    return this.primary.find(side, lineObj)\n  };\n  eventMixin(SharedTextMarker);\n\n  function markTextShared(doc, from, to, options, type) {\n    options = copyObj(options);\n    options.shared = false;\n    var markers = [markText(doc, from, to, options, type)], primary = markers[0];\n    var widget = options.widgetNode;\n    linkedDocs(doc, function (doc) {\n      if (widget) { options.widgetNode = widget.cloneNode(true); }\n      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));\n      for (var i = 0; i < doc.linked.length; ++i)\n        { if (doc.linked[i].isParent) { return } }\n      primary = lst(markers);\n    });\n    return new SharedTextMarker(markers, primary)\n  }\n\n  function findSharedMarkers(doc) {\n    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) { return m.parent; })\n  }\n\n  function copySharedMarkers(doc, markers) {\n    for (var i = 0; i < markers.length; i++) {\n      var marker = markers[i], pos = marker.find();\n      var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);\n      if (cmp(mFrom, mTo)) {\n        var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);\n        marker.markers.push(subMark);\n        subMark.parent = marker;\n      }\n    }\n  }\n\n  function detachSharedMarkers(markers) {\n    var loop = function ( i ) {\n      var marker = markers[i], linked = [marker.primary.doc];\n      linkedDocs(marker.primary.doc, function (d) { return linked.push(d); });\n      for (var j = 0; j < marker.markers.length; j++) {\n        var subMarker = marker.markers[j];\n        if (indexOf(linked, subMarker.doc) == -1) {\n          subMarker.parent = null;\n          marker.markers.splice(j--, 1);\n        }\n      }\n    };\n\n    for (var i = 0; i < markers.length; i++) loop( i );\n  }\n\n  var nextDocId = 0;\n  var Doc = function(text, mode, firstLine, lineSep, direction) {\n    if (!(this instanceof Doc)) { return new Doc(text, mode, firstLine, lineSep, direction) }\n    if (firstLine == null) { firstLine = 0; }\n\n    BranchChunk.call(this, [new LeafChunk([new Line(\"\", null)])]);\n    this.first = firstLine;\n    this.scrollTop = this.scrollLeft = 0;\n    this.cantEdit = false;\n    this.cleanGeneration = 1;\n    this.modeFrontier = this.highlightFrontier = firstLine;\n    var start = Pos(firstLine, 0);\n    this.sel = simpleSelection(start);\n    this.history = new History(null);\n    this.id = ++nextDocId;\n    this.modeOption = mode;\n    this.lineSep = lineSep;\n    this.direction = (direction == \"rtl\") ? \"rtl\" : \"ltr\";\n    this.extend = false;\n\n    if (typeof text == \"string\") { text = this.splitLines(text); }\n    updateDoc(this, {from: start, to: start, text: text});\n    setSelection(this, simpleSelection(start), sel_dontScroll);\n  };\n\n  Doc.prototype = createObj(BranchChunk.prototype, {\n    constructor: Doc,\n    // Iterate over the document. Supports two forms -- with only one\n    // argument, it calls that for each line in the document. With\n    // three, it iterates over the range given by the first two (with\n    // the second being non-inclusive).\n    iter: function(from, to, op) {\n      if (op) { this.iterN(from - this.first, to - from, op); }\n      else { this.iterN(this.first, this.first + this.size, from); }\n    },\n\n    // Non-public interface for adding and removing lines.\n    insert: function(at, lines) {\n      var height = 0;\n      for (var i = 0; i < lines.length; ++i) { height += lines[i].height; }\n      this.insertInner(at - this.first, lines, height);\n    },\n    remove: function(at, n) { this.removeInner(at - this.first, n); },\n\n    // From here, the methods are part of the public interface. Most\n    // are also available from CodeMirror (editor) instances.\n\n    getValue: function(lineSep) {\n      var lines = getLines(this, this.first, this.first + this.size);\n      if (lineSep === false) { return lines }\n      return lines.join(lineSep || this.lineSeparator())\n    },\n    setValue: docMethodOp(function(code) {\n      var top = Pos(this.first, 0), last = this.first + this.size - 1;\n      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),\n                        text: this.splitLines(code), origin: \"setValue\", full: true}, true);\n      if (this.cm) { scrollToCoords(this.cm, 0, 0); }\n      setSelection(this, simpleSelection(top), sel_dontScroll);\n    }),\n    replaceRange: function(code, from, to, origin) {\n      from = clipPos(this, from);\n      to = to ? clipPos(this, to) : from;\n      replaceRange(this, code, from, to, origin);\n    },\n    getRange: function(from, to, lineSep) {\n      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));\n      if (lineSep === false) { return lines }\n      return lines.join(lineSep || this.lineSeparator())\n    },\n\n    getLine: function(line) {var l = this.getLineHandle(line); return l && l.text},\n\n    getLineHandle: function(line) {if (isLine(this, line)) { return getLine(this, line) }},\n    getLineNumber: function(line) {return lineNo(line)},\n\n    getLineHandleVisualStart: function(line) {\n      if (typeof line == \"number\") { line = getLine(this, line); }\n      return visualLine(line)\n    },\n\n    lineCount: function() {return this.size},\n    firstLine: function() {return this.first},\n    lastLine: function() {return this.first + this.size - 1},\n\n    clipPos: function(pos) {return clipPos(this, pos)},\n\n    getCursor: function(start) {\n      var range$$1 = this.sel.primary(), pos;\n      if (start == null || start == \"head\") { pos = range$$1.head; }\n      else if (start == \"anchor\") { pos = range$$1.anchor; }\n      else if (start == \"end\" || start == \"to\" || start === false) { pos = range$$1.to(); }\n      else { pos = range$$1.from(); }\n      return pos\n    },\n    listSelections: function() { return this.sel.ranges },\n    somethingSelected: function() {return this.sel.somethingSelected()},\n\n    setCursor: docMethodOp(function(line, ch, options) {\n      setSimpleSelection(this, clipPos(this, typeof line == \"number\" ? Pos(line, ch || 0) : line), null, options);\n    }),\n    setSelection: docMethodOp(function(anchor, head, options) {\n      setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);\n    }),\n    extendSelection: docMethodOp(function(head, other, options) {\n      extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);\n    }),\n    extendSelections: docMethodOp(function(heads, options) {\n      extendSelections(this, clipPosArray(this, heads), options);\n    }),\n    extendSelectionsBy: docMethodOp(function(f, options) {\n      var heads = map(this.sel.ranges, f);\n      extendSelections(this, clipPosArray(this, heads), options);\n    }),\n    setSelections: docMethodOp(function(ranges, primary, options) {\n      var this$1 = this;\n\n      if (!ranges.length) { return }\n      var out = [];\n      for (var i = 0; i < ranges.length; i++)\n        { out[i] = new Range(clipPos(this$1, ranges[i].anchor),\n                           clipPos(this$1, ranges[i].head)); }\n      if (primary == null) { primary = Math.min(ranges.length - 1, this.sel.primIndex); }\n      setSelection(this, normalizeSelection(this.cm, out, primary), options);\n    }),\n    addSelection: docMethodOp(function(anchor, head, options) {\n      var ranges = this.sel.ranges.slice(0);\n      ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));\n      setSelection(this, normalizeSelection(this.cm, ranges, ranges.length - 1), options);\n    }),\n\n    getSelection: function(lineSep) {\n      var this$1 = this;\n\n      var ranges = this.sel.ranges, lines;\n      for (var i = 0; i < ranges.length; i++) {\n        var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());\n        lines = lines ? lines.concat(sel) : sel;\n      }\n      if (lineSep === false) { return lines }\n      else { return lines.join(lineSep || this.lineSeparator()) }\n    },\n    getSelections: function(lineSep) {\n      var this$1 = this;\n\n      var parts = [], ranges = this.sel.ranges;\n      for (var i = 0; i < ranges.length; i++) {\n        var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());\n        if (lineSep !== false) { sel = sel.join(lineSep || this$1.lineSeparator()); }\n        parts[i] = sel;\n      }\n      return parts\n    },\n    replaceSelection: function(code, collapse, origin) {\n      var dup = [];\n      for (var i = 0; i < this.sel.ranges.length; i++)\n        { dup[i] = code; }\n      this.replaceSelections(dup, collapse, origin || \"+input\");\n    },\n    replaceSelections: docMethodOp(function(code, collapse, origin) {\n      var this$1 = this;\n\n      var changes = [], sel = this.sel;\n      for (var i = 0; i < sel.ranges.length; i++) {\n        var range$$1 = sel.ranges[i];\n        changes[i] = {from: range$$1.from(), to: range$$1.to(), text: this$1.splitLines(code[i]), origin: origin};\n      }\n      var newSel = collapse && collapse != \"end\" && computeReplacedSel(this, changes, collapse);\n      for (var i$1 = changes.length - 1; i$1 >= 0; i$1--)\n        { makeChange(this$1, changes[i$1]); }\n      if (newSel) { setSelectionReplaceHistory(this, newSel); }\n      else if (this.cm) { ensureCursorVisible(this.cm); }\n    }),\n    undo: docMethodOp(function() {makeChangeFromHistory(this, \"undo\");}),\n    redo: docMethodOp(function() {makeChangeFromHistory(this, \"redo\");}),\n    undoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"undo\", true);}),\n    redoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"redo\", true);}),\n\n    setExtending: function(val) {this.extend = val;},\n    getExtending: function() {return this.extend},\n\n    historySize: function() {\n      var hist = this.history, done = 0, undone = 0;\n      for (var i = 0; i < hist.done.length; i++) { if (!hist.done[i].ranges) { ++done; } }\n      for (var i$1 = 0; i$1 < hist.undone.length; i$1++) { if (!hist.undone[i$1].ranges) { ++undone; } }\n      return {undo: done, redo: undone}\n    },\n    clearHistory: function() {this.history = new History(this.history.maxGeneration);},\n\n    markClean: function() {\n      this.cleanGeneration = this.changeGeneration(true);\n    },\n    changeGeneration: function(forceSplit) {\n      if (forceSplit)\n        { this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null; }\n      return this.history.generation\n    },\n    isClean: function (gen) {\n      return this.history.generation == (gen || this.cleanGeneration)\n    },\n\n    getHistory: function() {\n      return {done: copyHistoryArray(this.history.done),\n              undone: copyHistoryArray(this.history.undone)}\n    },\n    setHistory: function(histData) {\n      var hist = this.history = new History(this.history.maxGeneration);\n      hist.done = copyHistoryArray(histData.done.slice(0), null, true);\n      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);\n    },\n\n    setGutterMarker: docMethodOp(function(line, gutterID, value) {\n      return changeLine(this, line, \"gutter\", function (line) {\n        var markers = line.gutterMarkers || (line.gutterMarkers = {});\n        markers[gutterID] = value;\n        if (!value && isEmpty(markers)) { line.gutterMarkers = null; }\n        return true\n      })\n    }),\n\n    clearGutter: docMethodOp(function(gutterID) {\n      var this$1 = this;\n\n      this.iter(function (line) {\n        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {\n          changeLine(this$1, line, \"gutter\", function () {\n            line.gutterMarkers[gutterID] = null;\n            if (isEmpty(line.gutterMarkers)) { line.gutterMarkers = null; }\n            return true\n          });\n        }\n      });\n    }),\n\n    lineInfo: function(line) {\n      var n;\n      if (typeof line == \"number\") {\n        if (!isLine(this, line)) { return null }\n        n = line;\n        line = getLine(this, line);\n        if (!line) { return null }\n      } else {\n        n = lineNo(line);\n        if (n == null) { return null }\n      }\n      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,\n              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,\n              widgets: line.widgets}\n    },\n\n    addLineClass: docMethodOp(function(handle, where, cls) {\n      return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function (line) {\n        var prop = where == \"text\" ? \"textClass\"\n                 : where == \"background\" ? \"bgClass\"\n                 : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n        if (!line[prop]) { line[prop] = cls; }\n        else if (classTest(cls).test(line[prop])) { return false }\n        else { line[prop] += \" \" + cls; }\n        return true\n      })\n    }),\n    removeLineClass: docMethodOp(function(handle, where, cls) {\n      return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function (line) {\n        var prop = where == \"text\" ? \"textClass\"\n                 : where == \"background\" ? \"bgClass\"\n                 : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n        var cur = line[prop];\n        if (!cur) { return false }\n        else if (cls == null) { line[prop] = null; }\n        else {\n          var found = cur.match(classTest(cls));\n          if (!found) { return false }\n          var end = found.index + found[0].length;\n          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? \"\" : \" \") + cur.slice(end) || null;\n        }\n        return true\n      })\n    }),\n\n    addLineWidget: docMethodOp(function(handle, node, options) {\n      return addLineWidget(this, handle, node, options)\n    }),\n    removeLineWidget: function(widget) { widget.clear(); },\n\n    markText: function(from, to, options) {\n      return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || \"range\")\n    },\n    setBookmark: function(pos, options) {\n      var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),\n                      insertLeft: options && options.insertLeft,\n                      clearWhenEmpty: false, shared: options && options.shared,\n                      handleMouseEvents: options && options.handleMouseEvents};\n      pos = clipPos(this, pos);\n      return markText(this, pos, pos, realOpts, \"bookmark\")\n    },\n    findMarksAt: function(pos) {\n      pos = clipPos(this, pos);\n      var markers = [], spans = getLine(this, pos.line).markedSpans;\n      if (spans) { for (var i = 0; i < spans.length; ++i) {\n        var span = spans[i];\n        if ((span.from == null || span.from <= pos.ch) &&\n            (span.to == null || span.to >= pos.ch))\n          { markers.push(span.marker.parent || span.marker); }\n      } }\n      return markers\n    },\n    findMarks: function(from, to, filter) {\n      from = clipPos(this, from); to = clipPos(this, to);\n      var found = [], lineNo$$1 = from.line;\n      this.iter(from.line, to.line + 1, function (line) {\n        var spans = line.markedSpans;\n        if (spans) { for (var i = 0; i < spans.length; i++) {\n          var span = spans[i];\n          if (!(span.to != null && lineNo$$1 == from.line && from.ch >= span.to ||\n                span.from == null && lineNo$$1 != from.line ||\n                span.from != null && lineNo$$1 == to.line && span.from >= to.ch) &&\n              (!filter || filter(span.marker)))\n            { found.push(span.marker.parent || span.marker); }\n        } }\n        ++lineNo$$1;\n      });\n      return found\n    },\n    getAllMarks: function() {\n      var markers = [];\n      this.iter(function (line) {\n        var sps = line.markedSpans;\n        if (sps) { for (var i = 0; i < sps.length; ++i)\n          { if (sps[i].from != null) { markers.push(sps[i].marker); } } }\n      });\n      return markers\n    },\n\n    posFromIndex: function(off) {\n      var ch, lineNo$$1 = this.first, sepSize = this.lineSeparator().length;\n      this.iter(function (line) {\n        var sz = line.text.length + sepSize;\n        if (sz > off) { ch = off; return true }\n        off -= sz;\n        ++lineNo$$1;\n      });\n      return clipPos(this, Pos(lineNo$$1, ch))\n    },\n    indexFromPos: function (coords) {\n      coords = clipPos(this, coords);\n      var index = coords.ch;\n      if (coords.line < this.first || coords.ch < 0) { return 0 }\n      var sepSize = this.lineSeparator().length;\n      this.iter(this.first, coords.line, function (line) { // iter aborts when callback returns a truthy value\n        index += line.text.length + sepSize;\n      });\n      return index\n    },\n\n    copy: function(copyHistory) {\n      var doc = new Doc(getLines(this, this.first, this.first + this.size),\n                        this.modeOption, this.first, this.lineSep, this.direction);\n      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;\n      doc.sel = this.sel;\n      doc.extend = false;\n      if (copyHistory) {\n        doc.history.undoDepth = this.history.undoDepth;\n        doc.setHistory(this.getHistory());\n      }\n      return doc\n    },\n\n    linkedDoc: function(options) {\n      if (!options) { options = {}; }\n      var from = this.first, to = this.first + this.size;\n      if (options.from != null && options.from > from) { from = options.from; }\n      if (options.to != null && options.to < to) { to = options.to; }\n      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);\n      if (options.sharedHist) { copy.history = this.history\n      ; }(this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});\n      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];\n      copySharedMarkers(copy, findSharedMarkers(this));\n      return copy\n    },\n    unlinkDoc: function(other) {\n      var this$1 = this;\n\n      if (other instanceof CodeMirror) { other = other.doc; }\n      if (this.linked) { for (var i = 0; i < this.linked.length; ++i) {\n        var link = this$1.linked[i];\n        if (link.doc != other) { continue }\n        this$1.linked.splice(i, 1);\n        other.unlinkDoc(this$1);\n        detachSharedMarkers(findSharedMarkers(this$1));\n        break\n      } }\n      // If the histories were shared, split them again\n      if (other.history == this.history) {\n        var splitIds = [other.id];\n        linkedDocs(other, function (doc) { return splitIds.push(doc.id); }, true);\n        other.history = new History(null);\n        other.history.done = copyHistoryArray(this.history.done, splitIds);\n        other.history.undone = copyHistoryArray(this.history.undone, splitIds);\n      }\n    },\n    iterLinkedDocs: function(f) {linkedDocs(this, f);},\n\n    getMode: function() {return this.mode},\n    getEditor: function() {return this.cm},\n\n    splitLines: function(str) {\n      if (this.lineSep) { return str.split(this.lineSep) }\n      return splitLinesAuto(str)\n    },\n    lineSeparator: function() { return this.lineSep || \"\\n\" },\n\n    setDirection: docMethodOp(function (dir) {\n      if (dir != \"rtl\") { dir = \"ltr\"; }\n      if (dir == this.direction) { return }\n      this.direction = dir;\n      this.iter(function (line) { return line.order = null; });\n      if (this.cm) { directionChanged(this.cm); }\n    })\n  });\n\n  // Public alias.\n  Doc.prototype.eachLine = Doc.prototype.iter;\n\n  // Kludge to work around strange IE behavior where it'll sometimes\n  // re-fire a series of drag-related events right after the drop (#1551)\n  var lastDrop = 0;\n\n  function onDrop(e) {\n    var cm = this;\n    clearDragCursor(cm);\n    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))\n      { return }\n    e_preventDefault(e);\n    if (ie) { lastDrop = +new Date; }\n    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;\n    if (!pos || cm.isReadOnly()) { return }\n    // Might be a file drop, in which case we simply extract the text\n    // and insert it.\n    if (files && files.length && window.FileReader && window.File) {\n      var n = files.length, text = Array(n), read = 0;\n      var loadFile = function (file, i) {\n        if (cm.options.allowDropFileTypes &&\n            indexOf(cm.options.allowDropFileTypes, file.type) == -1)\n          { return }\n\n        var reader = new FileReader;\n        reader.onload = operation(cm, function () {\n          var content = reader.result;\n          if (/[\\x00-\\x08\\x0e-\\x1f]{2}/.test(content)) { content = \"\"; }\n          text[i] = content;\n          if (++read == n) {\n            pos = clipPos(cm.doc, pos);\n            var change = {from: pos, to: pos,\n                          text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),\n                          origin: \"paste\"};\n            makeChange(cm.doc, change);\n            setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));\n          }\n        });\n        reader.readAsText(file);\n      };\n      for (var i = 0; i < n; ++i) { loadFile(files[i], i); }\n    } else { // Normal drop\n      // Don't do a replace if the drop happened inside of the selected text.\n      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {\n        cm.state.draggingText(e);\n        // Ensure the editor is re-focused\n        setTimeout(function () { return cm.display.input.focus(); }, 20);\n        return\n      }\n      try {\n        var text$1 = e.dataTransfer.getData(\"Text\");\n        if (text$1) {\n          var selected;\n          if (cm.state.draggingText && !cm.state.draggingText.copy)\n            { selected = cm.listSelections(); }\n          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));\n          if (selected) { for (var i$1 = 0; i$1 < selected.length; ++i$1)\n            { replaceRange(cm.doc, \"\", selected[i$1].anchor, selected[i$1].head, \"drag\"); } }\n          cm.replaceSelection(text$1, \"around\", \"paste\");\n          cm.display.input.focus();\n        }\n      }\n      catch(e){}\n    }\n  }\n\n  function onDragStart(cm, e) {\n    if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return }\n    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) { return }\n\n    e.dataTransfer.setData(\"Text\", cm.getSelection());\n    e.dataTransfer.effectAllowed = \"copyMove\";\n\n    // Use dummy image instead of default browsers image.\n    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.\n    if (e.dataTransfer.setDragImage && !safari) {\n      var img = elt(\"img\", null, null, \"position: fixed; left: 0; top: 0;\");\n      img.src = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\n      if (presto) {\n        img.width = img.height = 1;\n        cm.display.wrapper.appendChild(img);\n        // Force a relayout, or Opera won't use our image for some obscure reason\n        img._top = img.offsetTop;\n      }\n      e.dataTransfer.setDragImage(img, 0, 0);\n      if (presto) { img.parentNode.removeChild(img); }\n    }\n  }\n\n  function onDragOver(cm, e) {\n    var pos = posFromMouse(cm, e);\n    if (!pos) { return }\n    var frag = document.createDocumentFragment();\n    drawSelectionCursor(cm, pos, frag);\n    if (!cm.display.dragCursor) {\n      cm.display.dragCursor = elt(\"div\", null, \"CodeMirror-cursors CodeMirror-dragcursors\");\n      cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);\n    }\n    removeChildrenAndAdd(cm.display.dragCursor, frag);\n  }\n\n  function clearDragCursor(cm) {\n    if (cm.display.dragCursor) {\n      cm.display.lineSpace.removeChild(cm.display.dragCursor);\n      cm.display.dragCursor = null;\n    }\n  }\n\n  // These must be handled carefully, because naively registering a\n  // handler for each editor will cause the editors to never be\n  // garbage collected.\n\n  function forEachCodeMirror(f) {\n    if (!document.getElementsByClassName) { return }\n    var byClass = document.getElementsByClassName(\"CodeMirror\"), editors = [];\n    for (var i = 0; i < byClass.length; i++) {\n      var cm = byClass[i].CodeMirror;\n      if (cm) { editors.push(cm); }\n    }\n    if (editors.length) { editors[0].operation(function () {\n      for (var i = 0; i < editors.length; i++) { f(editors[i]); }\n    }); }\n  }\n\n  var globalsRegistered = false;\n  function ensureGlobalHandlers() {\n    if (globalsRegistered) { return }\n    registerGlobalHandlers();\n    globalsRegistered = true;\n  }\n  function registerGlobalHandlers() {\n    // When the window resizes, we need to refresh active editors.\n    var resizeTimer;\n    on(window, \"resize\", function () {\n      if (resizeTimer == null) { resizeTimer = setTimeout(function () {\n        resizeTimer = null;\n        forEachCodeMirror(onResize);\n      }, 100); }\n    });\n    // When the window loses focus, we want to show the editor as blurred\n    on(window, \"blur\", function () { return forEachCodeMirror(onBlur); });\n  }\n  // Called when the window resizes\n  function onResize(cm) {\n    var d = cm.display;\n    // Might be a text scaling operation, clear size caches.\n    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n    d.scrollbarsClipped = false;\n    cm.setSize();\n  }\n\n  var keyNames = {\n    3: \"Pause\", 8: \"Backspace\", 9: \"Tab\", 13: \"Enter\", 16: \"Shift\", 17: \"Ctrl\", 18: \"Alt\",\n    19: \"Pause\", 20: \"CapsLock\", 27: \"Esc\", 32: \"Space\", 33: \"PageUp\", 34: \"PageDown\", 35: \"End\",\n    36: \"Home\", 37: \"Left\", 38: \"Up\", 39: \"Right\", 40: \"Down\", 44: \"PrintScrn\", 45: \"Insert\",\n    46: \"Delete\", 59: \";\", 61: \"=\", 91: \"Mod\", 92: \"Mod\", 93: \"Mod\",\n    106: \"*\", 107: \"=\", 109: \"-\", 110: \".\", 111: \"/\", 127: \"Delete\", 145: \"ScrollLock\",\n    173: \"-\", 186: \";\", 187: \"=\", 188: \",\", 189: \"-\", 190: \".\", 191: \"/\", 192: \"`\", 219: \"[\", 220: \"\\\\\",\n    221: \"]\", 222: \"'\", 63232: \"Up\", 63233: \"Down\", 63234: \"Left\", 63235: \"Right\", 63272: \"Delete\",\n    63273: \"Home\", 63275: \"End\", 63276: \"PageUp\", 63277: \"PageDown\", 63302: \"Insert\"\n  };\n\n  // Number keys\n  for (var i = 0; i < 10; i++) { keyNames[i + 48] = keyNames[i + 96] = String(i); }\n  // Alphabetic keys\n  for (var i$1 = 65; i$1 <= 90; i$1++) { keyNames[i$1] = String.fromCharCode(i$1); }\n  // Function keys\n  for (var i$2 = 1; i$2 <= 12; i$2++) { keyNames[i$2 + 111] = keyNames[i$2 + 63235] = \"F\" + i$2; }\n\n  var keyMap = {};\n\n  keyMap.basic = {\n    \"Left\": \"goCharLeft\", \"Right\": \"goCharRight\", \"Up\": \"goLineUp\", \"Down\": \"goLineDown\",\n    \"End\": \"goLineEnd\", \"Home\": \"goLineStartSmart\", \"PageUp\": \"goPageUp\", \"PageDown\": \"goPageDown\",\n    \"Delete\": \"delCharAfter\", \"Backspace\": \"delCharBefore\", \"Shift-Backspace\": \"delCharBefore\",\n    \"Tab\": \"defaultTab\", \"Shift-Tab\": \"indentAuto\",\n    \"Enter\": \"newlineAndIndent\", \"Insert\": \"toggleOverwrite\",\n    \"Esc\": \"singleSelection\"\n  };\n  // Note that the save and find-related commands aren't defined by\n  // default. User code or addons can define them. Unknown commands\n  // are simply ignored.\n  keyMap.pcDefault = {\n    \"Ctrl-A\": \"selectAll\", \"Ctrl-D\": \"deleteLine\", \"Ctrl-Z\": \"undo\", \"Shift-Ctrl-Z\": \"redo\", \"Ctrl-Y\": \"redo\",\n    \"Ctrl-Home\": \"goDocStart\", \"Ctrl-End\": \"goDocEnd\", \"Ctrl-Up\": \"goLineUp\", \"Ctrl-Down\": \"goLineDown\",\n    \"Ctrl-Left\": \"goGroupLeft\", \"Ctrl-Right\": \"goGroupRight\", \"Alt-Left\": \"goLineStart\", \"Alt-Right\": \"goLineEnd\",\n    \"Ctrl-Backspace\": \"delGroupBefore\", \"Ctrl-Delete\": \"delGroupAfter\", \"Ctrl-S\": \"save\", \"Ctrl-F\": \"find\",\n    \"Ctrl-G\": \"findNext\", \"Shift-Ctrl-G\": \"findPrev\", \"Shift-Ctrl-F\": \"replace\", \"Shift-Ctrl-R\": \"replaceAll\",\n    \"Ctrl-[\": \"indentLess\", \"Ctrl-]\": \"indentMore\",\n    \"Ctrl-U\": \"undoSelection\", \"Shift-Ctrl-U\": \"redoSelection\", \"Alt-U\": \"redoSelection\",\n    \"fallthrough\": \"basic\"\n  };\n  // Very basic readline/emacs-style bindings, which are standard on Mac.\n  keyMap.emacsy = {\n    \"Ctrl-F\": \"goCharRight\", \"Ctrl-B\": \"goCharLeft\", \"Ctrl-P\": \"goLineUp\", \"Ctrl-N\": \"goLineDown\",\n    \"Alt-F\": \"goWordRight\", \"Alt-B\": \"goWordLeft\", \"Ctrl-A\": \"goLineStart\", \"Ctrl-E\": \"goLineEnd\",\n    \"Ctrl-V\": \"goPageDown\", \"Shift-Ctrl-V\": \"goPageUp\", \"Ctrl-D\": \"delCharAfter\", \"Ctrl-H\": \"delCharBefore\",\n    \"Alt-D\": \"delWordAfter\", \"Alt-Backspace\": \"delWordBefore\", \"Ctrl-K\": \"killLine\", \"Ctrl-T\": \"transposeChars\",\n    \"Ctrl-O\": \"openLine\"\n  };\n  keyMap.macDefault = {\n    \"Cmd-A\": \"selectAll\", \"Cmd-D\": \"deleteLine\", \"Cmd-Z\": \"undo\", \"Shift-Cmd-Z\": \"redo\", \"Cmd-Y\": \"redo\",\n    \"Cmd-Home\": \"goDocStart\", \"Cmd-Up\": \"goDocStart\", \"Cmd-End\": \"goDocEnd\", \"Cmd-Down\": \"goDocEnd\", \"Alt-Left\": \"goGroupLeft\",\n    \"Alt-Right\": \"goGroupRight\", \"Cmd-Left\": \"goLineLeft\", \"Cmd-Right\": \"goLineRight\", \"Alt-Backspace\": \"delGroupBefore\",\n    \"Ctrl-Alt-Backspace\": \"delGroupAfter\", \"Alt-Delete\": \"delGroupAfter\", \"Cmd-S\": \"save\", \"Cmd-F\": \"find\",\n    \"Cmd-G\": \"findNext\", \"Shift-Cmd-G\": \"findPrev\", \"Cmd-Alt-F\": \"replace\", \"Shift-Cmd-Alt-F\": \"replaceAll\",\n    \"Cmd-[\": \"indentLess\", \"Cmd-]\": \"indentMore\", \"Cmd-Backspace\": \"delWrappedLineLeft\", \"Cmd-Delete\": \"delWrappedLineRight\",\n    \"Cmd-U\": \"undoSelection\", \"Shift-Cmd-U\": \"redoSelection\", \"Ctrl-Up\": \"goDocStart\", \"Ctrl-Down\": \"goDocEnd\",\n    \"fallthrough\": [\"basic\", \"emacsy\"]\n  };\n  keyMap[\"default\"] = mac ? keyMap.macDefault : keyMap.pcDefault;\n\n  // KEYMAP DISPATCH\n\n  function normalizeKeyName(name) {\n    var parts = name.split(/-(?!$)/);\n    name = parts[parts.length - 1];\n    var alt, ctrl, shift, cmd;\n    for (var i = 0; i < parts.length - 1; i++) {\n      var mod = parts[i];\n      if (/^(cmd|meta|m)$/i.test(mod)) { cmd = true; }\n      else if (/^a(lt)?$/i.test(mod)) { alt = true; }\n      else if (/^(c|ctrl|control)$/i.test(mod)) { ctrl = true; }\n      else if (/^s(hift)?$/i.test(mod)) { shift = true; }\n      else { throw new Error(\"Unrecognized modifier name: \" + mod) }\n    }\n    if (alt) { name = \"Alt-\" + name; }\n    if (ctrl) { name = \"Ctrl-\" + name; }\n    if (cmd) { name = \"Cmd-\" + name; }\n    if (shift) { name = \"Shift-\" + name; }\n    return name\n  }\n\n  // This is a kludge to keep keymaps mostly working as raw objects\n  // (backwards compatibility) while at the same time support features\n  // like normalization and multi-stroke key bindings. It compiles a\n  // new normalized keymap, and then updates the old object to reflect\n  // this.\n  function normalizeKeyMap(keymap) {\n    var copy = {};\n    for (var keyname in keymap) { if (keymap.hasOwnProperty(keyname)) {\n      var value = keymap[keyname];\n      if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) { continue }\n      if (value == \"...\") { delete keymap[keyname]; continue }\n\n      var keys = map(keyname.split(\" \"), normalizeKeyName);\n      for (var i = 0; i < keys.length; i++) {\n        var val = (void 0), name = (void 0);\n        if (i == keys.length - 1) {\n          name = keys.join(\" \");\n          val = value;\n        } else {\n          name = keys.slice(0, i + 1).join(\" \");\n          val = \"...\";\n        }\n        var prev = copy[name];\n        if (!prev) { copy[name] = val; }\n        else if (prev != val) { throw new Error(\"Inconsistent bindings for \" + name) }\n      }\n      delete keymap[keyname];\n    } }\n    for (var prop in copy) { keymap[prop] = copy[prop]; }\n    return keymap\n  }\n\n  function lookupKey(key, map$$1, handle, context) {\n    map$$1 = getKeyMap(map$$1);\n    var found = map$$1.call ? map$$1.call(key, context) : map$$1[key];\n    if (found === false) { return \"nothing\" }\n    if (found === \"...\") { return \"multi\" }\n    if (found != null && handle(found)) { return \"handled\" }\n\n    if (map$$1.fallthrough) {\n      if (Object.prototype.toString.call(map$$1.fallthrough) != \"[object Array]\")\n        { return lookupKey(key, map$$1.fallthrough, handle, context) }\n      for (var i = 0; i < map$$1.fallthrough.length; i++) {\n        var result = lookupKey(key, map$$1.fallthrough[i], handle, context);\n        if (result) { return result }\n      }\n    }\n  }\n\n  // Modifier key presses don't count as 'real' key presses for the\n  // purpose of keymap fallthrough.\n  function isModifierKey(value) {\n    var name = typeof value == \"string\" ? value : keyNames[value.keyCode];\n    return name == \"Ctrl\" || name == \"Alt\" || name == \"Shift\" || name == \"Mod\"\n  }\n\n  function addModifierNames(name, event, noShift) {\n    var base = name;\n    if (event.altKey && base != \"Alt\") { name = \"Alt-\" + name; }\n    if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != \"Ctrl\") { name = \"Ctrl-\" + name; }\n    if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != \"Cmd\") { name = \"Cmd-\" + name; }\n    if (!noShift && event.shiftKey && base != \"Shift\") { name = \"Shift-\" + name; }\n    return name\n  }\n\n  // Look up the name of a key as indicated by an event object.\n  function keyName(event, noShift) {\n    if (presto && event.keyCode == 34 && event[\"char\"]) { return false }\n    var name = keyNames[event.keyCode];\n    if (name == null || event.altGraphKey) { return false }\n    // Ctrl-ScrollLock has keyCode 3, same as Ctrl-Pause,\n    // so we'll use event.code when available (Chrome 48+, FF 38+, Safari 10.1+)\n    if (event.keyCode == 3 && event.code) { name = event.code; }\n    return addModifierNames(name, event, noShift)\n  }\n\n  function getKeyMap(val) {\n    return typeof val == \"string\" ? keyMap[val] : val\n  }\n\n  // Helper for deleting text near the selection(s), used to implement\n  // backspace, delete, and similar functionality.\n  function deleteNearSelection(cm, compute) {\n    var ranges = cm.doc.sel.ranges, kill = [];\n    // Build up a set of ranges to kill first, merging overlapping\n    // ranges.\n    for (var i = 0; i < ranges.length; i++) {\n      var toKill = compute(ranges[i]);\n      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {\n        var replaced = kill.pop();\n        if (cmp(replaced.from, toKill.from) < 0) {\n          toKill.from = replaced.from;\n          break\n        }\n      }\n      kill.push(toKill);\n    }\n    // Next, remove those actual ranges.\n    runInOp(cm, function () {\n      for (var i = kill.length - 1; i >= 0; i--)\n        { replaceRange(cm.doc, \"\", kill[i].from, kill[i].to, \"+delete\"); }\n      ensureCursorVisible(cm);\n    });\n  }\n\n  function moveCharLogically(line, ch, dir) {\n    var target = skipExtendingChars(line.text, ch + dir, dir);\n    return target < 0 || target > line.text.length ? null : target\n  }\n\n  function moveLogically(line, start, dir) {\n    var ch = moveCharLogically(line, start.ch, dir);\n    return ch == null ? null : new Pos(start.line, ch, dir < 0 ? \"after\" : \"before\")\n  }\n\n  function endOfLine(visually, cm, lineObj, lineNo, dir) {\n    if (visually) {\n      var order = getOrder(lineObj, cm.doc.direction);\n      if (order) {\n        var part = dir < 0 ? lst(order) : order[0];\n        var moveInStorageOrder = (dir < 0) == (part.level == 1);\n        var sticky = moveInStorageOrder ? \"after\" : \"before\";\n        var ch;\n        // With a wrapped rtl chunk (possibly spanning multiple bidi parts),\n        // it could be that the last bidi part is not on the last visual line,\n        // since visual lines contain content order-consecutive chunks.\n        // Thus, in rtl, we are looking for the first (content-order) character\n        // in the rtl chunk that is on the last line (that is, the same line\n        // as the last (content-order) character).\n        if (part.level > 0 || cm.doc.direction == \"rtl\") {\n          var prep = prepareMeasureForLine(cm, lineObj);\n          ch = dir < 0 ? lineObj.text.length - 1 : 0;\n          var targetTop = measureCharPrepared(cm, prep, ch).top;\n          ch = findFirst(function (ch) { return measureCharPrepared(cm, prep, ch).top == targetTop; }, (dir < 0) == (part.level == 1) ? part.from : part.to - 1, ch);\n          if (sticky == \"before\") { ch = moveCharLogically(lineObj, ch, 1); }\n        } else { ch = dir < 0 ? part.to : part.from; }\n        return new Pos(lineNo, ch, sticky)\n      }\n    }\n    return new Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? \"before\" : \"after\")\n  }\n\n  function moveVisually(cm, line, start, dir) {\n    var bidi = getOrder(line, cm.doc.direction);\n    if (!bidi) { return moveLogically(line, start, dir) }\n    if (start.ch >= line.text.length) {\n      start.ch = line.text.length;\n      start.sticky = \"before\";\n    } else if (start.ch <= 0) {\n      start.ch = 0;\n      start.sticky = \"after\";\n    }\n    var partPos = getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos];\n    if (cm.doc.direction == \"ltr\" && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {\n      // Case 1: We move within an ltr part in an ltr editor. Even with wrapped lines,\n      // nothing interesting happens.\n      return moveLogically(line, start, dir)\n    }\n\n    var mv = function (pos, dir) { return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir); };\n    var prep;\n    var getWrappedLineExtent = function (ch) {\n      if (!cm.options.lineWrapping) { return {begin: 0, end: line.text.length} }\n      prep = prep || prepareMeasureForLine(cm, line);\n      return wrappedLineExtentChar(cm, line, prep, ch)\n    };\n    var wrappedLineExtent = getWrappedLineExtent(start.sticky == \"before\" ? mv(start, -1) : start.ch);\n\n    if (cm.doc.direction == \"rtl\" || part.level == 1) {\n      var moveInStorageOrder = (part.level == 1) == (dir < 0);\n      var ch = mv(start, moveInStorageOrder ? 1 : -1);\n      if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent.begin : ch <= part.to && ch <= wrappedLineExtent.end)) {\n        // Case 2: We move within an rtl part or in an rtl editor on the same visual line\n        var sticky = moveInStorageOrder ? \"before\" : \"after\";\n        return new Pos(start.line, ch, sticky)\n      }\n    }\n\n    // Case 3: Could not move within this bidi part in this visual line, so leave\n    // the current bidi part\n\n    var searchInVisualLine = function (partPos, dir, wrappedLineExtent) {\n      var getRes = function (ch, moveInStorageOrder) { return moveInStorageOrder\n        ? new Pos(start.line, mv(ch, 1), \"before\")\n        : new Pos(start.line, ch, \"after\"); };\n\n      for (; partPos >= 0 && partPos < bidi.length; partPos += dir) {\n        var part = bidi[partPos];\n        var moveInStorageOrder = (dir > 0) == (part.level != 1);\n        var ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);\n        if (part.from <= ch && ch < part.to) { return getRes(ch, moveInStorageOrder) }\n        ch = moveInStorageOrder ? part.from : mv(part.to, -1);\n        if (wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) { return getRes(ch, moveInStorageOrder) }\n      }\n    };\n\n    // Case 3a: Look for other bidi parts on the same visual line\n    var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);\n    if (res) { return res }\n\n    // Case 3b: Look for other bidi parts on the next visual line\n    var nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);\n    if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {\n      res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));\n      if (res) { return res }\n    }\n\n    // Case 4: Nowhere to move\n    return null\n  }\n\n  // Commands are parameter-less actions that can be performed on an\n  // editor, mostly used for keybindings.\n  var commands = {\n    selectAll: selectAll,\n    singleSelection: function (cm) { return cm.setSelection(cm.getCursor(\"anchor\"), cm.getCursor(\"head\"), sel_dontScroll); },\n    killLine: function (cm) { return deleteNearSelection(cm, function (range) {\n      if (range.empty()) {\n        var len = getLine(cm.doc, range.head.line).text.length;\n        if (range.head.ch == len && range.head.line < cm.lastLine())\n          { return {from: range.head, to: Pos(range.head.line + 1, 0)} }\n        else\n          { return {from: range.head, to: Pos(range.head.line, len)} }\n      } else {\n        return {from: range.from(), to: range.to()}\n      }\n    }); },\n    deleteLine: function (cm) { return deleteNearSelection(cm, function (range) { return ({\n      from: Pos(range.from().line, 0),\n      to: clipPos(cm.doc, Pos(range.to().line + 1, 0))\n    }); }); },\n    delLineLeft: function (cm) { return deleteNearSelection(cm, function (range) { return ({\n      from: Pos(range.from().line, 0), to: range.from()\n    }); }); },\n    delWrappedLineLeft: function (cm) { return deleteNearSelection(cm, function (range) {\n      var top = cm.charCoords(range.head, \"div\").top + 5;\n      var leftPos = cm.coordsChar({left: 0, top: top}, \"div\");\n      return {from: leftPos, to: range.from()}\n    }); },\n    delWrappedLineRight: function (cm) { return deleteNearSelection(cm, function (range) {\n      var top = cm.charCoords(range.head, \"div\").top + 5;\n      var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\");\n      return {from: range.from(), to: rightPos }\n    }); },\n    undo: function (cm) { return cm.undo(); },\n    redo: function (cm) { return cm.redo(); },\n    undoSelection: function (cm) { return cm.undoSelection(); },\n    redoSelection: function (cm) { return cm.redoSelection(); },\n    goDocStart: function (cm) { return cm.extendSelection(Pos(cm.firstLine(), 0)); },\n    goDocEnd: function (cm) { return cm.extendSelection(Pos(cm.lastLine())); },\n    goLineStart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStart(cm, range.head.line); },\n      {origin: \"+move\", bias: 1}\n    ); },\n    goLineStartSmart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStartSmart(cm, range.head); },\n      {origin: \"+move\", bias: 1}\n    ); },\n    goLineEnd: function (cm) { return cm.extendSelectionsBy(function (range) { return lineEnd(cm, range.head.line); },\n      {origin: \"+move\", bias: -1}\n    ); },\n    goLineRight: function (cm) { return cm.extendSelectionsBy(function (range) {\n      var top = cm.cursorCoords(range.head, \"div\").top + 5;\n      return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\")\n    }, sel_move); },\n    goLineLeft: function (cm) { return cm.extendSelectionsBy(function (range) {\n      var top = cm.cursorCoords(range.head, \"div\").top + 5;\n      return cm.coordsChar({left: 0, top: top}, \"div\")\n    }, sel_move); },\n    goLineLeftSmart: function (cm) { return cm.extendSelectionsBy(function (range) {\n      var top = cm.cursorCoords(range.head, \"div\").top + 5;\n      var pos = cm.coordsChar({left: 0, top: top}, \"div\");\n      if (pos.ch < cm.getLine(pos.line).search(/\\S/)) { return lineStartSmart(cm, range.head) }\n      return pos\n    }, sel_move); },\n    goLineUp: function (cm) { return cm.moveV(-1, \"line\"); },\n    goLineDown: function (cm) { return cm.moveV(1, \"line\"); },\n    goPageUp: function (cm) { return cm.moveV(-1, \"page\"); },\n    goPageDown: function (cm) { return cm.moveV(1, \"page\"); },\n    goCharLeft: function (cm) { return cm.moveH(-1, \"char\"); },\n    goCharRight: function (cm) { return cm.moveH(1, \"char\"); },\n    goColumnLeft: function (cm) { return cm.moveH(-1, \"column\"); },\n    goColumnRight: function (cm) { return cm.moveH(1, \"column\"); },\n    goWordLeft: function (cm) { return cm.moveH(-1, \"word\"); },\n    goGroupRight: function (cm) { return cm.moveH(1, \"group\"); },\n    goGroupLeft: function (cm) { return cm.moveH(-1, \"group\"); },\n    goWordRight: function (cm) { return cm.moveH(1, \"word\"); },\n    delCharBefore: function (cm) { return cm.deleteH(-1, \"char\"); },\n    delCharAfter: function (cm) { return cm.deleteH(1, \"char\"); },\n    delWordBefore: function (cm) { return cm.deleteH(-1, \"word\"); },\n    delWordAfter: function (cm) { return cm.deleteH(1, \"word\"); },\n    delGroupBefore: function (cm) { return cm.deleteH(-1, \"group\"); },\n    delGroupAfter: function (cm) { return cm.deleteH(1, \"group\"); },\n    indentAuto: function (cm) { return cm.indentSelection(\"smart\"); },\n    indentMore: function (cm) { return cm.indentSelection(\"add\"); },\n    indentLess: function (cm) { return cm.indentSelection(\"subtract\"); },\n    insertTab: function (cm) { return cm.replaceSelection(\"\\t\"); },\n    insertSoftTab: function (cm) {\n      var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;\n      for (var i = 0; i < ranges.length; i++) {\n        var pos = ranges[i].from();\n        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);\n        spaces.push(spaceStr(tabSize - col % tabSize));\n      }\n      cm.replaceSelections(spaces);\n    },\n    defaultTab: function (cm) {\n      if (cm.somethingSelected()) { cm.indentSelection(\"add\"); }\n      else { cm.execCommand(\"insertTab\"); }\n    },\n    // Swap the two chars left and right of each selection's head.\n    // Move cursor behind the two swapped characters afterwards.\n    //\n    // Doesn't consider line feeds a character.\n    // Doesn't scan more than one line above to find a character.\n    // Doesn't do anything on an empty line.\n    // Doesn't do anything with non-empty selections.\n    transposeChars: function (cm) { return runInOp(cm, function () {\n      var ranges = cm.listSelections(), newSel = [];\n      for (var i = 0; i < ranges.length; i++) {\n        if (!ranges[i].empty()) { continue }\n        var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;\n        if (line) {\n          if (cur.ch == line.length) { cur = new Pos(cur.line, cur.ch - 1); }\n          if (cur.ch > 0) {\n            cur = new Pos(cur.line, cur.ch + 1);\n            cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),\n                            Pos(cur.line, cur.ch - 2), cur, \"+transpose\");\n          } else if (cur.line > cm.doc.first) {\n            var prev = getLine(cm.doc, cur.line - 1).text;\n            if (prev) {\n              cur = new Pos(cur.line, 1);\n              cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +\n                              prev.charAt(prev.length - 1),\n                              Pos(cur.line - 1, prev.length - 1), cur, \"+transpose\");\n            }\n          }\n        }\n        newSel.push(new Range(cur, cur));\n      }\n      cm.setSelections(newSel);\n    }); },\n    newlineAndIndent: function (cm) { return runInOp(cm, function () {\n      var sels = cm.listSelections();\n      for (var i = sels.length - 1; i >= 0; i--)\n        { cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, \"+input\"); }\n      sels = cm.listSelections();\n      for (var i$1 = 0; i$1 < sels.length; i$1++)\n        { cm.indentLine(sels[i$1].from().line, null, true); }\n      ensureCursorVisible(cm);\n    }); },\n    openLine: function (cm) { return cm.replaceSelection(\"\\n\", \"start\"); },\n    toggleOverwrite: function (cm) { return cm.toggleOverwrite(); }\n  };\n\n\n  function lineStart(cm, lineN) {\n    var line = getLine(cm.doc, lineN);\n    var visual = visualLine(line);\n    if (visual != line) { lineN = lineNo(visual); }\n    return endOfLine(true, cm, visual, lineN, 1)\n  }\n  function lineEnd(cm, lineN) {\n    var line = getLine(cm.doc, lineN);\n    var visual = visualLineEnd(line);\n    if (visual != line) { lineN = lineNo(visual); }\n    return endOfLine(true, cm, line, lineN, -1)\n  }\n  function lineStartSmart(cm, pos) {\n    var start = lineStart(cm, pos.line);\n    var line = getLine(cm.doc, start.line);\n    var order = getOrder(line, cm.doc.direction);\n    if (!order || order[0].level == 0) {\n      var firstNonWS = Math.max(0, line.text.search(/\\S/));\n      var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;\n      return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky)\n    }\n    return start\n  }\n\n  // Run a handler that was bound to a key.\n  function doHandleBinding(cm, bound, dropShift) {\n    if (typeof bound == \"string\") {\n      bound = commands[bound];\n      if (!bound) { return false }\n    }\n    // Ensure previous input has been read, so that the handler sees a\n    // consistent view of the document\n    cm.display.input.ensurePolled();\n    var prevShift = cm.display.shift, done = false;\n    try {\n      if (cm.isReadOnly()) { cm.state.suppressEdits = true; }\n      if (dropShift) { cm.display.shift = false; }\n      done = bound(cm) != Pass;\n    } finally {\n      cm.display.shift = prevShift;\n      cm.state.suppressEdits = false;\n    }\n    return done\n  }\n\n  function lookupKeyForEditor(cm, name, handle) {\n    for (var i = 0; i < cm.state.keyMaps.length; i++) {\n      var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);\n      if (result) { return result }\n    }\n    return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))\n      || lookupKey(name, cm.options.keyMap, handle, cm)\n  }\n\n  // Note that, despite the name, this function is also used to check\n  // for bound mouse clicks.\n\n  var stopSeq = new Delayed;\n\n  function dispatchKey(cm, name, e, handle) {\n    var seq = cm.state.keySeq;\n    if (seq) {\n      if (isModifierKey(name)) { return \"handled\" }\n      if (/\\'$/.test(name))\n        { cm.state.keySeq = null; }\n      else\n        { stopSeq.set(50, function () {\n          if (cm.state.keySeq == seq) {\n            cm.state.keySeq = null;\n            cm.display.input.reset();\n          }\n        }); }\n      if (dispatchKeyInner(cm, seq + \" \" + name, e, handle)) { return true }\n    }\n    return dispatchKeyInner(cm, name, e, handle)\n  }\n\n  function dispatchKeyInner(cm, name, e, handle) {\n    var result = lookupKeyForEditor(cm, name, handle);\n\n    if (result == \"multi\")\n      { cm.state.keySeq = name; }\n    if (result == \"handled\")\n      { signalLater(cm, \"keyHandled\", cm, name, e); }\n\n    if (result == \"handled\" || result == \"multi\") {\n      e_preventDefault(e);\n      restartBlink(cm);\n    }\n\n    return !!result\n  }\n\n  // Handle a key from the keydown event.\n  function handleKeyBinding(cm, e) {\n    var name = keyName(e, true);\n    if (!name) { return false }\n\n    if (e.shiftKey && !cm.state.keySeq) {\n      // First try to resolve full name (including 'Shift-'). Failing\n      // that, see if there is a cursor-motion command (starting with\n      // 'go') bound to the keyname without 'Shift-'.\n      return dispatchKey(cm, \"Shift-\" + name, e, function (b) { return doHandleBinding(cm, b, true); })\n          || dispatchKey(cm, name, e, function (b) {\n               if (typeof b == \"string\" ? /^go[A-Z]/.test(b) : b.motion)\n                 { return doHandleBinding(cm, b) }\n             })\n    } else {\n      return dispatchKey(cm, name, e, function (b) { return doHandleBinding(cm, b); })\n    }\n  }\n\n  // Handle a key from the keypress event\n  function handleCharBinding(cm, e, ch) {\n    return dispatchKey(cm, \"'\" + ch + \"'\", e, function (b) { return doHandleBinding(cm, b, true); })\n  }\n\n  var lastStoppedKey = null;\n  function onKeyDown(e) {\n    var cm = this;\n    cm.curOp.focus = activeElt();\n    if (signalDOMEvent(cm, e)) { return }\n    // IE does strange things with escape.\n    if (ie && ie_version < 11 && e.keyCode == 27) { e.returnValue = false; }\n    var code = e.keyCode;\n    cm.display.shift = code == 16 || e.shiftKey;\n    var handled = handleKeyBinding(cm, e);\n    if (presto) {\n      lastStoppedKey = handled ? code : null;\n      // Opera has no cut event... we try to at least catch the key combo\n      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))\n        { cm.replaceSelection(\"\", null, \"cut\"); }\n    }\n\n    // Turn mouse into crosshair when Alt is held on Mac.\n    if (code == 18 && !/\\bCodeMirror-crosshair\\b/.test(cm.display.lineDiv.className))\n      { showCrossHair(cm); }\n  }\n\n  function showCrossHair(cm) {\n    var lineDiv = cm.display.lineDiv;\n    addClass(lineDiv, \"CodeMirror-crosshair\");\n\n    function up(e) {\n      if (e.keyCode == 18 || !e.altKey) {\n        rmClass(lineDiv, \"CodeMirror-crosshair\");\n        off(document, \"keyup\", up);\n        off(document, \"mouseover\", up);\n      }\n    }\n    on(document, \"keyup\", up);\n    on(document, \"mouseover\", up);\n  }\n\n  function onKeyUp(e) {\n    if (e.keyCode == 16) { this.doc.sel.shift = false; }\n    signalDOMEvent(this, e);\n  }\n\n  function onKeyPress(e) {\n    var cm = this;\n    if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) { return }\n    var keyCode = e.keyCode, charCode = e.charCode;\n    if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return}\n    if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) { return }\n    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);\n    // Some browsers fire keypress events for backspace\n    if (ch == \"\\x08\") { return }\n    if (handleCharBinding(cm, e, ch)) { return }\n    cm.display.input.onKeyPress(e);\n  }\n\n  var DOUBLECLICK_DELAY = 400;\n\n  var PastClick = function(time, pos, button) {\n    this.time = time;\n    this.pos = pos;\n    this.button = button;\n  };\n\n  PastClick.prototype.compare = function (time, pos, button) {\n    return this.time + DOUBLECLICK_DELAY > time &&\n      cmp(pos, this.pos) == 0 && button == this.button\n  };\n\n  var lastClick, lastDoubleClick;\n  function clickRepeat(pos, button) {\n    var now = +new Date;\n    if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {\n      lastClick = lastDoubleClick = null;\n      return \"triple\"\n    } else if (lastClick && lastClick.compare(now, pos, button)) {\n      lastDoubleClick = new PastClick(now, pos, button);\n      lastClick = null;\n      return \"double\"\n    } else {\n      lastClick = new PastClick(now, pos, button);\n      lastDoubleClick = null;\n      return \"single\"\n    }\n  }\n\n  // A mouse down can be a single click, double click, triple click,\n  // start of selection drag, start of text drag, new cursor\n  // (ctrl-click), rectangle drag (alt-drag), or xwin\n  // middle-click-paste. Or it might be a click on something we should\n  // not interfere with, such as a scrollbar or widget.\n  function onMouseDown(e) {\n    var cm = this, display = cm.display;\n    if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) { return }\n    display.input.ensurePolled();\n    display.shift = e.shiftKey;\n\n    if (eventInWidget(display, e)) {\n      if (!webkit) {\n        // Briefly turn off draggability, to allow widgets to do\n        // normal dragging things.\n        display.scroller.draggable = false;\n        setTimeout(function () { return display.scroller.draggable = true; }, 100);\n      }\n      return\n    }\n    if (clickInGutter(cm, e)) { return }\n    var pos = posFromMouse(cm, e), button = e_button(e), repeat = pos ? clickRepeat(pos, button) : \"single\";\n    window.focus();\n\n    // #3261: make sure, that we're not starting a second selection\n    if (button == 1 && cm.state.selectingText)\n      { cm.state.selectingText(e); }\n\n    if (pos && handleMappedButton(cm, button, pos, repeat, e)) { return }\n\n    if (button == 1) {\n      if (pos) { leftButtonDown(cm, pos, repeat, e); }\n      else if (e_target(e) == display.scroller) { e_preventDefault(e); }\n    } else if (button == 2) {\n      if (pos) { extendSelection(cm.doc, pos); }\n      setTimeout(function () { return display.input.focus(); }, 20);\n    } else if (button == 3) {\n      if (captureRightClick) { cm.display.input.onContextMenu(e); }\n      else { delayBlurEvent(cm); }\n    }\n  }\n\n  function handleMappedButton(cm, button, pos, repeat, event) {\n    var name = \"Click\";\n    if (repeat == \"double\") { name = \"Double\" + name; }\n    else if (repeat == \"triple\") { name = \"Triple\" + name; }\n    name = (button == 1 ? \"Left\" : button == 2 ? \"Middle\" : \"Right\") + name;\n\n    return dispatchKey(cm,  addModifierNames(name, event), event, function (bound) {\n      if (typeof bound == \"string\") { bound = commands[bound]; }\n      if (!bound) { return false }\n      var done = false;\n      try {\n        if (cm.isReadOnly()) { cm.state.suppressEdits = true; }\n        done = bound(cm, pos) != Pass;\n      } finally {\n        cm.state.suppressEdits = false;\n      }\n      return done\n    })\n  }\n\n  function configureMouse(cm, repeat, event) {\n    var option = cm.getOption(\"configureMouse\");\n    var value = option ? option(cm, repeat, event) : {};\n    if (value.unit == null) {\n      var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;\n      value.unit = rect ? \"rectangle\" : repeat == \"single\" ? \"char\" : repeat == \"double\" ? \"word\" : \"line\";\n    }\n    if (value.extend == null || cm.doc.extend) { value.extend = cm.doc.extend || event.shiftKey; }\n    if (value.addNew == null) { value.addNew = mac ? event.metaKey : event.ctrlKey; }\n    if (value.moveOnDrag == null) { value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey); }\n    return value\n  }\n\n  function leftButtonDown(cm, pos, repeat, event) {\n    if (ie) { setTimeout(bind(ensureFocus, cm), 0); }\n    else { cm.curOp.focus = activeElt(); }\n\n    var behavior = configureMouse(cm, repeat, event);\n\n    var sel = cm.doc.sel, contained;\n    if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&\n        repeat == \"single\" && (contained = sel.contains(pos)) > -1 &&\n        (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) &&\n        (cmp(contained.to(), pos) > 0 || pos.xRel < 0))\n      { leftButtonStartDrag(cm, event, pos, behavior); }\n    else\n      { leftButtonSelect(cm, event, pos, behavior); }\n  }\n\n  // Start a text drag. When it ends, see if any dragging actually\n  // happen, and treat as a click if it didn't.\n  function leftButtonStartDrag(cm, event, pos, behavior) {\n    var display = cm.display, moved = false;\n    var dragEnd = operation(cm, function (e) {\n      if (webkit) { display.scroller.draggable = false; }\n      cm.state.draggingText = false;\n      off(display.wrapper.ownerDocument, \"mouseup\", dragEnd);\n      off(display.wrapper.ownerDocument, \"mousemove\", mouseMove);\n      off(display.scroller, \"dragstart\", dragStart);\n      off(display.scroller, \"drop\", dragEnd);\n      if (!moved) {\n        e_preventDefault(e);\n        if (!behavior.addNew)\n          { extendSelection(cm.doc, pos, null, null, behavior.extend); }\n        // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)\n        if (webkit || ie && ie_version == 9)\n          { setTimeout(function () {display.wrapper.ownerDocument.body.focus(); display.input.focus();}, 20); }\n        else\n          { display.input.focus(); }\n      }\n    });\n    var mouseMove = function(e2) {\n      moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;\n    };\n    var dragStart = function () { return moved = true; };\n    // Let the drag handler handle this.\n    if (webkit) { display.scroller.draggable = true; }\n    cm.state.draggingText = dragEnd;\n    dragEnd.copy = !behavior.moveOnDrag;\n    // IE's approach to draggable\n    if (display.scroller.dragDrop) { display.scroller.dragDrop(); }\n    on(display.wrapper.ownerDocument, \"mouseup\", dragEnd);\n    on(display.wrapper.ownerDocument, \"mousemove\", mouseMove);\n    on(display.scroller, \"dragstart\", dragStart);\n    on(display.scroller, \"drop\", dragEnd);\n\n    delayBlurEvent(cm);\n    setTimeout(function () { return display.input.focus(); }, 20);\n  }\n\n  function rangeForUnit(cm, pos, unit) {\n    if (unit == \"char\") { return new Range(pos, pos) }\n    if (unit == \"word\") { return cm.findWordAt(pos) }\n    if (unit == \"line\") { return new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))) }\n    var result = unit(cm, pos);\n    return new Range(result.from, result.to)\n  }\n\n  // Normal selection, as opposed to text dragging.\n  function leftButtonSelect(cm, event, start, behavior) {\n    var display = cm.display, doc = cm.doc;\n    e_preventDefault(event);\n\n    var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;\n    if (behavior.addNew && !behavior.extend) {\n      ourIndex = doc.sel.contains(start);\n      if (ourIndex > -1)\n        { ourRange = ranges[ourIndex]; }\n      else\n        { ourRange = new Range(start, start); }\n    } else {\n      ourRange = doc.sel.primary();\n      ourIndex = doc.sel.primIndex;\n    }\n\n    if (behavior.unit == \"rectangle\") {\n      if (!behavior.addNew) { ourRange = new Range(start, start); }\n      start = posFromMouse(cm, event, true, true);\n      ourIndex = -1;\n    } else {\n      var range$$1 = rangeForUnit(cm, start, behavior.unit);\n      if (behavior.extend)\n        { ourRange = extendRange(ourRange, range$$1.anchor, range$$1.head, behavior.extend); }\n      else\n        { ourRange = range$$1; }\n    }\n\n    if (!behavior.addNew) {\n      ourIndex = 0;\n      setSelection(doc, new Selection([ourRange], 0), sel_mouse);\n      startSel = doc.sel;\n    } else if (ourIndex == -1) {\n      ourIndex = ranges.length;\n      setSelection(doc, normalizeSelection(cm, ranges.concat([ourRange]), ourIndex),\n                   {scroll: false, origin: \"*mouse\"});\n    } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == \"char\" && !behavior.extend) {\n      setSelection(doc, normalizeSelection(cm, ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),\n                   {scroll: false, origin: \"*mouse\"});\n      startSel = doc.sel;\n    } else {\n      replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);\n    }\n\n    var lastPos = start;\n    function extendTo(pos) {\n      if (cmp(lastPos, pos) == 0) { return }\n      lastPos = pos;\n\n      if (behavior.unit == \"rectangle\") {\n        var ranges = [], tabSize = cm.options.tabSize;\n        var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);\n        var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);\n        var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);\n        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));\n             line <= end; line++) {\n          var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);\n          if (left == right)\n            { ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos))); }\n          else if (text.length > leftPos)\n            { ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize)))); }\n        }\n        if (!ranges.length) { ranges.push(new Range(start, start)); }\n        setSelection(doc, normalizeSelection(cm, startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),\n                     {origin: \"*mouse\", scroll: false});\n        cm.scrollIntoView(pos);\n      } else {\n        var oldRange = ourRange;\n        var range$$1 = rangeForUnit(cm, pos, behavior.unit);\n        var anchor = oldRange.anchor, head;\n        if (cmp(range$$1.anchor, anchor) > 0) {\n          head = range$$1.head;\n          anchor = minPos(oldRange.from(), range$$1.anchor);\n        } else {\n          head = range$$1.anchor;\n          anchor = maxPos(oldRange.to(), range$$1.head);\n        }\n        var ranges$1 = startSel.ranges.slice(0);\n        ranges$1[ourIndex] = bidiSimplify(cm, new Range(clipPos(doc, anchor), head));\n        setSelection(doc, normalizeSelection(cm, ranges$1, ourIndex), sel_mouse);\n      }\n    }\n\n    var editorSize = display.wrapper.getBoundingClientRect();\n    // Used to ensure timeout re-tries don't fire when another extend\n    // happened in the meantime (clearTimeout isn't reliable -- at\n    // least on Chrome, the timeouts still happen even when cleared,\n    // if the clear happens after their scheduled firing time).\n    var counter = 0;\n\n    function extend(e) {\n      var curCount = ++counter;\n      var cur = posFromMouse(cm, e, true, behavior.unit == \"rectangle\");\n      if (!cur) { return }\n      if (cmp(cur, lastPos) != 0) {\n        cm.curOp.focus = activeElt();\n        extendTo(cur);\n        var visible = visibleLines(display, doc);\n        if (cur.line >= visible.to || cur.line < visible.from)\n          { setTimeout(operation(cm, function () {if (counter == curCount) { extend(e); }}), 150); }\n      } else {\n        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;\n        if (outside) { setTimeout(operation(cm, function () {\n          if (counter != curCount) { return }\n          display.scroller.scrollTop += outside;\n          extend(e);\n        }), 50); }\n      }\n    }\n\n    function done(e) {\n      cm.state.selectingText = false;\n      counter = Infinity;\n      e_preventDefault(e);\n      display.input.focus();\n      off(display.wrapper.ownerDocument, \"mousemove\", move);\n      off(display.wrapper.ownerDocument, \"mouseup\", up);\n      doc.history.lastSelOrigin = null;\n    }\n\n    var move = operation(cm, function (e) {\n      if (e.buttons === 0 || !e_button(e)) { done(e); }\n      else { extend(e); }\n    });\n    var up = operation(cm, done);\n    cm.state.selectingText = up;\n    on(display.wrapper.ownerDocument, \"mousemove\", move);\n    on(display.wrapper.ownerDocument, \"mouseup\", up);\n  }\n\n  // Used when mouse-selecting to adjust the anchor to the proper side\n  // of a bidi jump depending on the visual position of the head.\n  function bidiSimplify(cm, range$$1) {\n    var anchor = range$$1.anchor;\n    var head = range$$1.head;\n    var anchorLine = getLine(cm.doc, anchor.line);\n    if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) { return range$$1 }\n    var order = getOrder(anchorLine);\n    if (!order) { return range$$1 }\n    var index = getBidiPartAt(order, anchor.ch, anchor.sticky), part = order[index];\n    if (part.from != anchor.ch && part.to != anchor.ch) { return range$$1 }\n    var boundary = index + ((part.from == anchor.ch) == (part.level != 1) ? 0 : 1);\n    if (boundary == 0 || boundary == order.length) { return range$$1 }\n\n    // Compute the relative visual position of the head compared to the\n    // anchor (<0 is to the left, >0 to the right)\n    var leftSide;\n    if (head.line != anchor.line) {\n      leftSide = (head.line - anchor.line) * (cm.doc.direction == \"ltr\" ? 1 : -1) > 0;\n    } else {\n      var headIndex = getBidiPartAt(order, head.ch, head.sticky);\n      var dir = headIndex - index || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);\n      if (headIndex == boundary - 1 || headIndex == boundary)\n        { leftSide = dir < 0; }\n      else\n        { leftSide = dir > 0; }\n    }\n\n    var usePart = order[boundary + (leftSide ? -1 : 0)];\n    var from = leftSide == (usePart.level == 1);\n    var ch = from ? usePart.from : usePart.to, sticky = from ? \"after\" : \"before\";\n    return anchor.ch == ch && anchor.sticky == sticky ? range$$1 : new Range(new Pos(anchor.line, ch, sticky), head)\n  }\n\n\n  // Determines whether an event happened in the gutter, and fires the\n  // handlers for the corresponding event.\n  function gutterEvent(cm, e, type, prevent) {\n    var mX, mY;\n    if (e.touches) {\n      mX = e.touches[0].clientX;\n      mY = e.touches[0].clientY;\n    } else {\n      try { mX = e.clientX; mY = e.clientY; }\n      catch(e) { return false }\n    }\n    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) { return false }\n    if (prevent) { e_preventDefault(e); }\n\n    var display = cm.display;\n    var lineBox = display.lineDiv.getBoundingClientRect();\n\n    if (mY > lineBox.bottom || !hasHandler(cm, type)) { return e_defaultPrevented(e) }\n    mY -= lineBox.top - display.viewOffset;\n\n    for (var i = 0; i < cm.options.gutters.length; ++i) {\n      var g = display.gutters.childNodes[i];\n      if (g && g.getBoundingClientRect().right >= mX) {\n        var line = lineAtHeight(cm.doc, mY);\n        var gutter = cm.options.gutters[i];\n        signal(cm, type, cm, line, gutter, e);\n        return e_defaultPrevented(e)\n      }\n    }\n  }\n\n  function clickInGutter(cm, e) {\n    return gutterEvent(cm, e, \"gutterClick\", true)\n  }\n\n  // CONTEXT MENU HANDLING\n\n  // To make the context menu work, we need to briefly unhide the\n  // textarea (making it as unobtrusive as possible) to let the\n  // right-click take effect on it.\n  function onContextMenu(cm, e) {\n    if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) { return }\n    if (signalDOMEvent(cm, e, \"contextmenu\")) { return }\n    if (!captureRightClick) { cm.display.input.onContextMenu(e); }\n  }\n\n  function contextMenuInGutter(cm, e) {\n    if (!hasHandler(cm, \"gutterContextMenu\")) { return false }\n    return gutterEvent(cm, e, \"gutterContextMenu\", false)\n  }\n\n  function themeChanged(cm) {\n    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\s*cm-s-\\S+/g, \"\") +\n      cm.options.theme.replace(/(^|\\s)\\s*/g, \" cm-s-\");\n    clearCaches(cm);\n  }\n\n  var Init = {toString: function(){return \"CodeMirror.Init\"}};\n\n  var defaults = {};\n  var optionHandlers = {};\n\n  function defineOptions(CodeMirror) {\n    var optionHandlers = CodeMirror.optionHandlers;\n\n    function option(name, deflt, handle, notOnInit) {\n      CodeMirror.defaults[name] = deflt;\n      if (handle) { optionHandlers[name] =\n        notOnInit ? function (cm, val, old) {if (old != Init) { handle(cm, val, old); }} : handle; }\n    }\n\n    CodeMirror.defineOption = option;\n\n    // Passed to option handlers when there is no old value.\n    CodeMirror.Init = Init;\n\n    // These two are, on init, called from the constructor because they\n    // have to be initialized before the editor can start at all.\n    option(\"value\", \"\", function (cm, val) { return cm.setValue(val); }, true);\n    option(\"mode\", null, function (cm, val) {\n      cm.doc.modeOption = val;\n      loadMode(cm);\n    }, true);\n\n    option(\"indentUnit\", 2, loadMode, true);\n    option(\"indentWithTabs\", false);\n    option(\"smartIndent\", true);\n    option(\"tabSize\", 4, function (cm) {\n      resetModeState(cm);\n      clearCaches(cm);\n      regChange(cm);\n    }, true);\n\n    option(\"lineSeparator\", null, function (cm, val) {\n      cm.doc.lineSep = val;\n      if (!val) { return }\n      var newBreaks = [], lineNo = cm.doc.first;\n      cm.doc.iter(function (line) {\n        for (var pos = 0;;) {\n          var found = line.text.indexOf(val, pos);\n          if (found == -1) { break }\n          pos = found + val.length;\n          newBreaks.push(Pos(lineNo, found));\n        }\n        lineNo++;\n      });\n      for (var i = newBreaks.length - 1; i >= 0; i--)\n        { replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length)); }\n    });\n    option(\"specialChars\", /[\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u061c\\u200b-\\u200f\\u2028\\u2029\\ufeff]/g, function (cm, val, old) {\n      cm.state.specialChars = new RegExp(val.source + (val.test(\"\\t\") ? \"\" : \"|\\t\"), \"g\");\n      if (old != Init) { cm.refresh(); }\n    });\n    option(\"specialCharPlaceholder\", defaultSpecialCharPlaceholder, function (cm) { return cm.refresh(); }, true);\n    option(\"electricChars\", true);\n    option(\"inputStyle\", mobile ? \"contenteditable\" : \"textarea\", function () {\n      throw new Error(\"inputStyle can not (yet) be changed in a running editor\") // FIXME\n    }, true);\n    option(\"spellcheck\", false, function (cm, val) { return cm.getInputField().spellcheck = val; }, true);\n    option(\"autocorrect\", false, function (cm, val) { return cm.getInputField().autocorrect = val; }, true);\n    option(\"autocapitalize\", false, function (cm, val) { return cm.getInputField().autocapitalize = val; }, true);\n    option(\"rtlMoveVisually\", !windows);\n    option(\"wholeLineUpdateBefore\", true);\n\n    option(\"theme\", \"default\", function (cm) {\n      themeChanged(cm);\n      guttersChanged(cm);\n    }, true);\n    option(\"keyMap\", \"default\", function (cm, val, old) {\n      var next = getKeyMap(val);\n      var prev = old != Init && getKeyMap(old);\n      if (prev && prev.detach) { prev.detach(cm, next); }\n      if (next.attach) { next.attach(cm, prev || null); }\n    });\n    option(\"extraKeys\", null);\n    option(\"configureMouse\", null);\n\n    option(\"lineWrapping\", false, wrappingChanged, true);\n    option(\"gutters\", [], function (cm) {\n      setGuttersForLineNumbers(cm.options);\n      guttersChanged(cm);\n    }, true);\n    option(\"fixedGutter\", true, function (cm, val) {\n      cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + \"px\" : \"0\";\n      cm.refresh();\n    }, true);\n    option(\"coverGutterNextToScrollbar\", false, function (cm) { return updateScrollbars(cm); }, true);\n    option(\"scrollbarStyle\", \"native\", function (cm) {\n      initScrollbars(cm);\n      updateScrollbars(cm);\n      cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);\n      cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);\n    }, true);\n    option(\"lineNumbers\", false, function (cm) {\n      setGuttersForLineNumbers(cm.options);\n      guttersChanged(cm);\n    }, true);\n    option(\"firstLineNumber\", 1, guttersChanged, true);\n    option(\"lineNumberFormatter\", function (integer) { return integer; }, guttersChanged, true);\n    option(\"showCursorWhenSelecting\", false, updateSelection, true);\n\n    option(\"resetSelectionOnContextMenu\", true);\n    option(\"lineWiseCopyCut\", true);\n    option(\"pasteLinesPerSelection\", true);\n    option(\"selectionsMayTouch\", false);\n\n    option(\"readOnly\", false, function (cm, val) {\n      if (val == \"nocursor\") {\n        onBlur(cm);\n        cm.display.input.blur();\n      }\n      cm.display.input.readOnlyChanged(val);\n    });\n    option(\"disableInput\", false, function (cm, val) {if (!val) { cm.display.input.reset(); }}, true);\n    option(\"dragDrop\", true, dragDropChanged);\n    option(\"allowDropFileTypes\", null);\n\n    option(\"cursorBlinkRate\", 530);\n    option(\"cursorScrollMargin\", 0);\n    option(\"cursorHeight\", 1, updateSelection, true);\n    option(\"singleCursorHeightPerLine\", true, updateSelection, true);\n    option(\"workTime\", 100);\n    option(\"workDelay\", 100);\n    option(\"flattenSpans\", true, resetModeState, true);\n    option(\"addModeClass\", false, resetModeState, true);\n    option(\"pollInterval\", 100);\n    option(\"undoDepth\", 200, function (cm, val) { return cm.doc.history.undoDepth = val; });\n    option(\"historyEventDelay\", 1250);\n    option(\"viewportMargin\", 10, function (cm) { return cm.refresh(); }, true);\n    option(\"maxHighlightLength\", 10000, resetModeState, true);\n    option(\"moveInputWithCursor\", true, function (cm, val) {\n      if (!val) { cm.display.input.resetPosition(); }\n    });\n\n    option(\"tabindex\", null, function (cm, val) { return cm.display.input.getField().tabIndex = val || \"\"; });\n    option(\"autofocus\", null);\n    option(\"direction\", \"ltr\", function (cm, val) { return cm.doc.setDirection(val); }, true);\n    option(\"phrases\", null);\n  }\n\n  function guttersChanged(cm) {\n    updateGutters(cm);\n    regChange(cm);\n    alignHorizontally(cm);\n  }\n\n  function dragDropChanged(cm, value, old) {\n    var wasOn = old && old != Init;\n    if (!value != !wasOn) {\n      var funcs = cm.display.dragFunctions;\n      var toggle = value ? on : off;\n      toggle(cm.display.scroller, \"dragstart\", funcs.start);\n      toggle(cm.display.scroller, \"dragenter\", funcs.enter);\n      toggle(cm.display.scroller, \"dragover\", funcs.over);\n      toggle(cm.display.scroller, \"dragleave\", funcs.leave);\n      toggle(cm.display.scroller, \"drop\", funcs.drop);\n    }\n  }\n\n  function wrappingChanged(cm) {\n    if (cm.options.lineWrapping) {\n      addClass(cm.display.wrapper, \"CodeMirror-wrap\");\n      cm.display.sizer.style.minWidth = \"\";\n      cm.display.sizerWidth = null;\n    } else {\n      rmClass(cm.display.wrapper, \"CodeMirror-wrap\");\n      findMaxLine(cm);\n    }\n    estimateLineHeights(cm);\n    regChange(cm);\n    clearCaches(cm);\n    setTimeout(function () { return updateScrollbars(cm); }, 100);\n  }\n\n  // A CodeMirror instance represents an editor. This is the object\n  // that user code is usually dealing with.\n\n  function CodeMirror(place, options) {\n    var this$1 = this;\n\n    if (!(this instanceof CodeMirror)) { return new CodeMirror(place, options) }\n\n    this.options = options = options ? copyObj(options) : {};\n    // Determine effective options based on given values and defaults.\n    copyObj(defaults, options, false);\n    setGuttersForLineNumbers(options);\n\n    var doc = options.value;\n    if (typeof doc == \"string\") { doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction); }\n    else if (options.mode) { doc.modeOption = options.mode; }\n    this.doc = doc;\n\n    var input = new CodeMirror.inputStyles[options.inputStyle](this);\n    var display = this.display = new Display(place, doc, input);\n    display.wrapper.CodeMirror = this;\n    updateGutters(this);\n    themeChanged(this);\n    if (options.lineWrapping)\n      { this.display.wrapper.className += \" CodeMirror-wrap\"; }\n    initScrollbars(this);\n\n    this.state = {\n      keyMaps: [],  // stores maps added by addKeyMap\n      overlays: [], // highlighting overlays, as added by addOverlay\n      modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info\n      overwrite: false,\n      delayingBlurEvent: false,\n      focused: false,\n      suppressEdits: false, // used to disable editing during key handlers when in readOnly mode\n      pasteIncoming: -1, cutIncoming: -1, // help recognize paste/cut edits in input.poll\n      selectingText: false,\n      draggingText: false,\n      highlight: new Delayed(), // stores highlight worker timeout\n      keySeq: null,  // Unfinished key sequence\n      specialChars: null\n    };\n\n    if (options.autofocus && !mobile) { display.input.focus(); }\n\n    // Override magic textarea content restore that IE sometimes does\n    // on our hidden textarea on reload\n    if (ie && ie_version < 11) { setTimeout(function () { return this$1.display.input.reset(true); }, 20); }\n\n    registerEventHandlers(this);\n    ensureGlobalHandlers();\n\n    startOperation(this);\n    this.curOp.forceUpdate = true;\n    attachDoc(this, doc);\n\n    if ((options.autofocus && !mobile) || this.hasFocus())\n      { setTimeout(bind(onFocus, this), 20); }\n    else\n      { onBlur(this); }\n\n    for (var opt in optionHandlers) { if (optionHandlers.hasOwnProperty(opt))\n      { optionHandlers[opt](this$1, options[opt], Init); } }\n    maybeUpdateLineNumberWidth(this);\n    if (options.finishInit) { options.finishInit(this); }\n    for (var i = 0; i < initHooks.length; ++i) { initHooks[i](this$1); }\n    endOperation(this);\n    // Suppress optimizelegibility in Webkit, since it breaks text\n    // measuring on line wrapping boundaries.\n    if (webkit && options.lineWrapping &&\n        getComputedStyle(display.lineDiv).textRendering == \"optimizelegibility\")\n      { display.lineDiv.style.textRendering = \"auto\"; }\n  }\n\n  // The default configuration options.\n  CodeMirror.defaults = defaults;\n  // Functions to run when options are changed.\n  CodeMirror.optionHandlers = optionHandlers;\n\n  // Attach the necessary event handlers when initializing the editor\n  function registerEventHandlers(cm) {\n    var d = cm.display;\n    on(d.scroller, \"mousedown\", operation(cm, onMouseDown));\n    // Older IE's will not fire a second mousedown for a double click\n    if (ie && ie_version < 11)\n      { on(d.scroller, \"dblclick\", operation(cm, function (e) {\n        if (signalDOMEvent(cm, e)) { return }\n        var pos = posFromMouse(cm, e);\n        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) { return }\n        e_preventDefault(e);\n        var word = cm.findWordAt(pos);\n        extendSelection(cm.doc, word.anchor, word.head);\n      })); }\n    else\n      { on(d.scroller, \"dblclick\", function (e) { return signalDOMEvent(cm, e) || e_preventDefault(e); }); }\n    // Some browsers fire contextmenu *after* opening the menu, at\n    // which point we can't mess with it anymore. Context menu is\n    // handled in onMouseDown for these browsers.\n    on(d.scroller, \"contextmenu\", function (e) { return onContextMenu(cm, e); });\n\n    // Used to suppress mouse event handling when a touch happens\n    var touchFinished, prevTouch = {end: 0};\n    function finishTouch() {\n      if (d.activeTouch) {\n        touchFinished = setTimeout(function () { return d.activeTouch = null; }, 1000);\n        prevTouch = d.activeTouch;\n        prevTouch.end = +new Date;\n      }\n    }\n    function isMouseLikeTouchEvent(e) {\n      if (e.touches.length != 1) { return false }\n      var touch = e.touches[0];\n      return touch.radiusX <= 1 && touch.radiusY <= 1\n    }\n    function farAway(touch, other) {\n      if (other.left == null) { return true }\n      var dx = other.left - touch.left, dy = other.top - touch.top;\n      return dx * dx + dy * dy > 20 * 20\n    }\n    on(d.scroller, \"touchstart\", function (e) {\n      if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {\n        d.input.ensurePolled();\n        clearTimeout(touchFinished);\n        var now = +new Date;\n        d.activeTouch = {start: now, moved: false,\n                         prev: now - prevTouch.end <= 300 ? prevTouch : null};\n        if (e.touches.length == 1) {\n          d.activeTouch.left = e.touches[0].pageX;\n          d.activeTouch.top = e.touches[0].pageY;\n        }\n      }\n    });\n    on(d.scroller, \"touchmove\", function () {\n      if (d.activeTouch) { d.activeTouch.moved = true; }\n    });\n    on(d.scroller, \"touchend\", function (e) {\n      var touch = d.activeTouch;\n      if (touch && !eventInWidget(d, e) && touch.left != null &&\n          !touch.moved && new Date - touch.start < 300) {\n        var pos = cm.coordsChar(d.activeTouch, \"page\"), range;\n        if (!touch.prev || farAway(touch, touch.prev)) // Single tap\n          { range = new Range(pos, pos); }\n        else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap\n          { range = cm.findWordAt(pos); }\n        else // Triple tap\n          { range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))); }\n        cm.setSelection(range.anchor, range.head);\n        cm.focus();\n        e_preventDefault(e);\n      }\n      finishTouch();\n    });\n    on(d.scroller, \"touchcancel\", finishTouch);\n\n    // Sync scrolling between fake scrollbars and real scrollable\n    // area, ensure viewport is updated when scrolling.\n    on(d.scroller, \"scroll\", function () {\n      if (d.scroller.clientHeight) {\n        updateScrollTop(cm, d.scroller.scrollTop);\n        setScrollLeft(cm, d.scroller.scrollLeft, true);\n        signal(cm, \"scroll\", cm);\n      }\n    });\n\n    // Listen to wheel events in order to try and update the viewport on time.\n    on(d.scroller, \"mousewheel\", function (e) { return onScrollWheel(cm, e); });\n    on(d.scroller, \"DOMMouseScroll\", function (e) { return onScrollWheel(cm, e); });\n\n    // Prevent wrapper from ever scrolling\n    on(d.wrapper, \"scroll\", function () { return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });\n\n    d.dragFunctions = {\n      enter: function (e) {if (!signalDOMEvent(cm, e)) { e_stop(e); }},\n      over: function (e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},\n      start: function (e) { return onDragStart(cm, e); },\n      drop: operation(cm, onDrop),\n      leave: function (e) {if (!signalDOMEvent(cm, e)) { clearDragCursor(cm); }}\n    };\n\n    var inp = d.input.getField();\n    on(inp, \"keyup\", function (e) { return onKeyUp.call(cm, e); });\n    on(inp, \"keydown\", operation(cm, onKeyDown));\n    on(inp, \"keypress\", operation(cm, onKeyPress));\n    on(inp, \"focus\", function (e) { return onFocus(cm, e); });\n    on(inp, \"blur\", function (e) { return onBlur(cm, e); });\n  }\n\n  var initHooks = [];\n  CodeMirror.defineInitHook = function (f) { return initHooks.push(f); };\n\n  // Indent the given line. The how parameter can be \"smart\",\n  // \"add\"/null, \"subtract\", or \"prev\". When aggressive is false\n  // (typically set to true for forced single-line indents), empty\n  // lines are not indented, and places where the mode returns Pass\n  // are left alone.\n  function indentLine(cm, n, how, aggressive) {\n    var doc = cm.doc, state;\n    if (how == null) { how = \"add\"; }\n    if (how == \"smart\") {\n      // Fall back to \"prev\" when the mode doesn't have an indentation\n      // method.\n      if (!doc.mode.indent) { how = \"prev\"; }\n      else { state = getContextBefore(cm, n).state; }\n    }\n\n    var tabSize = cm.options.tabSize;\n    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);\n    if (line.stateAfter) { line.stateAfter = null; }\n    var curSpaceString = line.text.match(/^\\s*/)[0], indentation;\n    if (!aggressive && !/\\S/.test(line.text)) {\n      indentation = 0;\n      how = \"not\";\n    } else if (how == \"smart\") {\n      indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);\n      if (indentation == Pass || indentation > 150) {\n        if (!aggressive) { return }\n        how = \"prev\";\n      }\n    }\n    if (how == \"prev\") {\n      if (n > doc.first) { indentation = countColumn(getLine(doc, n-1).text, null, tabSize); }\n      else { indentation = 0; }\n    } else if (how == \"add\") {\n      indentation = curSpace + cm.options.indentUnit;\n    } else if (how == \"subtract\") {\n      indentation = curSpace - cm.options.indentUnit;\n    } else if (typeof how == \"number\") {\n      indentation = curSpace + how;\n    }\n    indentation = Math.max(0, indentation);\n\n    var indentString = \"\", pos = 0;\n    if (cm.options.indentWithTabs)\n      { for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += \"\\t\";} }\n    if (pos < indentation) { indentString += spaceStr(indentation - pos); }\n\n    if (indentString != curSpaceString) {\n      replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), \"+input\");\n      line.stateAfter = null;\n      return true\n    } else {\n      // Ensure that, if the cursor was in the whitespace at the start\n      // of the line, it is moved to the end of that space.\n      for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {\n        var range = doc.sel.ranges[i$1];\n        if (range.head.line == n && range.head.ch < curSpaceString.length) {\n          var pos$1 = Pos(n, curSpaceString.length);\n          replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));\n          break\n        }\n      }\n    }\n  }\n\n  // This will be set to a {lineWise: bool, text: [string]} object, so\n  // that, when pasting, we know what kind of selections the copied\n  // text was made out of.\n  var lastCopied = null;\n\n  function setLastCopied(newLastCopied) {\n    lastCopied = newLastCopied;\n  }\n\n  function applyTextInput(cm, inserted, deleted, sel, origin) {\n    var doc = cm.doc;\n    cm.display.shift = false;\n    if (!sel) { sel = doc.sel; }\n\n    var recent = +new Date - 200;\n    var paste = origin == \"paste\" || cm.state.pasteIncoming > recent;\n    var textLines = splitLinesAuto(inserted), multiPaste = null;\n    // When pasting N lines into N selections, insert one line per selection\n    if (paste && sel.ranges.length > 1) {\n      if (lastCopied && lastCopied.text.join(\"\\n\") == inserted) {\n        if (sel.ranges.length % lastCopied.text.length == 0) {\n          multiPaste = [];\n          for (var i = 0; i < lastCopied.text.length; i++)\n            { multiPaste.push(doc.splitLines(lastCopied.text[i])); }\n        }\n      } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {\n        multiPaste = map(textLines, function (l) { return [l]; });\n      }\n    }\n\n    var updateInput = cm.curOp.updateInput;\n    // Normal behavior is to insert the new text into every selection\n    for (var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {\n      var range$$1 = sel.ranges[i$1];\n      var from = range$$1.from(), to = range$$1.to();\n      if (range$$1.empty()) {\n        if (deleted && deleted > 0) // Handle deletion\n          { from = Pos(from.line, from.ch - deleted); }\n        else if (cm.state.overwrite && !paste) // Handle overwrite\n          { to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length)); }\n        else if (paste && lastCopied && lastCopied.lineWise && lastCopied.text.join(\"\\n\") == inserted)\n          { from = to = Pos(from.line, 0); }\n      }\n      var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,\n                         origin: origin || (paste ? \"paste\" : cm.state.cutIncoming > recent ? \"cut\" : \"+input\")};\n      makeChange(cm.doc, changeEvent);\n      signalLater(cm, \"inputRead\", cm, changeEvent);\n    }\n    if (inserted && !paste)\n      { triggerElectric(cm, inserted); }\n\n    ensureCursorVisible(cm);\n    if (cm.curOp.updateInput < 2) { cm.curOp.updateInput = updateInput; }\n    cm.curOp.typing = true;\n    cm.state.pasteIncoming = cm.state.cutIncoming = -1;\n  }\n\n  function handlePaste(e, cm) {\n    var pasted = e.clipboardData && e.clipboardData.getData(\"Text\");\n    if (pasted) {\n      e.preventDefault();\n      if (!cm.isReadOnly() && !cm.options.disableInput)\n        { runInOp(cm, function () { return applyTextInput(cm, pasted, 0, null, \"paste\"); }); }\n      return true\n    }\n  }\n\n  function triggerElectric(cm, inserted) {\n    // When an 'electric' character is inserted, immediately trigger a reindent\n    if (!cm.options.electricChars || !cm.options.smartIndent) { return }\n    var sel = cm.doc.sel;\n\n    for (var i = sel.ranges.length - 1; i >= 0; i--) {\n      var range$$1 = sel.ranges[i];\n      if (range$$1.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range$$1.head.line)) { continue }\n      var mode = cm.getModeAt(range$$1.head);\n      var indented = false;\n      if (mode.electricChars) {\n        for (var j = 0; j < mode.electricChars.length; j++)\n          { if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {\n            indented = indentLine(cm, range$$1.head.line, \"smart\");\n            break\n          } }\n      } else if (mode.electricInput) {\n        if (mode.electricInput.test(getLine(cm.doc, range$$1.head.line).text.slice(0, range$$1.head.ch)))\n          { indented = indentLine(cm, range$$1.head.line, \"smart\"); }\n      }\n      if (indented) { signalLater(cm, \"electricInput\", cm, range$$1.head.line); }\n    }\n  }\n\n  function copyableRanges(cm) {\n    var text = [], ranges = [];\n    for (var i = 0; i < cm.doc.sel.ranges.length; i++) {\n      var line = cm.doc.sel.ranges[i].head.line;\n      var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};\n      ranges.push(lineRange);\n      text.push(cm.getRange(lineRange.anchor, lineRange.head));\n    }\n    return {text: text, ranges: ranges}\n  }\n\n  function disableBrowserMagic(field, spellcheck, autocorrect, autocapitalize) {\n    field.setAttribute(\"autocorrect\", !!autocorrect);\n    field.setAttribute(\"autocapitalize\", !!autocapitalize);\n    field.setAttribute(\"spellcheck\", !!spellcheck);\n  }\n\n  function hiddenTextarea() {\n    var te = elt(\"textarea\", null, null, \"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none\");\n    var div = elt(\"div\", [te], null, \"overflow: hidden; position: relative; width: 3px; height: 0px;\");\n    // The textarea is kept positioned near the cursor to prevent the\n    // fact that it'll be scrolled into view on input from scrolling\n    // our fake cursor out of view. On webkit, when wrap=off, paste is\n    // very slow. So make the area wide instead.\n    if (webkit) { te.style.width = \"1000px\"; }\n    else { te.setAttribute(\"wrap\", \"off\"); }\n    // If border: 0; -- iOS fails to open keyboard (issue #1287)\n    if (ios) { te.style.border = \"1px solid black\"; }\n    disableBrowserMagic(te);\n    return div\n  }\n\n  // The publicly visible API. Note that methodOp(f) means\n  // 'wrap f in an operation, performed on its `this` parameter'.\n\n  // This is not the complete set of editor methods. Most of the\n  // methods defined on the Doc type are also injected into\n  // CodeMirror.prototype, for backwards compatibility and\n  // convenience.\n\n  function addEditorMethods(CodeMirror) {\n    var optionHandlers = CodeMirror.optionHandlers;\n\n    var helpers = CodeMirror.helpers = {};\n\n    CodeMirror.prototype = {\n      constructor: CodeMirror,\n      focus: function(){window.focus(); this.display.input.focus();},\n\n      setOption: function(option, value) {\n        var options = this.options, old = options[option];\n        if (options[option] == value && option != \"mode\") { return }\n        options[option] = value;\n        if (optionHandlers.hasOwnProperty(option))\n          { operation(this, optionHandlers[option])(this, value, old); }\n        signal(this, \"optionChange\", this, option);\n      },\n\n      getOption: function(option) {return this.options[option]},\n      getDoc: function() {return this.doc},\n\n      addKeyMap: function(map$$1, bottom) {\n        this.state.keyMaps[bottom ? \"push\" : \"unshift\"](getKeyMap(map$$1));\n      },\n      removeKeyMap: function(map$$1) {\n        var maps = this.state.keyMaps;\n        for (var i = 0; i < maps.length; ++i)\n          { if (maps[i] == map$$1 || maps[i].name == map$$1) {\n            maps.splice(i, 1);\n            return true\n          } }\n      },\n\n      addOverlay: methodOp(function(spec, options) {\n        var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);\n        if (mode.startState) { throw new Error(\"Overlays may not be stateful.\") }\n        insertSorted(this.state.overlays,\n                     {mode: mode, modeSpec: spec, opaque: options && options.opaque,\n                      priority: (options && options.priority) || 0},\n                     function (overlay) { return overlay.priority; });\n        this.state.modeGen++;\n        regChange(this);\n      }),\n      removeOverlay: methodOp(function(spec) {\n        var this$1 = this;\n\n        var overlays = this.state.overlays;\n        for (var i = 0; i < overlays.length; ++i) {\n          var cur = overlays[i].modeSpec;\n          if (cur == spec || typeof spec == \"string\" && cur.name == spec) {\n            overlays.splice(i, 1);\n            this$1.state.modeGen++;\n            regChange(this$1);\n            return\n          }\n        }\n      }),\n\n      indentLine: methodOp(function(n, dir, aggressive) {\n        if (typeof dir != \"string\" && typeof dir != \"number\") {\n          if (dir == null) { dir = this.options.smartIndent ? \"smart\" : \"prev\"; }\n          else { dir = dir ? \"add\" : \"subtract\"; }\n        }\n        if (isLine(this.doc, n)) { indentLine(this, n, dir, aggressive); }\n      }),\n      indentSelection: methodOp(function(how) {\n        var this$1 = this;\n\n        var ranges = this.doc.sel.ranges, end = -1;\n        for (var i = 0; i < ranges.length; i++) {\n          var range$$1 = ranges[i];\n          if (!range$$1.empty()) {\n            var from = range$$1.from(), to = range$$1.to();\n            var start = Math.max(end, from.line);\n            end = Math.min(this$1.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;\n            for (var j = start; j < end; ++j)\n              { indentLine(this$1, j, how); }\n            var newRanges = this$1.doc.sel.ranges;\n            if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)\n              { replaceOneSelection(this$1.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll); }\n          } else if (range$$1.head.line > end) {\n            indentLine(this$1, range$$1.head.line, how, true);\n            end = range$$1.head.line;\n            if (i == this$1.doc.sel.primIndex) { ensureCursorVisible(this$1); }\n          }\n        }\n      }),\n\n      // Fetch the parser token for a given character. Useful for hacks\n      // that want to inspect the mode state (say, for completion).\n      getTokenAt: function(pos, precise) {\n        return takeToken(this, pos, precise)\n      },\n\n      getLineTokens: function(line, precise) {\n        return takeToken(this, Pos(line), precise, true)\n      },\n\n      getTokenTypeAt: function(pos) {\n        pos = clipPos(this.doc, pos);\n        var styles = getLineStyles(this, getLine(this.doc, pos.line));\n        var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;\n        var type;\n        if (ch == 0) { type = styles[2]; }\n        else { for (;;) {\n          var mid = (before + after) >> 1;\n          if ((mid ? styles[mid * 2 - 1] : 0) >= ch) { after = mid; }\n          else if (styles[mid * 2 + 1] < ch) { before = mid + 1; }\n          else { type = styles[mid * 2 + 2]; break }\n        } }\n        var cut = type ? type.indexOf(\"overlay \") : -1;\n        return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1)\n      },\n\n      getModeAt: function(pos) {\n        var mode = this.doc.mode;\n        if (!mode.innerMode) { return mode }\n        return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode\n      },\n\n      getHelper: function(pos, type) {\n        return this.getHelpers(pos, type)[0]\n      },\n\n      getHelpers: function(pos, type) {\n        var this$1 = this;\n\n        var found = [];\n        if (!helpers.hasOwnProperty(type)) { return found }\n        var help = helpers[type], mode = this.getModeAt(pos);\n        if (typeof mode[type] == \"string\") {\n          if (help[mode[type]]) { found.push(help[mode[type]]); }\n        } else if (mode[type]) {\n          for (var i = 0; i < mode[type].length; i++) {\n            var val = help[mode[type][i]];\n            if (val) { found.push(val); }\n          }\n        } else if (mode.helperType && help[mode.helperType]) {\n          found.push(help[mode.helperType]);\n        } else if (help[mode.name]) {\n          found.push(help[mode.name]);\n        }\n        for (var i$1 = 0; i$1 < help._global.length; i$1++) {\n          var cur = help._global[i$1];\n          if (cur.pred(mode, this$1) && indexOf(found, cur.val) == -1)\n            { found.push(cur.val); }\n        }\n        return found\n      },\n\n      getStateAfter: function(line, precise) {\n        var doc = this.doc;\n        line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);\n        return getContextBefore(this, line + 1, precise).state\n      },\n\n      cursorCoords: function(start, mode) {\n        var pos, range$$1 = this.doc.sel.primary();\n        if (start == null) { pos = range$$1.head; }\n        else if (typeof start == \"object\") { pos = clipPos(this.doc, start); }\n        else { pos = start ? range$$1.from() : range$$1.to(); }\n        return cursorCoords(this, pos, mode || \"page\")\n      },\n\n      charCoords: function(pos, mode) {\n        return charCoords(this, clipPos(this.doc, pos), mode || \"page\")\n      },\n\n      coordsChar: function(coords, mode) {\n        coords = fromCoordSystem(this, coords, mode || \"page\");\n        return coordsChar(this, coords.left, coords.top)\n      },\n\n      lineAtHeight: function(height, mode) {\n        height = fromCoordSystem(this, {top: height, left: 0}, mode || \"page\").top;\n        return lineAtHeight(this.doc, height + this.display.viewOffset)\n      },\n      heightAtLine: function(line, mode, includeWidgets) {\n        var end = false, lineObj;\n        if (typeof line == \"number\") {\n          var last = this.doc.first + this.doc.size - 1;\n          if (line < this.doc.first) { line = this.doc.first; }\n          else if (line > last) { line = last; end = true; }\n          lineObj = getLine(this.doc, line);\n        } else {\n          lineObj = line;\n        }\n        return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || \"page\", includeWidgets || end).top +\n          (end ? this.doc.height - heightAtLine(lineObj) : 0)\n      },\n\n      defaultTextHeight: function() { return textHeight(this.display) },\n      defaultCharWidth: function() { return charWidth(this.display) },\n\n      getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo}},\n\n      addWidget: function(pos, node, scroll, vert, horiz) {\n        var display = this.display;\n        pos = cursorCoords(this, clipPos(this.doc, pos));\n        var top = pos.bottom, left = pos.left;\n        node.style.position = \"absolute\";\n        node.setAttribute(\"cm-ignore-events\", \"true\");\n        this.display.input.setUneditable(node);\n        display.sizer.appendChild(node);\n        if (vert == \"over\") {\n          top = pos.top;\n        } else if (vert == \"above\" || vert == \"near\") {\n          var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),\n          hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);\n          // Default to positioning above (if specified and possible); otherwise default to positioning below\n          if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)\n            { top = pos.top - node.offsetHeight; }\n          else if (pos.bottom + node.offsetHeight <= vspace)\n            { top = pos.bottom; }\n          if (left + node.offsetWidth > hspace)\n            { left = hspace - node.offsetWidth; }\n        }\n        node.style.top = top + \"px\";\n        node.style.left = node.style.right = \"\";\n        if (horiz == \"right\") {\n          left = display.sizer.clientWidth - node.offsetWidth;\n          node.style.right = \"0px\";\n        } else {\n          if (horiz == \"left\") { left = 0; }\n          else if (horiz == \"middle\") { left = (display.sizer.clientWidth - node.offsetWidth) / 2; }\n          node.style.left = left + \"px\";\n        }\n        if (scroll)\n          { scrollIntoView(this, {left: left, top: top, right: left + node.offsetWidth, bottom: top + node.offsetHeight}); }\n      },\n\n      triggerOnKeyDown: methodOp(onKeyDown),\n      triggerOnKeyPress: methodOp(onKeyPress),\n      triggerOnKeyUp: onKeyUp,\n      triggerOnMouseDown: methodOp(onMouseDown),\n\n      execCommand: function(cmd) {\n        if (commands.hasOwnProperty(cmd))\n          { return commands[cmd].call(null, this) }\n      },\n\n      triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),\n\n      findPosH: function(from, amount, unit, visually) {\n        var this$1 = this;\n\n        var dir = 1;\n        if (amount < 0) { dir = -1; amount = -amount; }\n        var cur = clipPos(this.doc, from);\n        for (var i = 0; i < amount; ++i) {\n          cur = findPosH(this$1.doc, cur, dir, unit, visually);\n          if (cur.hitSide) { break }\n        }\n        return cur\n      },\n\n      moveH: methodOp(function(dir, unit) {\n        var this$1 = this;\n\n        this.extendSelectionsBy(function (range$$1) {\n          if (this$1.display.shift || this$1.doc.extend || range$$1.empty())\n            { return findPosH(this$1.doc, range$$1.head, dir, unit, this$1.options.rtlMoveVisually) }\n          else\n            { return dir < 0 ? range$$1.from() : range$$1.to() }\n        }, sel_move);\n      }),\n\n      deleteH: methodOp(function(dir, unit) {\n        var sel = this.doc.sel, doc = this.doc;\n        if (sel.somethingSelected())\n          { doc.replaceSelection(\"\", null, \"+delete\"); }\n        else\n          { deleteNearSelection(this, function (range$$1) {\n            var other = findPosH(doc, range$$1.head, dir, unit, false);\n            return dir < 0 ? {from: other, to: range$$1.head} : {from: range$$1.head, to: other}\n          }); }\n      }),\n\n      findPosV: function(from, amount, unit, goalColumn) {\n        var this$1 = this;\n\n        var dir = 1, x = goalColumn;\n        if (amount < 0) { dir = -1; amount = -amount; }\n        var cur = clipPos(this.doc, from);\n        for (var i = 0; i < amount; ++i) {\n          var coords = cursorCoords(this$1, cur, \"div\");\n          if (x == null) { x = coords.left; }\n          else { coords.left = x; }\n          cur = findPosV(this$1, coords, dir, unit);\n          if (cur.hitSide) { break }\n        }\n        return cur\n      },\n\n      moveV: methodOp(function(dir, unit) {\n        var this$1 = this;\n\n        var doc = this.doc, goals = [];\n        var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();\n        doc.extendSelectionsBy(function (range$$1) {\n          if (collapse)\n            { return dir < 0 ? range$$1.from() : range$$1.to() }\n          var headPos = cursorCoords(this$1, range$$1.head, \"div\");\n          if (range$$1.goalColumn != null) { headPos.left = range$$1.goalColumn; }\n          goals.push(headPos.left);\n          var pos = findPosV(this$1, headPos, dir, unit);\n          if (unit == \"page\" && range$$1 == doc.sel.primary())\n            { addToScrollTop(this$1, charCoords(this$1, pos, \"div\").top - headPos.top); }\n          return pos\n        }, sel_move);\n        if (goals.length) { for (var i = 0; i < doc.sel.ranges.length; i++)\n          { doc.sel.ranges[i].goalColumn = goals[i]; } }\n      }),\n\n      // Find the word at the given position (as returned by coordsChar).\n      findWordAt: function(pos) {\n        var doc = this.doc, line = getLine(doc, pos.line).text;\n        var start = pos.ch, end = pos.ch;\n        if (line) {\n          var helper = this.getHelper(pos, \"wordChars\");\n          if ((pos.sticky == \"before\" || end == line.length) && start) { --start; } else { ++end; }\n          var startChar = line.charAt(start);\n          var check = isWordChar(startChar, helper)\n            ? function (ch) { return isWordChar(ch, helper); }\n            : /\\s/.test(startChar) ? function (ch) { return /\\s/.test(ch); }\n            : function (ch) { return (!/\\s/.test(ch) && !isWordChar(ch)); };\n          while (start > 0 && check(line.charAt(start - 1))) { --start; }\n          while (end < line.length && check(line.charAt(end))) { ++end; }\n        }\n        return new Range(Pos(pos.line, start), Pos(pos.line, end))\n      },\n\n      toggleOverwrite: function(value) {\n        if (value != null && value == this.state.overwrite) { return }\n        if (this.state.overwrite = !this.state.overwrite)\n          { addClass(this.display.cursorDiv, \"CodeMirror-overwrite\"); }\n        else\n          { rmClass(this.display.cursorDiv, \"CodeMirror-overwrite\"); }\n\n        signal(this, \"overwriteToggle\", this, this.state.overwrite);\n      },\n      hasFocus: function() { return this.display.input.getField() == activeElt() },\n      isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit) },\n\n      scrollTo: methodOp(function (x, y) { scrollToCoords(this, x, y); }),\n      getScrollInfo: function() {\n        var scroller = this.display.scroller;\n        return {left: scroller.scrollLeft, top: scroller.scrollTop,\n                height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,\n                width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,\n                clientHeight: displayHeight(this), clientWidth: displayWidth(this)}\n      },\n\n      scrollIntoView: methodOp(function(range$$1, margin) {\n        if (range$$1 == null) {\n          range$$1 = {from: this.doc.sel.primary().head, to: null};\n          if (margin == null) { margin = this.options.cursorScrollMargin; }\n        } else if (typeof range$$1 == \"number\") {\n          range$$1 = {from: Pos(range$$1, 0), to: null};\n        } else if (range$$1.from == null) {\n          range$$1 = {from: range$$1, to: null};\n        }\n        if (!range$$1.to) { range$$1.to = range$$1.from; }\n        range$$1.margin = margin || 0;\n\n        if (range$$1.from.line != null) {\n          scrollToRange(this, range$$1);\n        } else {\n          scrollToCoordsRange(this, range$$1.from, range$$1.to, range$$1.margin);\n        }\n      }),\n\n      setSize: methodOp(function(width, height) {\n        var this$1 = this;\n\n        var interpret = function (val) { return typeof val == \"number\" || /^\\d+$/.test(String(val)) ? val + \"px\" : val; };\n        if (width != null) { this.display.wrapper.style.width = interpret(width); }\n        if (height != null) { this.display.wrapper.style.height = interpret(height); }\n        if (this.options.lineWrapping) { clearLineMeasurementCache(this); }\n        var lineNo$$1 = this.display.viewFrom;\n        this.doc.iter(lineNo$$1, this.display.viewTo, function (line) {\n          if (line.widgets) { for (var i = 0; i < line.widgets.length; i++)\n            { if (line.widgets[i].noHScroll) { regLineChange(this$1, lineNo$$1, \"widget\"); break } } }\n          ++lineNo$$1;\n        });\n        this.curOp.forceUpdate = true;\n        signal(this, \"refresh\", this);\n      }),\n\n      operation: function(f){return runInOp(this, f)},\n      startOperation: function(){return startOperation(this)},\n      endOperation: function(){return endOperation(this)},\n\n      refresh: methodOp(function() {\n        var oldHeight = this.display.cachedTextHeight;\n        regChange(this);\n        this.curOp.forceUpdate = true;\n        clearCaches(this);\n        scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);\n        updateGutterSpace(this);\n        if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)\n          { estimateLineHeights(this); }\n        signal(this, \"refresh\", this);\n      }),\n\n      swapDoc: methodOp(function(doc) {\n        var old = this.doc;\n        old.cm = null;\n        attachDoc(this, doc);\n        clearCaches(this);\n        this.display.input.reset();\n        scrollToCoords(this, doc.scrollLeft, doc.scrollTop);\n        this.curOp.forceScroll = true;\n        signalLater(this, \"swapDoc\", this, old);\n        return old\n      }),\n\n      phrase: function(phraseText) {\n        var phrases = this.options.phrases;\n        return phrases && Object.prototype.hasOwnProperty.call(phrases, phraseText) ? phrases[phraseText] : phraseText\n      },\n\n      getInputField: function(){return this.display.input.getField()},\n      getWrapperElement: function(){return this.display.wrapper},\n      getScrollerElement: function(){return this.display.scroller},\n      getGutterElement: function(){return this.display.gutters}\n    };\n    eventMixin(CodeMirror);\n\n    CodeMirror.registerHelper = function(type, name, value) {\n      if (!helpers.hasOwnProperty(type)) { helpers[type] = CodeMirror[type] = {_global: []}; }\n      helpers[type][name] = value;\n    };\n    CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {\n      CodeMirror.registerHelper(type, name, value);\n      helpers[type]._global.push({pred: predicate, val: value});\n    };\n  }\n\n  // Used for horizontal relative motion. Dir is -1 or 1 (left or\n  // right), unit can be \"char\", \"column\" (like char, but doesn't\n  // cross line boundaries), \"word\" (across next word), or \"group\" (to\n  // the start of next group of word or non-word-non-whitespace\n  // chars). The visually param controls whether, in right-to-left\n  // text, direction 1 means to move towards the next index in the\n  // string, or towards the character to the right of the current\n  // position. The resulting position will have a hitSide=true\n  // property if it reached the end of the document.\n  function findPosH(doc, pos, dir, unit, visually) {\n    var oldPos = pos;\n    var origDir = dir;\n    var lineObj = getLine(doc, pos.line);\n    function findNextLine() {\n      var l = pos.line + dir;\n      if (l < doc.first || l >= doc.first + doc.size) { return false }\n      pos = new Pos(l, pos.ch, pos.sticky);\n      return lineObj = getLine(doc, l)\n    }\n    function moveOnce(boundToLine) {\n      var next;\n      if (visually) {\n        next = moveVisually(doc.cm, lineObj, pos, dir);\n      } else {\n        next = moveLogically(lineObj, pos, dir);\n      }\n      if (next == null) {\n        if (!boundToLine && findNextLine())\n          { pos = endOfLine(visually, doc.cm, lineObj, pos.line, dir); }\n        else\n          { return false }\n      } else {\n        pos = next;\n      }\n      return true\n    }\n\n    if (unit == \"char\") {\n      moveOnce();\n    } else if (unit == \"column\") {\n      moveOnce(true);\n    } else if (unit == \"word\" || unit == \"group\") {\n      var sawType = null, group = unit == \"group\";\n      var helper = doc.cm && doc.cm.getHelper(pos, \"wordChars\");\n      for (var first = true;; first = false) {\n        if (dir < 0 && !moveOnce(!first)) { break }\n        var cur = lineObj.text.charAt(pos.ch) || \"\\n\";\n        var type = isWordChar(cur, helper) ? \"w\"\n          : group && cur == \"\\n\" ? \"n\"\n          : !group || /\\s/.test(cur) ? null\n          : \"p\";\n        if (group && !first && !type) { type = \"s\"; }\n        if (sawType && sawType != type) {\n          if (dir < 0) {dir = 1; moveOnce(); pos.sticky = \"after\";}\n          break\n        }\n\n        if (type) { sawType = type; }\n        if (dir > 0 && !moveOnce(!first)) { break }\n      }\n    }\n    var result = skipAtomic(doc, pos, oldPos, origDir, true);\n    if (equalCursorPos(oldPos, result)) { result.hitSide = true; }\n    return result\n  }\n\n  // For relative vertical movement. Dir may be -1 or 1. Unit can be\n  // \"page\" or \"line\". The resulting position will have a hitSide=true\n  // property if it reached the end of the document.\n  function findPosV(cm, pos, dir, unit) {\n    var doc = cm.doc, x = pos.left, y;\n    if (unit == \"page\") {\n      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);\n      var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);\n      y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;\n\n    } else if (unit == \"line\") {\n      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;\n    }\n    var target;\n    for (;;) {\n      target = coordsChar(cm, x, y);\n      if (!target.outside) { break }\n      if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break }\n      y += dir * 5;\n    }\n    return target\n  }\n\n  // CONTENTEDITABLE INPUT STYLE\n\n  var ContentEditableInput = function(cm) {\n    this.cm = cm;\n    this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;\n    this.polling = new Delayed();\n    this.composing = null;\n    this.gracePeriod = false;\n    this.readDOMTimeout = null;\n  };\n\n  ContentEditableInput.prototype.init = function (display) {\n      var this$1 = this;\n\n    var input = this, cm = input.cm;\n    var div = input.div = display.lineDiv;\n    disableBrowserMagic(div, cm.options.spellcheck, cm.options.autocorrect, cm.options.autocapitalize);\n\n    on(div, \"paste\", function (e) {\n      if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }\n      // IE doesn't fire input events, so we schedule a read for the pasted content in this way\n      if (ie_version <= 11) { setTimeout(operation(cm, function () { return this$1.updateFromDOM(); }), 20); }\n    });\n\n    on(div, \"compositionstart\", function (e) {\n      this$1.composing = {data: e.data, done: false};\n    });\n    on(div, \"compositionupdate\", function (e) {\n      if (!this$1.composing) { this$1.composing = {data: e.data, done: false}; }\n    });\n    on(div, \"compositionend\", function (e) {\n      if (this$1.composing) {\n        if (e.data != this$1.composing.data) { this$1.readFromDOMSoon(); }\n        this$1.composing.done = true;\n      }\n    });\n\n    on(div, \"touchstart\", function () { return input.forceCompositionEnd(); });\n\n    on(div, \"input\", function () {\n      if (!this$1.composing) { this$1.readFromDOMSoon(); }\n    });\n\n    function onCopyCut(e) {\n      if (signalDOMEvent(cm, e)) { return }\n      if (cm.somethingSelected()) {\n        setLastCopied({lineWise: false, text: cm.getSelections()});\n        if (e.type == \"cut\") { cm.replaceSelection(\"\", null, \"cut\"); }\n      } else if (!cm.options.lineWiseCopyCut) {\n        return\n      } else {\n        var ranges = copyableRanges(cm);\n        setLastCopied({lineWise: true, text: ranges.text});\n        if (e.type == \"cut\") {\n          cm.operation(function () {\n            cm.setSelections(ranges.ranges, 0, sel_dontScroll);\n            cm.replaceSelection(\"\", null, \"cut\");\n          });\n        }\n      }\n      if (e.clipboardData) {\n        e.clipboardData.clearData();\n        var content = lastCopied.text.join(\"\\n\");\n        // iOS exposes the clipboard API, but seems to discard content inserted into it\n        e.clipboardData.setData(\"Text\", content);\n        if (e.clipboardData.getData(\"Text\") == content) {\n          e.preventDefault();\n          return\n        }\n      }\n      // Old-fashioned briefly-focus-a-textarea hack\n      var kludge = hiddenTextarea(), te = kludge.firstChild;\n      cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);\n      te.value = lastCopied.text.join(\"\\n\");\n      var hadFocus = document.activeElement;\n      selectInput(te);\n      setTimeout(function () {\n        cm.display.lineSpace.removeChild(kludge);\n        hadFocus.focus();\n        if (hadFocus == div) { input.showPrimarySelection(); }\n      }, 50);\n    }\n    on(div, \"copy\", onCopyCut);\n    on(div, \"cut\", onCopyCut);\n  };\n\n  ContentEditableInput.prototype.prepareSelection = function () {\n    var result = prepareSelection(this.cm, false);\n    result.focus = this.cm.state.focused;\n    return result\n  };\n\n  ContentEditableInput.prototype.showSelection = function (info, takeFocus) {\n    if (!info || !this.cm.display.view.length) { return }\n    if (info.focus || takeFocus) { this.showPrimarySelection(); }\n    this.showMultipleSelections(info);\n  };\n\n  ContentEditableInput.prototype.getSelection = function () {\n    return this.cm.display.wrapper.ownerDocument.getSelection()\n  };\n\n  ContentEditableInput.prototype.showPrimarySelection = function () {\n    var sel = this.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();\n    var from = prim.from(), to = prim.to();\n\n    if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {\n      sel.removeAllRanges();\n      return\n    }\n\n    var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n    var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);\n    if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&\n        cmp(minPos(curAnchor, curFocus), from) == 0 &&\n        cmp(maxPos(curAnchor, curFocus), to) == 0)\n      { return }\n\n    var view = cm.display.view;\n    var start = (from.line >= cm.display.viewFrom && posToDOM(cm, from)) ||\n        {node: view[0].measure.map[2], offset: 0};\n    var end = to.line < cm.display.viewTo && posToDOM(cm, to);\n    if (!end) {\n      var measure = view[view.length - 1].measure;\n      var map$$1 = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;\n      end = {node: map$$1[map$$1.length - 1], offset: map$$1[map$$1.length - 2] - map$$1[map$$1.length - 3]};\n    }\n\n    if (!start || !end) {\n      sel.removeAllRanges();\n      return\n    }\n\n    var old = sel.rangeCount && sel.getRangeAt(0), rng;\n    try { rng = range(start.node, start.offset, end.offset, end.node); }\n    catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible\n    if (rng) {\n      if (!gecko && cm.state.focused) {\n        sel.collapse(start.node, start.offset);\n        if (!rng.collapsed) {\n          sel.removeAllRanges();\n          sel.addRange(rng);\n        }\n      } else {\n        sel.removeAllRanges();\n        sel.addRange(rng);\n      }\n      if (old && sel.anchorNode == null) { sel.addRange(old); }\n      else if (gecko) { this.startGracePeriod(); }\n    }\n    this.rememberSelection();\n  };\n\n  ContentEditableInput.prototype.startGracePeriod = function () {\n      var this$1 = this;\n\n    clearTimeout(this.gracePeriod);\n    this.gracePeriod = setTimeout(function () {\n      this$1.gracePeriod = false;\n      if (this$1.selectionChanged())\n        { this$1.cm.operation(function () { return this$1.cm.curOp.selectionChanged = true; }); }\n    }, 20);\n  };\n\n  ContentEditableInput.prototype.showMultipleSelections = function (info) {\n    removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);\n    removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);\n  };\n\n  ContentEditableInput.prototype.rememberSelection = function () {\n    var sel = this.getSelection();\n    this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;\n    this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;\n  };\n\n  ContentEditableInput.prototype.selectionInEditor = function () {\n    var sel = this.getSelection();\n    if (!sel.rangeCount) { return false }\n    var node = sel.getRangeAt(0).commonAncestorContainer;\n    return contains(this.div, node)\n  };\n\n  ContentEditableInput.prototype.focus = function () {\n    if (this.cm.options.readOnly != \"nocursor\") {\n      if (!this.selectionInEditor())\n        { this.showSelection(this.prepareSelection(), true); }\n      this.div.focus();\n    }\n  };\n  ContentEditableInput.prototype.blur = function () { this.div.blur(); };\n  ContentEditableInput.prototype.getField = function () { return this.div };\n\n  ContentEditableInput.prototype.supportsTouch = function () { return true };\n\n  ContentEditableInput.prototype.receivedFocus = function () {\n    var input = this;\n    if (this.selectionInEditor())\n      { this.pollSelection(); }\n    else\n      { runInOp(this.cm, function () { return input.cm.curOp.selectionChanged = true; }); }\n\n    function poll() {\n      if (input.cm.state.focused) {\n        input.pollSelection();\n        input.polling.set(input.cm.options.pollInterval, poll);\n      }\n    }\n    this.polling.set(this.cm.options.pollInterval, poll);\n  };\n\n  ContentEditableInput.prototype.selectionChanged = function () {\n    var sel = this.getSelection();\n    return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||\n      sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset\n  };\n\n  ContentEditableInput.prototype.pollSelection = function () {\n    if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) { return }\n    var sel = this.getSelection(), cm = this.cm;\n    // On Android Chrome (version 56, at least), backspacing into an\n    // uneditable block element will put the cursor in that element,\n    // and then, because it's not editable, hide the virtual keyboard.\n    // Because Android doesn't allow us to actually detect backspace\n    // presses in a sane way, this code checks for when that happens\n    // and simulates a backspace press in this case.\n    if (android && chrome && this.cm.options.gutters.length && isInGutter(sel.anchorNode)) {\n      this.cm.triggerOnKeyDown({type: \"keydown\", keyCode: 8, preventDefault: Math.abs});\n      this.blur();\n      this.focus();\n      return\n    }\n    if (this.composing) { return }\n    this.rememberSelection();\n    var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n    var head = domToPos(cm, sel.focusNode, sel.focusOffset);\n    if (anchor && head) { runInOp(cm, function () {\n      setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);\n      if (anchor.bad || head.bad) { cm.curOp.selectionChanged = true; }\n    }); }\n  };\n\n  ContentEditableInput.prototype.pollContent = function () {\n    if (this.readDOMTimeout != null) {\n      clearTimeout(this.readDOMTimeout);\n      this.readDOMTimeout = null;\n    }\n\n    var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();\n    var from = sel.from(), to = sel.to();\n    if (from.ch == 0 && from.line > cm.firstLine())\n      { from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length); }\n    if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine())\n      { to = Pos(to.line + 1, 0); }\n    if (from.line < display.viewFrom || to.line > display.viewTo - 1) { return false }\n\n    var fromIndex, fromLine, fromNode;\n    if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {\n      fromLine = lineNo(display.view[0].line);\n      fromNode = display.view[0].node;\n    } else {\n      fromLine = lineNo(display.view[fromIndex].line);\n      fromNode = display.view[fromIndex - 1].node.nextSibling;\n    }\n    var toIndex = findViewIndex(cm, to.line);\n    var toLine, toNode;\n    if (toIndex == display.view.length - 1) {\n      toLine = display.viewTo - 1;\n      toNode = display.lineDiv.lastChild;\n    } else {\n      toLine = lineNo(display.view[toIndex + 1].line) - 1;\n      toNode = display.view[toIndex + 1].node.previousSibling;\n    }\n\n    if (!fromNode) { return false }\n    var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));\n    var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));\n    while (newText.length > 1 && oldText.length > 1) {\n      if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }\n      else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }\n      else { break }\n    }\n\n    var cutFront = 0, cutEnd = 0;\n    var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);\n    while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))\n      { ++cutFront; }\n    var newBot = lst(newText), oldBot = lst(oldText);\n    var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),\n                             oldBot.length - (oldText.length == 1 ? cutFront : 0));\n    while (cutEnd < maxCutEnd &&\n           newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))\n      { ++cutEnd; }\n    // Try to move start of change to start of selection if ambiguous\n    if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {\n      while (cutFront && cutFront > from.ch &&\n             newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {\n        cutFront--;\n        cutEnd++;\n      }\n    }\n\n    newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\\u200b+/, \"\");\n    newText[0] = newText[0].slice(cutFront).replace(/\\u200b+$/, \"\");\n\n    var chFrom = Pos(fromLine, cutFront);\n    var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);\n    if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {\n      replaceRange(cm.doc, newText, chFrom, chTo, \"+input\");\n      return true\n    }\n  };\n\n  ContentEditableInput.prototype.ensurePolled = function () {\n    this.forceCompositionEnd();\n  };\n  ContentEditableInput.prototype.reset = function () {\n    this.forceCompositionEnd();\n  };\n  ContentEditableInput.prototype.forceCompositionEnd = function () {\n    if (!this.composing) { return }\n    clearTimeout(this.readDOMTimeout);\n    this.composing = null;\n    this.updateFromDOM();\n    this.div.blur();\n    this.div.focus();\n  };\n  ContentEditableInput.prototype.readFromDOMSoon = function () {\n      var this$1 = this;\n\n    if (this.readDOMTimeout != null) { return }\n    this.readDOMTimeout = setTimeout(function () {\n      this$1.readDOMTimeout = null;\n      if (this$1.composing) {\n        if (this$1.composing.done) { this$1.composing = null; }\n        else { return }\n      }\n      this$1.updateFromDOM();\n    }, 80);\n  };\n\n  ContentEditableInput.prototype.updateFromDOM = function () {\n      var this$1 = this;\n\n    if (this.cm.isReadOnly() || !this.pollContent())\n      { runInOp(this.cm, function () { return regChange(this$1.cm); }); }\n  };\n\n  ContentEditableInput.prototype.setUneditable = function (node) {\n    node.contentEditable = \"false\";\n  };\n\n  ContentEditableInput.prototype.onKeyPress = function (e) {\n    if (e.charCode == 0 || this.composing) { return }\n    e.preventDefault();\n    if (!this.cm.isReadOnly())\n      { operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0); }\n  };\n\n  ContentEditableInput.prototype.readOnlyChanged = function (val) {\n    this.div.contentEditable = String(val != \"nocursor\");\n  };\n\n  ContentEditableInput.prototype.onContextMenu = function () {};\n  ContentEditableInput.prototype.resetPosition = function () {};\n\n  ContentEditableInput.prototype.needsContentAttribute = true;\n\n  function posToDOM(cm, pos) {\n    var view = findViewForLine(cm, pos.line);\n    if (!view || view.hidden) { return null }\n    var line = getLine(cm.doc, pos.line);\n    var info = mapFromLineView(view, line, pos.line);\n\n    var order = getOrder(line, cm.doc.direction), side = \"left\";\n    if (order) {\n      var partPos = getBidiPartAt(order, pos.ch);\n      side = partPos % 2 ? \"right\" : \"left\";\n    }\n    var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);\n    result.offset = result.collapse == \"right\" ? result.end : result.start;\n    return result\n  }\n\n  function isInGutter(node) {\n    for (var scan = node; scan; scan = scan.parentNode)\n      { if (/CodeMirror-gutter-wrapper/.test(scan.className)) { return true } }\n    return false\n  }\n\n  function badPos(pos, bad) { if (bad) { pos.bad = true; } return pos }\n\n  function domTextBetween(cm, from, to, fromLine, toLine) {\n    var text = \"\", closing = false, lineSep = cm.doc.lineSeparator(), extraLinebreak = false;\n    function recognizeMarker(id) { return function (marker) { return marker.id == id; } }\n    function close() {\n      if (closing) {\n        text += lineSep;\n        if (extraLinebreak) { text += lineSep; }\n        closing = extraLinebreak = false;\n      }\n    }\n    function addText(str) {\n      if (str) {\n        close();\n        text += str;\n      }\n    }\n    function walk(node) {\n      if (node.nodeType == 1) {\n        var cmText = node.getAttribute(\"cm-text\");\n        if (cmText) {\n          addText(cmText);\n          return\n        }\n        var markerID = node.getAttribute(\"cm-marker\"), range$$1;\n        if (markerID) {\n          var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));\n          if (found.length && (range$$1 = found[0].find(0)))\n            { addText(getBetween(cm.doc, range$$1.from, range$$1.to).join(lineSep)); }\n          return\n        }\n        if (node.getAttribute(\"contenteditable\") == \"false\") { return }\n        var isBlock = /^(pre|div|p|li|table|br)$/i.test(node.nodeName);\n        if (!/^br$/i.test(node.nodeName) && node.textContent.length == 0) { return }\n\n        if (isBlock) { close(); }\n        for (var i = 0; i < node.childNodes.length; i++)\n          { walk(node.childNodes[i]); }\n\n        if (/^(pre|p)$/i.test(node.nodeName)) { extraLinebreak = true; }\n        if (isBlock) { closing = true; }\n      } else if (node.nodeType == 3) {\n        addText(node.nodeValue.replace(/\\u200b/g, \"\").replace(/\\u00a0/g, \" \"));\n      }\n    }\n    for (;;) {\n      walk(from);\n      if (from == to) { break }\n      from = from.nextSibling;\n      extraLinebreak = false;\n    }\n    return text\n  }\n\n  function domToPos(cm, node, offset) {\n    var lineNode;\n    if (node == cm.display.lineDiv) {\n      lineNode = cm.display.lineDiv.childNodes[offset];\n      if (!lineNode) { return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true) }\n      node = null; offset = 0;\n    } else {\n      for (lineNode = node;; lineNode = lineNode.parentNode) {\n        if (!lineNode || lineNode == cm.display.lineDiv) { return null }\n        if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) { break }\n      }\n    }\n    for (var i = 0; i < cm.display.view.length; i++) {\n      var lineView = cm.display.view[i];\n      if (lineView.node == lineNode)\n        { return locateNodeInLineView(lineView, node, offset) }\n    }\n  }\n\n  function locateNodeInLineView(lineView, node, offset) {\n    var wrapper = lineView.text.firstChild, bad = false;\n    if (!node || !contains(wrapper, node)) { return badPos(Pos(lineNo(lineView.line), 0), true) }\n    if (node == wrapper) {\n      bad = true;\n      node = wrapper.childNodes[offset];\n      offset = 0;\n      if (!node) {\n        var line = lineView.rest ? lst(lineView.rest) : lineView.line;\n        return badPos(Pos(lineNo(line), line.text.length), bad)\n      }\n    }\n\n    var textNode = node.nodeType == 3 ? node : null, topNode = node;\n    if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {\n      textNode = node.firstChild;\n      if (offset) { offset = textNode.nodeValue.length; }\n    }\n    while (topNode.parentNode != wrapper) { topNode = topNode.parentNode; }\n    var measure = lineView.measure, maps = measure.maps;\n\n    function find(textNode, topNode, offset) {\n      for (var i = -1; i < (maps ? maps.length : 0); i++) {\n        var map$$1 = i < 0 ? measure.map : maps[i];\n        for (var j = 0; j < map$$1.length; j += 3) {\n          var curNode = map$$1[j + 2];\n          if (curNode == textNode || curNode == topNode) {\n            var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);\n            var ch = map$$1[j] + offset;\n            if (offset < 0 || curNode != textNode) { ch = map$$1[j + (offset ? 1 : 0)]; }\n            return Pos(line, ch)\n          }\n        }\n      }\n    }\n    var found = find(textNode, topNode, offset);\n    if (found) { return badPos(found, bad) }\n\n    // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems\n    for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {\n      found = find(after, after.firstChild, 0);\n      if (found)\n        { return badPos(Pos(found.line, found.ch - dist), bad) }\n      else\n        { dist += after.textContent.length; }\n    }\n    for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {\n      found = find(before, before.firstChild, -1);\n      if (found)\n        { return badPos(Pos(found.line, found.ch + dist$1), bad) }\n      else\n        { dist$1 += before.textContent.length; }\n    }\n  }\n\n  // TEXTAREA INPUT STYLE\n\n  var TextareaInput = function(cm) {\n    this.cm = cm;\n    // See input.poll and input.reset\n    this.prevInput = \"\";\n\n    // Flag that indicates whether we expect input to appear real soon\n    // now (after some event like 'keypress' or 'input') and are\n    // polling intensively.\n    this.pollingFast = false;\n    // Self-resetting timeout for the poller\n    this.polling = new Delayed();\n    // Used to work around IE issue with selection being forgotten when focus moves away from textarea\n    this.hasSelection = false;\n    this.composing = null;\n  };\n\n  TextareaInput.prototype.init = function (display) {\n      var this$1 = this;\n\n    var input = this, cm = this.cm;\n    this.createField(display);\n    var te = this.textarea;\n\n    display.wrapper.insertBefore(this.wrapper, display.wrapper.firstChild);\n\n    // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)\n    if (ios) { te.style.width = \"0px\"; }\n\n    on(te, \"input\", function () {\n      if (ie && ie_version >= 9 && this$1.hasSelection) { this$1.hasSelection = null; }\n      input.poll();\n    });\n\n    on(te, \"paste\", function (e) {\n      if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }\n\n      cm.state.pasteIncoming = +new Date;\n      input.fastPoll();\n    });\n\n    function prepareCopyCut(e) {\n      if (signalDOMEvent(cm, e)) { return }\n      if (cm.somethingSelected()) {\n        setLastCopied({lineWise: false, text: cm.getSelections()});\n      } else if (!cm.options.lineWiseCopyCut) {\n        return\n      } else {\n        var ranges = copyableRanges(cm);\n        setLastCopied({lineWise: true, text: ranges.text});\n        if (e.type == \"cut\") {\n          cm.setSelections(ranges.ranges, null, sel_dontScroll);\n        } else {\n          input.prevInput = \"\";\n          te.value = ranges.text.join(\"\\n\");\n          selectInput(te);\n        }\n      }\n      if (e.type == \"cut\") { cm.state.cutIncoming = +new Date; }\n    }\n    on(te, \"cut\", prepareCopyCut);\n    on(te, \"copy\", prepareCopyCut);\n\n    on(display.scroller, \"paste\", function (e) {\n      if (eventInWidget(display, e) || signalDOMEvent(cm, e)) { return }\n      if (!te.dispatchEvent) {\n        cm.state.pasteIncoming = +new Date;\n        input.focus();\n        return\n      }\n\n      // Pass the `paste` event to the textarea so it's handled by its event listener.\n      var event = new Event(\"paste\");\n      event.clipboardData = e.clipboardData;\n      te.dispatchEvent(event);\n    });\n\n    // Prevent normal selection in the editor (we handle our own)\n    on(display.lineSpace, \"selectstart\", function (e) {\n      if (!eventInWidget(display, e)) { e_preventDefault(e); }\n    });\n\n    on(te, \"compositionstart\", function () {\n      var start = cm.getCursor(\"from\");\n      if (input.composing) { input.composing.range.clear(); }\n      input.composing = {\n        start: start,\n        range: cm.markText(start, cm.getCursor(\"to\"), {className: \"CodeMirror-composing\"})\n      };\n    });\n    on(te, \"compositionend\", function () {\n      if (input.composing) {\n        input.poll();\n        input.composing.range.clear();\n        input.composing = null;\n      }\n    });\n  };\n\n  TextareaInput.prototype.createField = function (_display) {\n    // Wraps and hides input textarea\n    this.wrapper = hiddenTextarea();\n    // The semihidden textarea that is focused when the editor is\n    // focused, and receives input.\n    this.textarea = this.wrapper.firstChild;\n  };\n\n  TextareaInput.prototype.prepareSelection = function () {\n    // Redraw the selection and/or cursor\n    var cm = this.cm, display = cm.display, doc = cm.doc;\n    var result = prepareSelection(cm);\n\n    // Move the hidden textarea near the cursor to prevent scrolling artifacts\n    if (cm.options.moveInputWithCursor) {\n      var headPos = cursorCoords(cm, doc.sel.primary().head, \"div\");\n      var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();\n      result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,\n                                          headPos.top + lineOff.top - wrapOff.top));\n      result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,\n                                           headPos.left + lineOff.left - wrapOff.left));\n    }\n\n    return result\n  };\n\n  TextareaInput.prototype.showSelection = function (drawn) {\n    var cm = this.cm, display = cm.display;\n    removeChildrenAndAdd(display.cursorDiv, drawn.cursors);\n    removeChildrenAndAdd(display.selectionDiv, drawn.selection);\n    if (drawn.teTop != null) {\n      this.wrapper.style.top = drawn.teTop + \"px\";\n      this.wrapper.style.left = drawn.teLeft + \"px\";\n    }\n  };\n\n  // Reset the input to correspond to the selection (or to be empty,\n  // when not typing and nothing is selected)\n  TextareaInput.prototype.reset = function (typing) {\n    if (this.contextMenuPending || this.composing) { return }\n    var cm = this.cm;\n    if (cm.somethingSelected()) {\n      this.prevInput = \"\";\n      var content = cm.getSelection();\n      this.textarea.value = content;\n      if (cm.state.focused) { selectInput(this.textarea); }\n      if (ie && ie_version >= 9) { this.hasSelection = content; }\n    } else if (!typing) {\n      this.prevInput = this.textarea.value = \"\";\n      if (ie && ie_version >= 9) { this.hasSelection = null; }\n    }\n  };\n\n  TextareaInput.prototype.getField = function () { return this.textarea };\n\n  TextareaInput.prototype.supportsTouch = function () { return false };\n\n  TextareaInput.prototype.focus = function () {\n    if (this.cm.options.readOnly != \"nocursor\" && (!mobile || activeElt() != this.textarea)) {\n      try { this.textarea.focus(); }\n      catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM\n    }\n  };\n\n  TextareaInput.prototype.blur = function () { this.textarea.blur(); };\n\n  TextareaInput.prototype.resetPosition = function () {\n    this.wrapper.style.top = this.wrapper.style.left = 0;\n  };\n\n  TextareaInput.prototype.receivedFocus = function () { this.slowPoll(); };\n\n  // Poll for input changes, using the normal rate of polling. This\n  // runs as long as the editor is focused.\n  TextareaInput.prototype.slowPoll = function () {\n      var this$1 = this;\n\n    if (this.pollingFast) { return }\n    this.polling.set(this.cm.options.pollInterval, function () {\n      this$1.poll();\n      if (this$1.cm.state.focused) { this$1.slowPoll(); }\n    });\n  };\n\n  // When an event has just come in that is likely to add or change\n  // something in the input textarea, we poll faster, to ensure that\n  // the change appears on the screen quickly.\n  TextareaInput.prototype.fastPoll = function () {\n    var missed = false, input = this;\n    input.pollingFast = true;\n    function p() {\n      var changed = input.poll();\n      if (!changed && !missed) {missed = true; input.polling.set(60, p);}\n      else {input.pollingFast = false; input.slowPoll();}\n    }\n    input.polling.set(20, p);\n  };\n\n  // Read input from the textarea, and update the document to match.\n  // When something is selected, it is present in the textarea, and\n  // selected (unless it is huge, in which case a placeholder is\n  // used). When nothing is selected, the cursor sits after previously\n  // seen text (can be empty), which is stored in prevInput (we must\n  // not reset the textarea when typing, because that breaks IME).\n  TextareaInput.prototype.poll = function () {\n      var this$1 = this;\n\n    var cm = this.cm, input = this.textarea, prevInput = this.prevInput;\n    // Since this is called a *lot*, try to bail out as cheaply as\n    // possible when it is clear that nothing happened. hasSelection\n    // will be the case when there is a lot of text in the textarea,\n    // in which case reading its value would be expensive.\n    if (this.contextMenuPending || !cm.state.focused ||\n        (hasSelection(input) && !prevInput && !this.composing) ||\n        cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)\n      { return false }\n\n    var text = input.value;\n    // If nothing changed, bail.\n    if (text == prevInput && !cm.somethingSelected()) { return false }\n    // Work around nonsensical selection resetting in IE9/10, and\n    // inexplicable appearance of private area unicode characters on\n    // some key combos in Mac (#2689).\n    if (ie && ie_version >= 9 && this.hasSelection === text ||\n        mac && /[\\uf700-\\uf7ff]/.test(text)) {\n      cm.display.input.reset();\n      return false\n    }\n\n    if (cm.doc.sel == cm.display.selForContextMenu) {\n      var first = text.charCodeAt(0);\n      if (first == 0x200b && !prevInput) { prevInput = \"\\u200b\"; }\n      if (first == 0x21da) { this.reset(); return this.cm.execCommand(\"undo\") }\n    }\n    // Find the part of the input that is actually new\n    var same = 0, l = Math.min(prevInput.length, text.length);\n    while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) { ++same; }\n\n    runInOp(cm, function () {\n      applyTextInput(cm, text.slice(same), prevInput.length - same,\n                     null, this$1.composing ? \"*compose\" : null);\n\n      // Don't leave long text in the textarea, since it makes further polling slow\n      if (text.length > 1000 || text.indexOf(\"\\n\") > -1) { input.value = this$1.prevInput = \"\"; }\n      else { this$1.prevInput = text; }\n\n      if (this$1.composing) {\n        this$1.composing.range.clear();\n        this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor(\"to\"),\n                                           {className: \"CodeMirror-composing\"});\n      }\n    });\n    return true\n  };\n\n  TextareaInput.prototype.ensurePolled = function () {\n    if (this.pollingFast && this.poll()) { this.pollingFast = false; }\n  };\n\n  TextareaInput.prototype.onKeyPress = function () {\n    if (ie && ie_version >= 9) { this.hasSelection = null; }\n    this.fastPoll();\n  };\n\n  TextareaInput.prototype.onContextMenu = function (e) {\n    var input = this, cm = input.cm, display = cm.display, te = input.textarea;\n    if (input.contextMenuPending) { input.contextMenuPending(); }\n    var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;\n    if (!pos || presto) { return } // Opera is difficult.\n\n    // Reset the current text selection only if the click is done outside of the selection\n    // and 'resetSelectionOnContextMenu' option is true.\n    var reset = cm.options.resetSelectionOnContextMenu;\n    if (reset && cm.doc.sel.contains(pos) == -1)\n      { operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll); }\n\n    var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;\n    var wrapperBox = input.wrapper.offsetParent.getBoundingClientRect();\n    input.wrapper.style.cssText = \"position: static\";\n    te.style.cssText = \"position: absolute; width: 30px; height: 30px;\\n      top: \" + (e.clientY - wrapperBox.top - 5) + \"px; left: \" + (e.clientX - wrapperBox.left - 5) + \"px;\\n      z-index: 1000; background: \" + (ie ? \"rgba(255, 255, 255, .05)\" : \"transparent\") + \";\\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);\";\n    var oldScrollY;\n    if (webkit) { oldScrollY = window.scrollY; } // Work around Chrome issue (#2712)\n    display.input.focus();\n    if (webkit) { window.scrollTo(null, oldScrollY); }\n    display.input.reset();\n    // Adds \"Select all\" to context menu in FF\n    if (!cm.somethingSelected()) { te.value = input.prevInput = \" \"; }\n    input.contextMenuPending = rehide;\n    display.selForContextMenu = cm.doc.sel;\n    clearTimeout(display.detectingSelectAll);\n\n    // Select-all will be greyed out if there's nothing to select, so\n    // this adds a zero-width space so that we can later check whether\n    // it got selected.\n    function prepareSelectAllHack() {\n      if (te.selectionStart != null) {\n        var selected = cm.somethingSelected();\n        var extval = \"\\u200b\" + (selected ? te.value : \"\");\n        te.value = \"\\u21da\"; // Used to catch context-menu undo\n        te.value = extval;\n        input.prevInput = selected ? \"\" : \"\\u200b\";\n        te.selectionStart = 1; te.selectionEnd = extval.length;\n        // Re-set this, in case some other handler touched the\n        // selection in the meantime.\n        display.selForContextMenu = cm.doc.sel;\n      }\n    }\n    function rehide() {\n      if (input.contextMenuPending != rehide) { return }\n      input.contextMenuPending = false;\n      input.wrapper.style.cssText = oldWrapperCSS;\n      te.style.cssText = oldCSS;\n      if (ie && ie_version < 9) { display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos); }\n\n      // Try to detect the user choosing select-all\n      if (te.selectionStart != null) {\n        if (!ie || (ie && ie_version < 9)) { prepareSelectAllHack(); }\n        var i = 0, poll = function () {\n          if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&\n              te.selectionEnd > 0 && input.prevInput == \"\\u200b\") {\n            operation(cm, selectAll)(cm);\n          } else if (i++ < 10) {\n            display.detectingSelectAll = setTimeout(poll, 500);\n          } else {\n            display.selForContextMenu = null;\n            display.input.reset();\n          }\n        };\n        display.detectingSelectAll = setTimeout(poll, 200);\n      }\n    }\n\n    if (ie && ie_version >= 9) { prepareSelectAllHack(); }\n    if (captureRightClick) {\n      e_stop(e);\n      var mouseup = function () {\n        off(window, \"mouseup\", mouseup);\n        setTimeout(rehide, 20);\n      };\n      on(window, \"mouseup\", mouseup);\n    } else {\n      setTimeout(rehide, 50);\n    }\n  };\n\n  TextareaInput.prototype.readOnlyChanged = function (val) {\n    if (!val) { this.reset(); }\n    this.textarea.disabled = val == \"nocursor\";\n  };\n\n  TextareaInput.prototype.setUneditable = function () {};\n\n  TextareaInput.prototype.needsContentAttribute = false;\n\n  function fromTextArea(textarea, options) {\n    options = options ? copyObj(options) : {};\n    options.value = textarea.value;\n    if (!options.tabindex && textarea.tabIndex)\n      { options.tabindex = textarea.tabIndex; }\n    if (!options.placeholder && textarea.placeholder)\n      { options.placeholder = textarea.placeholder; }\n    // Set autofocus to true if this textarea is focused, or if it has\n    // autofocus and no other element is focused.\n    if (options.autofocus == null) {\n      var hasFocus = activeElt();\n      options.autofocus = hasFocus == textarea ||\n        textarea.getAttribute(\"autofocus\") != null && hasFocus == document.body;\n    }\n\n    function save() {textarea.value = cm.getValue();}\n\n    var realSubmit;\n    if (textarea.form) {\n      on(textarea.form, \"submit\", save);\n      // Deplorable hack to make the submit method do the right thing.\n      if (!options.leaveSubmitMethodAlone) {\n        var form = textarea.form;\n        realSubmit = form.submit;\n        try {\n          var wrappedSubmit = form.submit = function () {\n            save();\n            form.submit = realSubmit;\n            form.submit();\n            form.submit = wrappedSubmit;\n          };\n        } catch(e) {}\n      }\n    }\n\n    options.finishInit = function (cm) {\n      cm.save = save;\n      cm.getTextArea = function () { return textarea; };\n      cm.toTextArea = function () {\n        cm.toTextArea = isNaN; // Prevent this from being ran twice\n        save();\n        textarea.parentNode.removeChild(cm.getWrapperElement());\n        textarea.style.display = \"\";\n        if (textarea.form) {\n          off(textarea.form, \"submit\", save);\n          if (typeof textarea.form.submit == \"function\")\n            { textarea.form.submit = realSubmit; }\n        }\n      };\n    };\n\n    textarea.style.display = \"none\";\n    var cm = CodeMirror(function (node) { return textarea.parentNode.insertBefore(node, textarea.nextSibling); },\n      options);\n    return cm\n  }\n\n  function addLegacyProps(CodeMirror) {\n    CodeMirror.off = off;\n    CodeMirror.on = on;\n    CodeMirror.wheelEventPixels = wheelEventPixels;\n    CodeMirror.Doc = Doc;\n    CodeMirror.splitLines = splitLinesAuto;\n    CodeMirror.countColumn = countColumn;\n    CodeMirror.findColumn = findColumn;\n    CodeMirror.isWordChar = isWordCharBasic;\n    CodeMirror.Pass = Pass;\n    CodeMirror.signal = signal;\n    CodeMirror.Line = Line;\n    CodeMirror.changeEnd = changeEnd;\n    CodeMirror.scrollbarModel = scrollbarModel;\n    CodeMirror.Pos = Pos;\n    CodeMirror.cmpPos = cmp;\n    CodeMirror.modes = modes;\n    CodeMirror.mimeModes = mimeModes;\n    CodeMirror.resolveMode = resolveMode;\n    CodeMirror.getMode = getMode;\n    CodeMirror.modeExtensions = modeExtensions;\n    CodeMirror.extendMode = extendMode;\n    CodeMirror.copyState = copyState;\n    CodeMirror.startState = startState;\n    CodeMirror.innerMode = innerMode;\n    CodeMirror.commands = commands;\n    CodeMirror.keyMap = keyMap;\n    CodeMirror.keyName = keyName;\n    CodeMirror.isModifierKey = isModifierKey;\n    CodeMirror.lookupKey = lookupKey;\n    CodeMirror.normalizeKeyMap = normalizeKeyMap;\n    CodeMirror.StringStream = StringStream;\n    CodeMirror.SharedTextMarker = SharedTextMarker;\n    CodeMirror.TextMarker = TextMarker;\n    CodeMirror.LineWidget = LineWidget;\n    CodeMirror.e_preventDefault = e_preventDefault;\n    CodeMirror.e_stopPropagation = e_stopPropagation;\n    CodeMirror.e_stop = e_stop;\n    CodeMirror.addClass = addClass;\n    CodeMirror.contains = contains;\n    CodeMirror.rmClass = rmClass;\n    CodeMirror.keyNames = keyNames;\n  }\n\n  // EDITOR CONSTRUCTOR\n\n  defineOptions(CodeMirror);\n\n  addEditorMethods(CodeMirror);\n\n  // Set up methods on CodeMirror's prototype to redirect to the editor's document.\n  var dontDelegate = \"iter insert remove copy getEditor constructor\".split(\" \");\n  for (var prop in Doc.prototype) { if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)\n    { CodeMirror.prototype[prop] = (function(method) {\n      return function() {return method.apply(this.doc, arguments)}\n    })(Doc.prototype[prop]); } }\n\n  eventMixin(Doc);\n  CodeMirror.inputStyles = {\"textarea\": TextareaInput, \"contenteditable\": ContentEditableInput};\n\n  // Extra arguments are stored as the mode's dependencies, which is\n  // used by (legacy) mechanisms like loadmode.js to automatically\n  // load a mode. (Preferred mechanism is the require/define calls.)\n  CodeMirror.defineMode = function(name/*, mode, …*/) {\n    if (!CodeMirror.defaults.mode && name != \"null\") { CodeMirror.defaults.mode = name; }\n    defineMode.apply(this, arguments);\n  };\n\n  CodeMirror.defineMIME = defineMIME;\n\n  // Minimal default mode.\n  CodeMirror.defineMode(\"null\", function () { return ({token: function (stream) { return stream.skipToEnd(); }}); });\n  CodeMirror.defineMIME(\"text/plain\", \"null\");\n\n  // EXTENSIONS\n\n  CodeMirror.defineExtension = function (name, func) {\n    CodeMirror.prototype[name] = func;\n  };\n  CodeMirror.defineDocExtension = function (name, func) {\n    Doc.prototype[name] = func;\n  };\n\n  CodeMirror.fromTextArea = fromTextArea;\n\n  addLegacyProps(CodeMirror);\n\n  CodeMirror.version = \"5.45.0\";\n\n  return CodeMirror;\n\n})));\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"../javascript/javascript\"), require(\"../css/css\"), require(\"../htmlmixed/htmlmixed\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"../javascript/javascript\", \"../css/css\", \"../htmlmixed/htmlmixed\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"pug\", function (config) {\n  // token types\n  var KEYWORD = 'keyword';\n  var DOCTYPE = 'meta';\n  var ID = 'builtin';\n  var CLASS = 'qualifier';\n\n  var ATTRS_NEST = {\n    '{': '}',\n    '(': ')',\n    '[': ']'\n  };\n\n  var jsMode = CodeMirror.getMode(config, 'javascript');\n\n  function State() {\n    this.javaScriptLine = false;\n    this.javaScriptLineExcludesColon = false;\n\n    this.javaScriptArguments = false;\n    this.javaScriptArgumentsDepth = 0;\n\n    this.isInterpolating = false;\n    this.interpolationNesting = 0;\n\n    this.jsState = CodeMirror.startState(jsMode);\n\n    this.restOfLine = '';\n\n    this.isIncludeFiltered = false;\n    this.isEach = false;\n\n    this.lastTag = '';\n    this.scriptType = '';\n\n    // Attributes Mode\n    this.isAttrs = false;\n    this.attrsNest = [];\n    this.inAttributeName = true;\n    this.attributeIsType = false;\n    this.attrValue = '';\n\n    // Indented Mode\n    this.indentOf = Infinity;\n    this.indentToken = '';\n\n    this.innerMode = null;\n    this.innerState = null;\n\n    this.innerModeForLine = false;\n  }\n  /**\n   * Safely copy a state\n   *\n   * @return {State}\n   */\n  State.prototype.copy = function () {\n    var res = new State();\n    res.javaScriptLine = this.javaScriptLine;\n    res.javaScriptLineExcludesColon = this.javaScriptLineExcludesColon;\n    res.javaScriptArguments = this.javaScriptArguments;\n    res.javaScriptArgumentsDepth = this.javaScriptArgumentsDepth;\n    res.isInterpolating = this.isInterpolating;\n    res.interpolationNesting = this.interpolationNesting;\n\n    res.jsState = CodeMirror.copyState(jsMode, this.jsState);\n\n    res.innerMode = this.innerMode;\n    if (this.innerMode && this.innerState) {\n      res.innerState = CodeMirror.copyState(this.innerMode, this.innerState);\n    }\n\n    res.restOfLine = this.restOfLine;\n\n    res.isIncludeFiltered = this.isIncludeFiltered;\n    res.isEach = this.isEach;\n    res.lastTag = this.lastTag;\n    res.scriptType = this.scriptType;\n    res.isAttrs = this.isAttrs;\n    res.attrsNest = this.attrsNest.slice();\n    res.inAttributeName = this.inAttributeName;\n    res.attributeIsType = this.attributeIsType;\n    res.attrValue = this.attrValue;\n    res.indentOf = this.indentOf;\n    res.indentToken = this.indentToken;\n\n    res.innerModeForLine = this.innerModeForLine;\n\n    return res;\n  };\n\n  function javaScript(stream, state) {\n    if (stream.sol()) {\n      // if javaScriptLine was set at end of line, ignore it\n      state.javaScriptLine = false;\n      state.javaScriptLineExcludesColon = false;\n    }\n    if (state.javaScriptLine) {\n      if (state.javaScriptLineExcludesColon && stream.peek() === ':') {\n        state.javaScriptLine = false;\n        state.javaScriptLineExcludesColon = false;\n        return;\n      }\n      var tok = jsMode.token(stream, state.jsState);\n      if (stream.eol()) state.javaScriptLine = false;\n      return tok || true;\n    }\n  }\n  function javaScriptArguments(stream, state) {\n    if (state.javaScriptArguments) {\n      if (state.javaScriptArgumentsDepth === 0 && stream.peek() !== '(') {\n        state.javaScriptArguments = false;\n        return;\n      }\n      if (stream.peek() === '(') {\n        state.javaScriptArgumentsDepth++;\n      } else if (stream.peek() === ')') {\n        state.javaScriptArgumentsDepth--;\n      }\n      if (state.javaScriptArgumentsDepth === 0) {\n        state.javaScriptArguments = false;\n        return;\n      }\n\n      var tok = jsMode.token(stream, state.jsState);\n      return tok || true;\n    }\n  }\n\n  function yieldStatement(stream) {\n    if (stream.match(/^yield\\b/)) {\n        return 'keyword';\n    }\n  }\n\n  function doctype(stream) {\n    if (stream.match(/^(?:doctype) *([^\\n]+)?/)) {\n        return DOCTYPE;\n    }\n  }\n\n  function interpolation(stream, state) {\n    if (stream.match('#{')) {\n      state.isInterpolating = true;\n      state.interpolationNesting = 0;\n      return 'punctuation';\n    }\n  }\n\n  function interpolationContinued(stream, state) {\n    if (state.isInterpolating) {\n      if (stream.peek() === '}') {\n        state.interpolationNesting--;\n        if (state.interpolationNesting < 0) {\n          stream.next();\n          state.isInterpolating = false;\n          return 'punctuation';\n        }\n      } else if (stream.peek() === '{') {\n        state.interpolationNesting++;\n      }\n      return jsMode.token(stream, state.jsState) || true;\n    }\n  }\n\n  function caseStatement(stream, state) {\n    if (stream.match(/^case\\b/)) {\n      state.javaScriptLine = true;\n      return KEYWORD;\n    }\n  }\n\n  function when(stream, state) {\n    if (stream.match(/^when\\b/)) {\n      state.javaScriptLine = true;\n      state.javaScriptLineExcludesColon = true;\n      return KEYWORD;\n    }\n  }\n\n  function defaultStatement(stream) {\n    if (stream.match(/^default\\b/)) {\n      return KEYWORD;\n    }\n  }\n\n  function extendsStatement(stream, state) {\n    if (stream.match(/^extends?\\b/)) {\n      state.restOfLine = 'string';\n      return KEYWORD;\n    }\n  }\n\n  function append(stream, state) {\n    if (stream.match(/^append\\b/)) {\n      state.restOfLine = 'variable';\n      return KEYWORD;\n    }\n  }\n  function prepend(stream, state) {\n    if (stream.match(/^prepend\\b/)) {\n      state.restOfLine = 'variable';\n      return KEYWORD;\n    }\n  }\n  function block(stream, state) {\n    if (stream.match(/^block\\b *(?:(prepend|append)\\b)?/)) {\n      state.restOfLine = 'variable';\n      return KEYWORD;\n    }\n  }\n\n  function include(stream, state) {\n    if (stream.match(/^include\\b/)) {\n      state.restOfLine = 'string';\n      return KEYWORD;\n    }\n  }\n\n  function includeFiltered(stream, state) {\n    if (stream.match(/^include:([a-zA-Z0-9\\-]+)/, false) && stream.match('include')) {\n      state.isIncludeFiltered = true;\n      return KEYWORD;\n    }\n  }\n\n  function includeFilteredContinued(stream, state) {\n    if (state.isIncludeFiltered) {\n      var tok = filter(stream, state);\n      state.isIncludeFiltered = false;\n      state.restOfLine = 'string';\n      return tok;\n    }\n  }\n\n  function mixin(stream, state) {\n    if (stream.match(/^mixin\\b/)) {\n      state.javaScriptLine = true;\n      return KEYWORD;\n    }\n  }\n\n  function call(stream, state) {\n    if (stream.match(/^\\+([-\\w]+)/)) {\n      if (!stream.match(/^\\( *[-\\w]+ *=/, false)) {\n        state.javaScriptArguments = true;\n        state.javaScriptArgumentsDepth = 0;\n      }\n      return 'variable';\n    }\n    if (stream.match(/^\\+#{/, false)) {\n      stream.next();\n      state.mixinCallAfter = true;\n      return interpolation(stream, state);\n    }\n  }\n  function callArguments(stream, state) {\n    if (state.mixinCallAfter) {\n      state.mixinCallAfter = false;\n      if (!stream.match(/^\\( *[-\\w]+ *=/, false)) {\n        state.javaScriptArguments = true;\n        state.javaScriptArgumentsDepth = 0;\n      }\n      return true;\n    }\n  }\n\n  function conditional(stream, state) {\n    if (stream.match(/^(if|unless|else if|else)\\b/)) {\n      state.javaScriptLine = true;\n      return KEYWORD;\n    }\n  }\n\n  function each(stream, state) {\n    if (stream.match(/^(- *)?(each|for)\\b/)) {\n      state.isEach = true;\n      return KEYWORD;\n    }\n  }\n  function eachContinued(stream, state) {\n    if (state.isEach) {\n      if (stream.match(/^ in\\b/)) {\n        state.javaScriptLine = true;\n        state.isEach = false;\n        return KEYWORD;\n      } else if (stream.sol() || stream.eol()) {\n        state.isEach = false;\n      } else if (stream.next()) {\n        while (!stream.match(/^ in\\b/, false) && stream.next());\n        return 'variable';\n      }\n    }\n  }\n\n  function whileStatement(stream, state) {\n    if (stream.match(/^while\\b/)) {\n      state.javaScriptLine = true;\n      return KEYWORD;\n    }\n  }\n\n  function tag(stream, state) {\n    var captures;\n    if (captures = stream.match(/^(\\w(?:[-:\\w]*\\w)?)\\/?/)) {\n      state.lastTag = captures[1].toLowerCase();\n      if (state.lastTag === 'script') {\n        state.scriptType = 'application/javascript';\n      }\n      return 'tag';\n    }\n  }\n\n  function filter(stream, state) {\n    if (stream.match(/^:([\\w\\-]+)/)) {\n      var innerMode;\n      if (config && config.innerModes) {\n        innerMode = config.innerModes(stream.current().substring(1));\n      }\n      if (!innerMode) {\n        innerMode = stream.current().substring(1);\n      }\n      if (typeof innerMode === 'string') {\n        innerMode = CodeMirror.getMode(config, innerMode);\n      }\n      setInnerMode(stream, state, innerMode);\n      return 'atom';\n    }\n  }\n\n  function code(stream, state) {\n    if (stream.match(/^(!?=|-)/)) {\n      state.javaScriptLine = true;\n      return 'punctuation';\n    }\n  }\n\n  function id(stream) {\n    if (stream.match(/^#([\\w-]+)/)) {\n      return ID;\n    }\n  }\n\n  function className(stream) {\n    if (stream.match(/^\\.([\\w-]+)/)) {\n      return CLASS;\n    }\n  }\n\n  function attrs(stream, state) {\n    if (stream.peek() == '(') {\n      stream.next();\n      state.isAttrs = true;\n      state.attrsNest = [];\n      state.inAttributeName = true;\n      state.attrValue = '';\n      state.attributeIsType = false;\n      return 'punctuation';\n    }\n  }\n\n  function attrsContinued(stream, state) {\n    if (state.isAttrs) {\n      if (ATTRS_NEST[stream.peek()]) {\n        state.attrsNest.push(ATTRS_NEST[stream.peek()]);\n      }\n      if (state.attrsNest[state.attrsNest.length - 1] === stream.peek()) {\n        state.attrsNest.pop();\n      } else  if (stream.eat(')')) {\n        state.isAttrs = false;\n        return 'punctuation';\n      }\n      if (state.inAttributeName && stream.match(/^[^=,\\)!]+/)) {\n        if (stream.peek() === '=' || stream.peek() === '!') {\n          state.inAttributeName = false;\n          state.jsState = CodeMirror.startState(jsMode);\n          if (state.lastTag === 'script' && stream.current().trim().toLowerCase() === 'type') {\n            state.attributeIsType = true;\n          } else {\n            state.attributeIsType = false;\n          }\n        }\n        return 'attribute';\n      }\n\n      var tok = jsMode.token(stream, state.jsState);\n      if (state.attributeIsType && tok === 'string') {\n        state.scriptType = stream.current().toString();\n      }\n      if (state.attrsNest.length === 0 && (tok === 'string' || tok === 'variable' || tok === 'keyword')) {\n        try {\n          Function('', 'var x ' + state.attrValue.replace(/,\\s*$/, '').replace(/^!/, ''));\n          state.inAttributeName = true;\n          state.attrValue = '';\n          stream.backUp(stream.current().length);\n          return attrsContinued(stream, state);\n        } catch (ex) {\n          //not the end of an attribute\n        }\n      }\n      state.attrValue += stream.current();\n      return tok || true;\n    }\n  }\n\n  function attributesBlock(stream, state) {\n    if (stream.match(/^&attributes\\b/)) {\n      state.javaScriptArguments = true;\n      state.javaScriptArgumentsDepth = 0;\n      return 'keyword';\n    }\n  }\n\n  function indent(stream) {\n    if (stream.sol() && stream.eatSpace()) {\n      return 'indent';\n    }\n  }\n\n  function comment(stream, state) {\n    if (stream.match(/^ *\\/\\/(-)?([^\\n]*)/)) {\n      state.indentOf = stream.indentation();\n      state.indentToken = 'comment';\n      return 'comment';\n    }\n  }\n\n  function colon(stream) {\n    if (stream.match(/^: */)) {\n      return 'colon';\n    }\n  }\n\n  function text(stream, state) {\n    if (stream.match(/^(?:\\| ?| )([^\\n]+)/)) {\n      return 'string';\n    }\n    if (stream.match(/^(<[^\\n]*)/, false)) {\n      // html string\n      setInnerMode(stream, state, 'htmlmixed');\n      state.innerModeForLine = true;\n      return innerMode(stream, state, true);\n    }\n  }\n\n  function dot(stream, state) {\n    if (stream.eat('.')) {\n      var innerMode = null;\n      if (state.lastTag === 'script' && state.scriptType.toLowerCase().indexOf('javascript') != -1) {\n        innerMode = state.scriptType.toLowerCase().replace(/\"|'/g, '');\n      } else if (state.lastTag === 'style') {\n        innerMode = 'css';\n      }\n      setInnerMode(stream, state, innerMode);\n      return 'dot';\n    }\n  }\n\n  function fail(stream) {\n    stream.next();\n    return null;\n  }\n\n\n  function setInnerMode(stream, state, mode) {\n    mode = CodeMirror.mimeModes[mode] || mode;\n    mode = config.innerModes ? config.innerModes(mode) || mode : mode;\n    mode = CodeMirror.mimeModes[mode] || mode;\n    mode = CodeMirror.getMode(config, mode);\n    state.indentOf = stream.indentation();\n\n    if (mode && mode.name !== 'null') {\n      state.innerMode = mode;\n    } else {\n      state.indentToken = 'string';\n    }\n  }\n  function innerMode(stream, state, force) {\n    if (stream.indentation() > state.indentOf || (state.innerModeForLine && !stream.sol()) || force) {\n      if (state.innerMode) {\n        if (!state.innerState) {\n          state.innerState = state.innerMode.startState ? CodeMirror.startState(state.innerMode, stream.indentation()) : {};\n        }\n        return stream.hideFirstChars(state.indentOf + 2, function () {\n          return state.innerMode.token(stream, state.innerState) || true;\n        });\n      } else {\n        stream.skipToEnd();\n        return state.indentToken;\n      }\n    } else if (stream.sol()) {\n      state.indentOf = Infinity;\n      state.indentToken = null;\n      state.innerMode = null;\n      state.innerState = null;\n    }\n  }\n  function restOfLine(stream, state) {\n    if (stream.sol()) {\n      // if restOfLine was set at end of line, ignore it\n      state.restOfLine = '';\n    }\n    if (state.restOfLine) {\n      stream.skipToEnd();\n      var tok = state.restOfLine;\n      state.restOfLine = '';\n      return tok;\n    }\n  }\n\n\n  function startState() {\n    return new State();\n  }\n  function copyState(state) {\n    return state.copy();\n  }\n  /**\n   * Get the next token in the stream\n   *\n   * @param {Stream} stream\n   * @param {State} state\n   */\n  function nextToken(stream, state) {\n    var tok = innerMode(stream, state)\n      || restOfLine(stream, state)\n      || interpolationContinued(stream, state)\n      || includeFilteredContinued(stream, state)\n      || eachContinued(stream, state)\n      || attrsContinued(stream, state)\n      || javaScript(stream, state)\n      || javaScriptArguments(stream, state)\n      || callArguments(stream, state)\n\n      || yieldStatement(stream, state)\n      || doctype(stream, state)\n      || interpolation(stream, state)\n      || caseStatement(stream, state)\n      || when(stream, state)\n      || defaultStatement(stream, state)\n      || extendsStatement(stream, state)\n      || append(stream, state)\n      || prepend(stream, state)\n      || block(stream, state)\n      || include(stream, state)\n      || includeFiltered(stream, state)\n      || mixin(stream, state)\n      || call(stream, state)\n      || conditional(stream, state)\n      || each(stream, state)\n      || whileStatement(stream, state)\n      || tag(stream, state)\n      || filter(stream, state)\n      || code(stream, state)\n      || id(stream, state)\n      || className(stream, state)\n      || attrs(stream, state)\n      || attributesBlock(stream, state)\n      || indent(stream, state)\n      || text(stream, state)\n      || comment(stream, state)\n      || colon(stream, state)\n      || dot(stream, state)\n      || fail(stream, state);\n\n    return tok === true ? null : tok;\n  }\n  return {\n    startState: startState,\n    copyState: copyState,\n    token: nextToken\n  };\n}, 'javascript', 'css', 'htmlmixed');\n\nCodeMirror.defineMIME('text/x-pug', 'pug');\nCodeMirror.defineMIME('text/x-jade', 'pug');\n\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function (mod) {\n  \"use strict\";\n  if (typeof exports === \"object\" && typeof module === \"object\") {// CommonJS\n    mod(require(\"../../lib/codemirror\"),\n        require(\"../../addon/mode/overlay\"),\n        require(\"../xml/xml\"),\n        require(\"../javascript/javascript\"),\n        require(\"../coffeescript/coffeescript\"),\n        require(\"../css/css\"),\n        require(\"../sass/sass\"),\n        require(\"../stylus/stylus\"),\n        require(\"../pug/pug\"),\n        require(\"../handlebars/handlebars\"));\n  } else if (typeof define === \"function\" && define.amd) { // AMD\n    define([\"../../lib/codemirror\",\n            \"../../addon/mode/overlay\",\n            \"../xml/xml\",\n            \"../javascript/javascript\",\n            \"../coffeescript/coffeescript\",\n            \"../css/css\",\n            \"../sass/sass\",\n            \"../stylus/stylus\",\n            \"../pug/pug\",\n            \"../handlebars/handlebars\"], mod);\n  } else { // Plain browser env\n    mod(CodeMirror);\n  }\n})(function (CodeMirror) {\n  var tagLanguages = {\n    script: [\n      [\"lang\", /coffee(script)?/, \"coffeescript\"],\n      [\"type\", /^(?:text|application)\\/(?:x-)?coffee(?:script)?$/, \"coffeescript\"],\n      [\"lang\", /^babel$/, \"javascript\"],\n      [\"type\", /^text\\/babel$/, \"javascript\"],\n      [\"type\", /^text\\/ecmascript-\\d+$/, \"javascript\"]\n    ],\n    style: [\n      [\"lang\", /^stylus$/i, \"stylus\"],\n      [\"lang\", /^sass$/i, \"sass\"],\n      [\"lang\", /^less$/i, \"text/x-less\"],\n      [\"lang\", /^scss$/i, \"text/x-scss\"],\n      [\"type\", /^(text\\/)?(x-)?styl(us)?$/i, \"stylus\"],\n      [\"type\", /^text\\/sass/i, \"sass\"],\n      [\"type\", /^(text\\/)?(x-)?scss$/i, \"text/x-scss\"],\n      [\"type\", /^(text\\/)?(x-)?less$/i, \"text/x-less\"]\n    ],\n    template: [\n      [\"lang\", /^vue-template$/i, \"vue\"],\n      [\"lang\", /^pug$/i, \"pug\"],\n      [\"lang\", /^handlebars$/i, \"handlebars\"],\n      [\"type\", /^(text\\/)?(x-)?pug$/i, \"pug\"],\n      [\"type\", /^text\\/x-handlebars-template$/i, \"handlebars\"],\n      [null, null, \"vue-template\"]\n    ]\n  };\n\n  CodeMirror.defineMode(\"vue-template\", function (config, parserConfig) {\n    var mustacheOverlay = {\n      token: function (stream) {\n        if (stream.match(/^\\{\\{.*?\\}\\}/)) return \"meta mustache\";\n        while (stream.next() && !stream.match(\"{{\", false)) {}\n        return null;\n      }\n    };\n    return CodeMirror.overlayMode(CodeMirror.getMode(config, parserConfig.backdrop || \"text/html\"), mustacheOverlay);\n  });\n\n  CodeMirror.defineMode(\"vue\", function (config) {\n    return CodeMirror.getMode(config, {name: \"htmlmixed\", tags: tagLanguages});\n  }, \"htmlmixed\", \"xml\", \"javascript\", \"coffeescript\", \"css\", \"sass\", \"stylus\", \"pug\", \"handlebars\");\n\n  CodeMirror.defineMIME(\"script/x-vue\", \"vue\");\n  CodeMirror.defineMIME(\"text/x-vue\", \"vue\");\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"./searchcursor\"), require(\"../scroll/annotatescrollbar\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"./searchcursor\", \"../scroll/annotatescrollbar\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineExtension(\"showMatchesOnScrollbar\", function(query, caseFold, options) {\n    if (typeof options == \"string\") options = {className: options};\n    if (!options) options = {};\n    return new SearchAnnotation(this, query, caseFold, options);\n  });\n\n  function SearchAnnotation(cm, query, caseFold, options) {\n    this.cm = cm;\n    this.options = options;\n    var annotateOptions = {listenForChanges: false};\n    for (var prop in options) annotateOptions[prop] = options[prop];\n    if (!annotateOptions.className) annotateOptions.className = \"CodeMirror-search-match\";\n    this.annotation = cm.annotateScrollbar(annotateOptions);\n    this.query = query;\n    this.caseFold = caseFold;\n    this.gap = {from: cm.firstLine(), to: cm.lastLine() + 1};\n    this.matches = [];\n    this.update = null;\n\n    this.findMatches();\n    this.annotation.update(this.matches);\n\n    var self = this;\n    cm.on(\"change\", this.changeHandler = function(_cm, change) { self.onChange(change); });\n  }\n\n  var MAX_MATCHES = 1000;\n\n  SearchAnnotation.prototype.findMatches = function() {\n    if (!this.gap) return;\n    for (var i = 0; i < this.matches.length; i++) {\n      var match = this.matches[i];\n      if (match.from.line >= this.gap.to) break;\n      if (match.to.line >= this.gap.from) this.matches.splice(i--, 1);\n    }\n    var cursor = this.cm.getSearchCursor(this.query, CodeMirror.Pos(this.gap.from, 0), this.caseFold);\n    var maxMatches = this.options && this.options.maxMatches || MAX_MATCHES;\n    while (cursor.findNext()) {\n      var match = {from: cursor.from(), to: cursor.to()};\n      if (match.from.line >= this.gap.to) break;\n      this.matches.splice(i++, 0, match);\n      if (this.matches.length > maxMatches) break;\n    }\n    this.gap = null;\n  };\n\n  function offsetLine(line, changeStart, sizeChange) {\n    if (line <= changeStart) return line;\n    return Math.max(changeStart, line + sizeChange);\n  }\n\n  SearchAnnotation.prototype.onChange = function(change) {\n    var startLine = change.from.line;\n    var endLine = CodeMirror.changeEnd(change).line;\n    var sizeChange = endLine - change.to.line;\n    if (this.gap) {\n      this.gap.from = Math.min(offsetLine(this.gap.from, startLine, sizeChange), change.from.line);\n      this.gap.to = Math.max(offsetLine(this.gap.to, startLine, sizeChange), change.from.line);\n    } else {\n      this.gap = {from: change.from.line, to: endLine + 1};\n    }\n\n    if (sizeChange) for (var i = 0; i < this.matches.length; i++) {\n      var match = this.matches[i];\n      var newFrom = offsetLine(match.from.line, startLine, sizeChange);\n      if (newFrom != match.from.line) match.from = CodeMirror.Pos(newFrom, match.from.ch);\n      var newTo = offsetLine(match.to.line, startLine, sizeChange);\n      if (newTo != match.to.line) match.to = CodeMirror.Pos(newTo, match.to.ch);\n    }\n    clearTimeout(this.update);\n    var self = this;\n    this.update = setTimeout(function() { self.updateAfterChange(); }, 250);\n  };\n\n  SearchAnnotation.prototype.updateAfterChange = function() {\n    this.findMatches();\n    this.annotation.update(this.matches);\n  };\n\n  SearchAnnotation.prototype.clear = function() {\n    this.cm.off(\"change\", this.changeHandler);\n    this.annotation.clear();\n  };\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var noOptions = {};\n  var nonWS = /[^\\s\\u00a0]/;\n  var Pos = CodeMirror.Pos;\n\n  function firstNonWS(str) {\n    var found = str.search(nonWS);\n    return found == -1 ? 0 : found;\n  }\n\n  CodeMirror.commands.toggleComment = function(cm) {\n    cm.toggleComment();\n  };\n\n  CodeMirror.defineExtension(\"toggleComment\", function(options) {\n    if (!options) options = noOptions;\n    var cm = this;\n    var minLine = Infinity, ranges = this.listSelections(), mode = null;\n    for (var i = ranges.length - 1; i >= 0; i--) {\n      var from = ranges[i].from(), to = ranges[i].to();\n      if (from.line >= minLine) continue;\n      if (to.line >= minLine) to = Pos(minLine, 0);\n      minLine = from.line;\n      if (mode == null) {\n        if (cm.uncomment(from, to, options)) mode = \"un\";\n        else { cm.lineComment(from, to, options); mode = \"line\"; }\n      } else if (mode == \"un\") {\n        cm.uncomment(from, to, options);\n      } else {\n        cm.lineComment(from, to, options);\n      }\n    }\n  });\n\n  // Rough heuristic to try and detect lines that are part of multi-line string\n  function probablyInsideString(cm, pos, line) {\n    return /\\bstring\\b/.test(cm.getTokenTypeAt(Pos(pos.line, 0))) && !/^[\\'\\\"\\`]/.test(line)\n  }\n\n  function getMode(cm, pos) {\n    var mode = cm.getMode()\n    return mode.useInnerComments === false || !mode.innerMode ? mode : cm.getModeAt(pos)\n  }\n\n  CodeMirror.defineExtension(\"lineComment\", function(from, to, options) {\n    if (!options) options = noOptions;\n    var self = this, mode = getMode(self, from);\n    var firstLine = self.getLine(from.line);\n    if (firstLine == null || probablyInsideString(self, from, firstLine)) return;\n\n    var commentString = options.lineComment || mode.lineComment;\n    if (!commentString) {\n      if (options.blockCommentStart || mode.blockCommentStart) {\n        options.fullLines = true;\n        self.blockComment(from, to, options);\n      }\n      return;\n    }\n\n    var end = Math.min(to.ch != 0 || to.line == from.line ? to.line + 1 : to.line, self.lastLine() + 1);\n    var pad = options.padding == null ? \" \" : options.padding;\n    var blankLines = options.commentBlankLines || from.line == to.line;\n\n    self.operation(function() {\n      if (options.indent) {\n        var baseString = null;\n        for (var i = from.line; i < end; ++i) {\n          var line = self.getLine(i);\n          var whitespace = line.slice(0, firstNonWS(line));\n          if (baseString == null || baseString.length > whitespace.length) {\n            baseString = whitespace;\n          }\n        }\n        for (var i = from.line; i < end; ++i) {\n          var line = self.getLine(i), cut = baseString.length;\n          if (!blankLines && !nonWS.test(line)) continue;\n          if (line.slice(0, cut) != baseString) cut = firstNonWS(line);\n          self.replaceRange(baseString + commentString + pad, Pos(i, 0), Pos(i, cut));\n        }\n      } else {\n        for (var i = from.line; i < end; ++i) {\n          if (blankLines || nonWS.test(self.getLine(i)))\n            self.replaceRange(commentString + pad, Pos(i, 0));\n        }\n      }\n    });\n  });\n\n  CodeMirror.defineExtension(\"blockComment\", function(from, to, options) {\n    if (!options) options = noOptions;\n    var self = this, mode = getMode(self, from);\n    var startString = options.blockCommentStart || mode.blockCommentStart;\n    var endString = options.blockCommentEnd || mode.blockCommentEnd;\n    if (!startString || !endString) {\n      if ((options.lineComment || mode.lineComment) && options.fullLines != false)\n        self.lineComment(from, to, options);\n      return;\n    }\n    if (/\\bcomment\\b/.test(self.getTokenTypeAt(Pos(from.line, 0)))) return\n\n    var end = Math.min(to.line, self.lastLine());\n    if (end != from.line && to.ch == 0 && nonWS.test(self.getLine(end))) --end;\n\n    var pad = options.padding == null ? \" \" : options.padding;\n    if (from.line > end) return;\n\n    self.operation(function() {\n      if (options.fullLines != false) {\n        var lastLineHasText = nonWS.test(self.getLine(end));\n        self.replaceRange(pad + endString, Pos(end));\n        self.replaceRange(startString + pad, Pos(from.line, 0));\n        var lead = options.blockCommentLead || mode.blockCommentLead;\n        if (lead != null) for (var i = from.line + 1; i <= end; ++i)\n          if (i != end || lastLineHasText)\n            self.replaceRange(lead + pad, Pos(i, 0));\n      } else {\n        self.replaceRange(endString, to);\n        self.replaceRange(startString, from);\n      }\n    });\n  });\n\n  CodeMirror.defineExtension(\"uncomment\", function(from, to, options) {\n    if (!options) options = noOptions;\n    var self = this, mode = getMode(self, from);\n    var end = Math.min(to.ch != 0 || to.line == from.line ? to.line : to.line - 1, self.lastLine()), start = Math.min(from.line, end);\n\n    // Try finding line comments\n    var lineString = options.lineComment || mode.lineComment, lines = [];\n    var pad = options.padding == null ? \" \" : options.padding, didSomething;\n    lineComment: {\n      if (!lineString) break lineComment;\n      for (var i = start; i <= end; ++i) {\n        var line = self.getLine(i);\n        var found = line.indexOf(lineString);\n        if (found > -1 && !/comment/.test(self.getTokenTypeAt(Pos(i, found + 1)))) found = -1;\n        if (found == -1 && nonWS.test(line)) break lineComment;\n        if (found > -1 && nonWS.test(line.slice(0, found))) break lineComment;\n        lines.push(line);\n      }\n      self.operation(function() {\n        for (var i = start; i <= end; ++i) {\n          var line = lines[i - start];\n          var pos = line.indexOf(lineString), endPos = pos + lineString.length;\n          if (pos < 0) continue;\n          if (line.slice(endPos, endPos + pad.length) == pad) endPos += pad.length;\n          didSomething = true;\n          self.replaceRange(\"\", Pos(i, pos), Pos(i, endPos));\n        }\n      });\n      if (didSomething) return true;\n    }\n\n    // Try block comments\n    var startString = options.blockCommentStart || mode.blockCommentStart;\n    var endString = options.blockCommentEnd || mode.blockCommentEnd;\n    if (!startString || !endString) return false;\n    var lead = options.blockCommentLead || mode.blockCommentLead;\n    var startLine = self.getLine(start), open = startLine.indexOf(startString)\n    if (open == -1) return false\n    var endLine = end == start ? startLine : self.getLine(end)\n    var close = endLine.indexOf(endString, end == start ? open + startString.length : 0);\n    var insideStart = Pos(start, open + 1), insideEnd = Pos(end, close + 1)\n    if (close == -1 ||\n        !/comment/.test(self.getTokenTypeAt(insideStart)) ||\n        !/comment/.test(self.getTokenTypeAt(insideEnd)) ||\n        self.getRange(insideStart, insideEnd, \"\\n\").indexOf(endString) > -1)\n      return false;\n\n    // Avoid killing block comments completely outside the selection.\n    // Positions of the last startString before the start of the selection, and the first endString after it.\n    var lastStart = startLine.lastIndexOf(startString, from.ch);\n    var firstEnd = lastStart == -1 ? -1 : startLine.slice(0, from.ch).indexOf(endString, lastStart + startString.length);\n    if (lastStart != -1 && firstEnd != -1 && firstEnd + endString.length != from.ch) return false;\n    // Positions of the first endString after the end of the selection, and the last startString before it.\n    firstEnd = endLine.indexOf(endString, to.ch);\n    var almostLastStart = endLine.slice(to.ch).lastIndexOf(startString, firstEnd - to.ch);\n    lastStart = (firstEnd == -1 || almostLastStart == -1) ? -1 : to.ch + almostLastStart;\n    if (firstEnd != -1 && lastStart != -1 && lastStart != to.ch) return false;\n\n    self.operation(function() {\n      self.replaceRange(\"\", Pos(end, close - (pad && endLine.slice(close - pad.length, close) == pad ? pad.length : 0)),\n                        Pos(end, close + endString.length));\n      var openEnd = open + startString.length;\n      if (pad && startLine.slice(openEnd, openEnd + pad.length) == pad) openEnd += pad.length;\n      self.replaceRange(\"\", Pos(start, open), Pos(start, openEnd));\n      if (lead) for (var i = start + 1; i <= end; ++i) {\n        var line = self.getLine(i), found = line.indexOf(lead);\n        if (found == -1 || nonWS.test(line.slice(0, found))) continue;\n        var foundEnd = found + lead.length;\n        if (pad && line.slice(foundEnd, foundEnd + pad.length) == pad) foundEnd += pad.length;\n        self.replaceRange(\"\", Pos(i, found), Pos(i, foundEnd));\n      }\n    });\n    return true;\n  });\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineSimpleMode = function(name, states) {\n    CodeMirror.defineMode(name, function(config) {\n      return CodeMirror.simpleMode(config, states);\n    });\n  };\n\n  CodeMirror.simpleMode = function(config, states) {\n    ensureState(states, \"start\");\n    var states_ = {}, meta = states.meta || {}, hasIndentation = false;\n    for (var state in states) if (state != meta && states.hasOwnProperty(state)) {\n      var list = states_[state] = [], orig = states[state];\n      for (var i = 0; i < orig.length; i++) {\n        var data = orig[i];\n        list.push(new Rule(data, states));\n        if (data.indent || data.dedent) hasIndentation = true;\n      }\n    }\n    var mode = {\n      startState: function() {\n        return {state: \"start\", pending: null,\n                local: null, localState: null,\n                indent: hasIndentation ? [] : null};\n      },\n      copyState: function(state) {\n        var s = {state: state.state, pending: state.pending,\n                 local: state.local, localState: null,\n                 indent: state.indent && state.indent.slice(0)};\n        if (state.localState)\n          s.localState = CodeMirror.copyState(state.local.mode, state.localState);\n        if (state.stack)\n          s.stack = state.stack.slice(0);\n        for (var pers = state.persistentStates; pers; pers = pers.next)\n          s.persistentStates = {mode: pers.mode,\n                                spec: pers.spec,\n                                state: pers.state == state.localState ? s.localState : CodeMirror.copyState(pers.mode, pers.state),\n                                next: s.persistentStates};\n        return s;\n      },\n      token: tokenFunction(states_, config),\n      innerMode: function(state) { return state.local && {mode: state.local.mode, state: state.localState}; },\n      indent: indentFunction(states_, meta)\n    };\n    if (meta) for (var prop in meta) if (meta.hasOwnProperty(prop))\n      mode[prop] = meta[prop];\n    return mode;\n  };\n\n  function ensureState(states, name) {\n    if (!states.hasOwnProperty(name))\n      throw new Error(\"Undefined state \" + name + \" in simple mode\");\n  }\n\n  function toRegex(val, caret) {\n    if (!val) return /(?:)/;\n    var flags = \"\";\n    if (val instanceof RegExp) {\n      if (val.ignoreCase) flags = \"i\";\n      val = val.source;\n    } else {\n      val = String(val);\n    }\n    return new RegExp((caret === false ? \"\" : \"^\") + \"(?:\" + val + \")\", flags);\n  }\n\n  function asToken(val) {\n    if (!val) return null;\n    if (val.apply) return val\n    if (typeof val == \"string\") return val.replace(/\\./g, \" \");\n    var result = [];\n    for (var i = 0; i < val.length; i++)\n      result.push(val[i] && val[i].replace(/\\./g, \" \"));\n    return result;\n  }\n\n  function Rule(data, states) {\n    if (data.next || data.push) ensureState(states, data.next || data.push);\n    this.regex = toRegex(data.regex);\n    this.token = asToken(data.token);\n    this.data = data;\n  }\n\n  function tokenFunction(states, config) {\n    return function(stream, state) {\n      if (state.pending) {\n        var pend = state.pending.shift();\n        if (state.pending.length == 0) state.pending = null;\n        stream.pos += pend.text.length;\n        return pend.token;\n      }\n\n      if (state.local) {\n        if (state.local.end && stream.match(state.local.end)) {\n          var tok = state.local.endToken || null;\n          state.local = state.localState = null;\n          return tok;\n        } else {\n          var tok = state.local.mode.token(stream, state.localState), m;\n          if (state.local.endScan && (m = state.local.endScan.exec(stream.current())))\n            stream.pos = stream.start + m.index;\n          return tok;\n        }\n      }\n\n      var curState = states[state.state];\n      for (var i = 0; i < curState.length; i++) {\n        var rule = curState[i];\n        var matches = (!rule.data.sol || stream.sol()) && stream.match(rule.regex);\n        if (matches) {\n          if (rule.data.next) {\n            state.state = rule.data.next;\n          } else if (rule.data.push) {\n            (state.stack || (state.stack = [])).push(state.state);\n            state.state = rule.data.push;\n          } else if (rule.data.pop && state.stack && state.stack.length) {\n            state.state = state.stack.pop();\n          }\n\n          if (rule.data.mode)\n            enterLocalMode(config, state, rule.data.mode, rule.token);\n          if (rule.data.indent)\n            state.indent.push(stream.indentation() + config.indentUnit);\n          if (rule.data.dedent)\n            state.indent.pop();\n          var token = rule.token\n          if (token && token.apply) token = token(matches)\n          if (matches.length > 2 && rule.token && typeof rule.token != \"string\") {\n            state.pending = [];\n            for (var j = 2; j < matches.length; j++)\n              if (matches[j])\n                state.pending.push({text: matches[j], token: rule.token[j - 1]});\n            stream.backUp(matches[0].length - (matches[1] ? matches[1].length : 0));\n            return token[0];\n          } else if (token && token.join) {\n            return token[0];\n          } else {\n            return token;\n          }\n        }\n      }\n      stream.next();\n      return null;\n    };\n  }\n\n  function cmp(a, b) {\n    if (a === b) return true;\n    if (!a || typeof a != \"object\" || !b || typeof b != \"object\") return false;\n    var props = 0;\n    for (var prop in a) if (a.hasOwnProperty(prop)) {\n      if (!b.hasOwnProperty(prop) || !cmp(a[prop], b[prop])) return false;\n      props++;\n    }\n    for (var prop in b) if (b.hasOwnProperty(prop)) props--;\n    return props == 0;\n  }\n\n  function enterLocalMode(config, state, spec, token) {\n    var pers;\n    if (spec.persistent) for (var p = state.persistentStates; p && !pers; p = p.next)\n      if (spec.spec ? cmp(spec.spec, p.spec) : spec.mode == p.mode) pers = p;\n    var mode = pers ? pers.mode : spec.mode || CodeMirror.getMode(config, spec.spec);\n    var lState = pers ? pers.state : CodeMirror.startState(mode);\n    if (spec.persistent && !pers)\n      state.persistentStates = {mode: mode, spec: spec.spec, state: lState, next: state.persistentStates};\n\n    state.localState = lState;\n    state.local = {mode: mode,\n                   end: spec.end && toRegex(spec.end),\n                   endScan: spec.end && spec.forceEnd !== false && toRegex(spec.end, false),\n                   endToken: token && token.join ? token[token.length - 1] : token};\n  }\n\n  function indexOf(val, arr) {\n    for (var i = 0; i < arr.length; i++) if (arr[i] === val) return true;\n  }\n\n  function indentFunction(states, meta) {\n    return function(state, textAfter, line) {\n      if (state.local && state.local.mode.indent)\n        return state.local.mode.indent(state.localState, textAfter, line);\n      if (state.indent == null || state.local || meta.dontIndentStates && indexOf(state.state, meta.dontIndentStates) > -1)\n        return CodeMirror.Pass;\n\n      var pos = state.indent.length - 1, rules = states[state.state];\n      scan: for (;;) {\n        for (var i = 0; i < rules.length; i++) {\n          var rule = rules[i];\n          if (rule.data.dedent && rule.data.dedentIfLineStart !== false) {\n            var m = rule.regex.exec(textAfter);\n            if (m && m[0]) {\n              pos--;\n              if (rule.next || rule.push) rules = states[rule.next || rule.push];\n              textAfter = textAfter.slice(m[0].length);\n              continue scan;\n            }\n          }\n        }\n        break;\n      }\n      return pos < 0 ? 0 : state.indent[pos];\n    };\n  }\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n// Stylus mode created by Dmitry Kiselyov http://git.io/AaRB\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"stylus\", function(config) {\n    var indentUnit = config.indentUnit,\n        indentUnitString = '',\n        tagKeywords = keySet(tagKeywords_),\n        tagVariablesRegexp = /^(a|b|i|s|col|em)$/i,\n        propertyKeywords = keySet(propertyKeywords_),\n        nonStandardPropertyKeywords = keySet(nonStandardPropertyKeywords_),\n        valueKeywords = keySet(valueKeywords_),\n        colorKeywords = keySet(colorKeywords_),\n        documentTypes = keySet(documentTypes_),\n        documentTypesRegexp = wordRegexp(documentTypes_),\n        mediaFeatures = keySet(mediaFeatures_),\n        mediaTypes = keySet(mediaTypes_),\n        fontProperties = keySet(fontProperties_),\n        operatorsRegexp = /^\\s*([.]{2,3}|&&|\\|\\||\\*\\*|[?!=:]?=|[-+*\\/%<>]=?|\\?:|\\~)/,\n        wordOperatorKeywordsRegexp = wordRegexp(wordOperatorKeywords_),\n        blockKeywords = keySet(blockKeywords_),\n        vendorPrefixesRegexp = new RegExp(/^\\-(moz|ms|o|webkit)-/i),\n        commonAtoms = keySet(commonAtoms_),\n        firstWordMatch = \"\",\n        states = {},\n        ch,\n        style,\n        type,\n        override;\n\n    while (indentUnitString.length < indentUnit) indentUnitString += ' ';\n\n    /**\n     * Tokenizers\n     */\n    function tokenBase(stream, state) {\n      firstWordMatch = stream.string.match(/(^[\\w-]+\\s*=\\s*$)|(^\\s*[\\w-]+\\s*=\\s*[\\w-])|(^\\s*(\\.|#|@|\\$|\\&|\\[|\\d|\\+|::?|\\{|\\>|~|\\/)?\\s*[\\w-]*([a-z0-9-]|\\*|\\/\\*)(\\(|,)?)/);\n      state.context.line.firstWord = firstWordMatch ? firstWordMatch[0].replace(/^\\s*/, \"\") : \"\";\n      state.context.line.indent = stream.indentation();\n      ch = stream.peek();\n\n      // Line comment\n      if (stream.match(\"//\")) {\n        stream.skipToEnd();\n        return [\"comment\", \"comment\"];\n      }\n      // Block comment\n      if (stream.match(\"/*\")) {\n        state.tokenize = tokenCComment;\n        return tokenCComment(stream, state);\n      }\n      // String\n      if (ch == \"\\\"\" || ch == \"'\") {\n        stream.next();\n        state.tokenize = tokenString(ch);\n        return state.tokenize(stream, state);\n      }\n      // Def\n      if (ch == \"@\") {\n        stream.next();\n        stream.eatWhile(/[\\w\\\\-]/);\n        return [\"def\", stream.current()];\n      }\n      // ID selector or Hex color\n      if (ch == \"#\") {\n        stream.next();\n        // Hex color\n        if (stream.match(/^[0-9a-f]{3}([0-9a-f]([0-9a-f]{2}){0,2})?\\b/i)) {\n          return [\"atom\", \"atom\"];\n        }\n        // ID selector\n        if (stream.match(/^[a-z][\\w-]*/i)) {\n          return [\"builtin\", \"hash\"];\n        }\n      }\n      // Vendor prefixes\n      if (stream.match(vendorPrefixesRegexp)) {\n        return [\"meta\", \"vendor-prefixes\"];\n      }\n      // Numbers\n      if (stream.match(/^-?[0-9]?\\.?[0-9]/)) {\n        stream.eatWhile(/[a-z%]/i);\n        return [\"number\", \"unit\"];\n      }\n      // !important|optional\n      if (ch == \"!\") {\n        stream.next();\n        return [stream.match(/^(important|optional)/i) ? \"keyword\": \"operator\", \"important\"];\n      }\n      // Class\n      if (ch == \".\" && stream.match(/^\\.[a-z][\\w-]*/i)) {\n        return [\"qualifier\", \"qualifier\"];\n      }\n      // url url-prefix domain regexp\n      if (stream.match(documentTypesRegexp)) {\n        if (stream.peek() == \"(\") state.tokenize = tokenParenthesized;\n        return [\"property\", \"word\"];\n      }\n      // Mixins / Functions\n      if (stream.match(/^[a-z][\\w-]*\\(/i)) {\n        stream.backUp(1);\n        return [\"keyword\", \"mixin\"];\n      }\n      // Block mixins\n      if (stream.match(/^(\\+|-)[a-z][\\w-]*\\(/i)) {\n        stream.backUp(1);\n        return [\"keyword\", \"block-mixin\"];\n      }\n      // Parent Reference BEM naming\n      if (stream.string.match(/^\\s*&/) && stream.match(/^[-_]+[a-z][\\w-]*/)) {\n        return [\"qualifier\", \"qualifier\"];\n      }\n      // / Root Reference & Parent Reference\n      if (stream.match(/^(\\/|&)(-|_|:|\\.|#|[a-z])/)) {\n        stream.backUp(1);\n        return [\"variable-3\", \"reference\"];\n      }\n      if (stream.match(/^&{1}\\s*$/)) {\n        return [\"variable-3\", \"reference\"];\n      }\n      // Word operator\n      if (stream.match(wordOperatorKeywordsRegexp)) {\n        return [\"operator\", \"operator\"];\n      }\n      // Word\n      if (stream.match(/^\\$?[-_]*[a-z0-9]+[\\w-]*/i)) {\n        // Variable\n        if (stream.match(/^(\\.|\\[)[\\w-\\'\\\"\\]]+/i, false)) {\n          if (!wordIsTag(stream.current())) {\n            stream.match(/\\./);\n            return [\"variable-2\", \"variable-name\"];\n          }\n        }\n        return [\"variable-2\", \"word\"];\n      }\n      // Operators\n      if (stream.match(operatorsRegexp)) {\n        return [\"operator\", stream.current()];\n      }\n      // Delimiters\n      if (/[:;,{}\\[\\]\\(\\)]/.test(ch)) {\n        stream.next();\n        return [null, ch];\n      }\n      // Non-detected items\n      stream.next();\n      return [null, null];\n    }\n\n    /**\n     * Token comment\n     */\n    function tokenCComment(stream, state) {\n      var maybeEnd = false, ch;\n      while ((ch = stream.next()) != null) {\n        if (maybeEnd && ch == \"/\") {\n          state.tokenize = null;\n          break;\n        }\n        maybeEnd = (ch == \"*\");\n      }\n      return [\"comment\", \"comment\"];\n    }\n\n    /**\n     * Token string\n     */\n    function tokenString(quote) {\n      return function(stream, state) {\n        var escaped = false, ch;\n        while ((ch = stream.next()) != null) {\n          if (ch == quote && !escaped) {\n            if (quote == \")\") stream.backUp(1);\n            break;\n          }\n          escaped = !escaped && ch == \"\\\\\";\n        }\n        if (ch == quote || !escaped && quote != \")\") state.tokenize = null;\n        return [\"string\", \"string\"];\n      };\n    }\n\n    /**\n     * Token parenthesized\n     */\n    function tokenParenthesized(stream, state) {\n      stream.next(); // Must be \"(\"\n      if (!stream.match(/\\s*[\\\"\\')]/, false))\n        state.tokenize = tokenString(\")\");\n      else\n        state.tokenize = null;\n      return [null, \"(\"];\n    }\n\n    /**\n     * Context management\n     */\n    function Context(type, indent, prev, line) {\n      this.type = type;\n      this.indent = indent;\n      this.prev = prev;\n      this.line = line || {firstWord: \"\", indent: 0};\n    }\n\n    function pushContext(state, stream, type, indent) {\n      indent = indent >= 0 ? indent : indentUnit;\n      state.context = new Context(type, stream.indentation() + indent, state.context);\n      return type;\n    }\n\n    function popContext(state, currentIndent) {\n      var contextIndent = state.context.indent - indentUnit;\n      currentIndent = currentIndent || false;\n      state.context = state.context.prev;\n      if (currentIndent) state.context.indent = contextIndent;\n      return state.context.type;\n    }\n\n    function pass(type, stream, state) {\n      return states[state.context.type](type, stream, state);\n    }\n\n    function popAndPass(type, stream, state, n) {\n      for (var i = n || 1; i > 0; i--)\n        state.context = state.context.prev;\n      return pass(type, stream, state);\n    }\n\n\n    /**\n     * Parser\n     */\n    function wordIsTag(word) {\n      return word.toLowerCase() in tagKeywords;\n    }\n\n    function wordIsProperty(word) {\n      word = word.toLowerCase();\n      return word in propertyKeywords || word in fontProperties;\n    }\n\n    function wordIsBlock(word) {\n      return word.toLowerCase() in blockKeywords;\n    }\n\n    function wordIsVendorPrefix(word) {\n      return word.toLowerCase().match(vendorPrefixesRegexp);\n    }\n\n    function wordAsValue(word) {\n      var wordLC = word.toLowerCase();\n      var override = \"variable-2\";\n      if (wordIsTag(word)) override = \"tag\";\n      else if (wordIsBlock(word)) override = \"block-keyword\";\n      else if (wordIsProperty(word)) override = \"property\";\n      else if (wordLC in valueKeywords || wordLC in commonAtoms) override = \"atom\";\n      else if (wordLC == \"return\" || wordLC in colorKeywords) override = \"keyword\";\n\n      // Font family\n      else if (word.match(/^[A-Z]/)) override = \"string\";\n      return override;\n    }\n\n    function typeIsBlock(type, stream) {\n      return ((endOfLine(stream) && (type == \"{\" || type == \"]\" || type == \"hash\" || type == \"qualifier\")) || type == \"block-mixin\");\n    }\n\n    function typeIsInterpolation(type, stream) {\n      return type == \"{\" && stream.match(/^\\s*\\$?[\\w-]+/i, false);\n    }\n\n    function typeIsPseudo(type, stream) {\n      return type == \":\" && stream.match(/^[a-z-]+/, false);\n    }\n\n    function startOfLine(stream) {\n      return stream.sol() || stream.string.match(new RegExp(\"^\\\\s*\" + escapeRegExp(stream.current())));\n    }\n\n    function endOfLine(stream) {\n      return stream.eol() || stream.match(/^\\s*$/, false);\n    }\n\n    function firstWordOfLine(line) {\n      var re = /^\\s*[-_]*[a-z0-9]+[\\w-]*/i;\n      var result = typeof line == \"string\" ? line.match(re) : line.string.match(re);\n      return result ? result[0].replace(/^\\s*/, \"\") : \"\";\n    }\n\n\n    /**\n     * Block\n     */\n    states.block = function(type, stream, state) {\n      if ((type == \"comment\" && startOfLine(stream)) ||\n          (type == \",\" && endOfLine(stream)) ||\n          type == \"mixin\") {\n        return pushContext(state, stream, \"block\", 0);\n      }\n      if (typeIsInterpolation(type, stream)) {\n        return pushContext(state, stream, \"interpolation\");\n      }\n      if (endOfLine(stream) && type == \"]\") {\n        if (!/^\\s*(\\.|#|:|\\[|\\*|&)/.test(stream.string) && !wordIsTag(firstWordOfLine(stream))) {\n          return pushContext(state, stream, \"block\", 0);\n        }\n      }\n      if (typeIsBlock(type, stream)) {\n        return pushContext(state, stream, \"block\");\n      }\n      if (type == \"}\" && endOfLine(stream)) {\n        return pushContext(state, stream, \"block\", 0);\n      }\n      if (type == \"variable-name\") {\n        if (stream.string.match(/^\\s?\\$[\\w-\\.\\[\\]\\'\\\"]+$/) || wordIsBlock(firstWordOfLine(stream))) {\n          return pushContext(state, stream, \"variableName\");\n        }\n        else {\n          return pushContext(state, stream, \"variableName\", 0);\n        }\n      }\n      if (type == \"=\") {\n        if (!endOfLine(stream) && !wordIsBlock(firstWordOfLine(stream))) {\n          return pushContext(state, stream, \"block\", 0);\n        }\n        return pushContext(state, stream, \"block\");\n      }\n      if (type == \"*\") {\n        if (endOfLine(stream) || stream.match(/\\s*(,|\\.|#|\\[|:|{)/,false)) {\n          override = \"tag\";\n          return pushContext(state, stream, \"block\");\n        }\n      }\n      if (typeIsPseudo(type, stream)) {\n        return pushContext(state, stream, \"pseudo\");\n      }\n      if (/@(font-face|media|supports|(-moz-)?document)/.test(type)) {\n        return pushContext(state, stream, endOfLine(stream) ? \"block\" : \"atBlock\");\n      }\n      if (/@(-(moz|ms|o|webkit)-)?keyframes$/.test(type)) {\n        return pushContext(state, stream, \"keyframes\");\n      }\n      if (/@extends?/.test(type)) {\n        return pushContext(state, stream, \"extend\", 0);\n      }\n      if (type && type.charAt(0) == \"@\") {\n\n        // Property Lookup\n        if (stream.indentation() > 0 && wordIsProperty(stream.current().slice(1))) {\n          override = \"variable-2\";\n          return \"block\";\n        }\n        if (/(@import|@require|@charset)/.test(type)) {\n          return pushContext(state, stream, \"block\", 0);\n        }\n        return pushContext(state, stream, \"block\");\n      }\n      if (type == \"reference\" && endOfLine(stream)) {\n        return pushContext(state, stream, \"block\");\n      }\n      if (type == \"(\") {\n        return pushContext(state, stream, \"parens\");\n      }\n\n      if (type == \"vendor-prefixes\") {\n        return pushContext(state, stream, \"vendorPrefixes\");\n      }\n      if (type == \"word\") {\n        var word = stream.current();\n        override = wordAsValue(word);\n\n        if (override == \"property\") {\n          if (startOfLine(stream)) {\n            return pushContext(state, stream, \"block\", 0);\n          } else {\n            override = \"atom\";\n            return \"block\";\n          }\n        }\n\n        if (override == \"tag\") {\n\n          // tag is a css value\n          if (/embed|menu|pre|progress|sub|table/.test(word)) {\n            if (wordIsProperty(firstWordOfLine(stream))) {\n              override = \"atom\";\n              return \"block\";\n            }\n          }\n\n          // tag is an attribute\n          if (stream.string.match(new RegExp(\"\\\\[\\\\s*\" + word + \"|\" + word +\"\\\\s*\\\\]\"))) {\n            override = \"atom\";\n            return \"block\";\n          }\n\n          // tag is a variable\n          if (tagVariablesRegexp.test(word)) {\n            if ((startOfLine(stream) && stream.string.match(/=/)) ||\n                (!startOfLine(stream) &&\n                 !stream.string.match(/^(\\s*\\.|#|\\&|\\[|\\/|>|\\*)/) &&\n                 !wordIsTag(firstWordOfLine(stream)))) {\n              override = \"variable-2\";\n              if (wordIsBlock(firstWordOfLine(stream)))  return \"block\";\n              return pushContext(state, stream, \"block\", 0);\n            }\n          }\n\n          if (endOfLine(stream)) return pushContext(state, stream, \"block\");\n        }\n        if (override == \"block-keyword\") {\n          override = \"keyword\";\n\n          // Postfix conditionals\n          if (stream.current(/(if|unless)/) && !startOfLine(stream)) {\n            return \"block\";\n          }\n          return pushContext(state, stream, \"block\");\n        }\n        if (word == \"return\") return pushContext(state, stream, \"block\", 0);\n\n        // Placeholder selector\n        if (override == \"variable-2\" && stream.string.match(/^\\s?\\$[\\w-\\.\\[\\]\\'\\\"]+$/)) {\n          return pushContext(state, stream, \"block\");\n        }\n      }\n      return state.context.type;\n    };\n\n\n    /**\n     * Parens\n     */\n    states.parens = function(type, stream, state) {\n      if (type == \"(\") return pushContext(state, stream, \"parens\");\n      if (type == \")\") {\n        if (state.context.prev.type == \"parens\") {\n          return popContext(state);\n        }\n        if ((stream.string.match(/^[a-z][\\w-]*\\(/i) && endOfLine(stream)) ||\n            wordIsBlock(firstWordOfLine(stream)) ||\n            /(\\.|#|:|\\[|\\*|&|>|~|\\+|\\/)/.test(firstWordOfLine(stream)) ||\n            (!stream.string.match(/^-?[a-z][\\w-\\.\\[\\]\\'\\\"]*\\s*=/) &&\n             wordIsTag(firstWordOfLine(stream)))) {\n          return pushContext(state, stream, \"block\");\n        }\n        if (stream.string.match(/^[\\$-]?[a-z][\\w-\\.\\[\\]\\'\\\"]*\\s*=/) ||\n            stream.string.match(/^\\s*(\\(|\\)|[0-9])/) ||\n            stream.string.match(/^\\s+[a-z][\\w-]*\\(/i) ||\n            stream.string.match(/^\\s+[\\$-]?[a-z]/i)) {\n          return pushContext(state, stream, \"block\", 0);\n        }\n        if (endOfLine(stream)) return pushContext(state, stream, \"block\");\n        else return pushContext(state, stream, \"block\", 0);\n      }\n      if (type && type.charAt(0) == \"@\" && wordIsProperty(stream.current().slice(1))) {\n        override = \"variable-2\";\n      }\n      if (type == \"word\") {\n        var word = stream.current();\n        override = wordAsValue(word);\n        if (override == \"tag\" && tagVariablesRegexp.test(word)) {\n          override = \"variable-2\";\n        }\n        if (override == \"property\" || word == \"to\") override = \"atom\";\n      }\n      if (type == \"variable-name\") {\n        return pushContext(state, stream, \"variableName\");\n      }\n      if (typeIsPseudo(type, stream)) {\n        return pushContext(state, stream, \"pseudo\");\n      }\n      return state.context.type;\n    };\n\n\n    /**\n     * Vendor prefixes\n     */\n    states.vendorPrefixes = function(type, stream, state) {\n      if (type == \"word\") {\n        override = \"property\";\n        return pushContext(state, stream, \"block\", 0);\n      }\n      return popContext(state);\n    };\n\n\n    /**\n     * Pseudo\n     */\n    states.pseudo = function(type, stream, state) {\n      if (!wordIsProperty(firstWordOfLine(stream.string))) {\n        stream.match(/^[a-z-]+/);\n        override = \"variable-3\";\n        if (endOfLine(stream)) return pushContext(state, stream, \"block\");\n        return popContext(state);\n      }\n      return popAndPass(type, stream, state);\n    };\n\n\n    /**\n     * atBlock\n     */\n    states.atBlock = function(type, stream, state) {\n      if (type == \"(\") return pushContext(state, stream, \"atBlock_parens\");\n      if (typeIsBlock(type, stream)) {\n        return pushContext(state, stream, \"block\");\n      }\n      if (typeIsInterpolation(type, stream)) {\n        return pushContext(state, stream, \"interpolation\");\n      }\n      if (type == \"word\") {\n        var word = stream.current().toLowerCase();\n        if (/^(only|not|and|or)$/.test(word))\n          override = \"keyword\";\n        else if (documentTypes.hasOwnProperty(word))\n          override = \"tag\";\n        else if (mediaTypes.hasOwnProperty(word))\n          override = \"attribute\";\n        else if (mediaFeatures.hasOwnProperty(word))\n          override = \"property\";\n        else if (nonStandardPropertyKeywords.hasOwnProperty(word))\n          override = \"string-2\";\n        else override = wordAsValue(stream.current());\n        if (override == \"tag\" && endOfLine(stream)) {\n          return pushContext(state, stream, \"block\");\n        }\n      }\n      if (type == \"operator\" && /^(not|and|or)$/.test(stream.current())) {\n        override = \"keyword\";\n      }\n      return state.context.type;\n    };\n\n    states.atBlock_parens = function(type, stream, state) {\n      if (type == \"{\" || type == \"}\") return state.context.type;\n      if (type == \")\") {\n        if (endOfLine(stream)) return pushContext(state, stream, \"block\");\n        else return pushContext(state, stream, \"atBlock\");\n      }\n      if (type == \"word\") {\n        var word = stream.current().toLowerCase();\n        override = wordAsValue(word);\n        if (/^(max|min)/.test(word)) override = \"property\";\n        if (override == \"tag\") {\n          tagVariablesRegexp.test(word) ? override = \"variable-2\" : override = \"atom\";\n        }\n        return state.context.type;\n      }\n      return states.atBlock(type, stream, state);\n    };\n\n\n    /**\n     * Keyframes\n     */\n    states.keyframes = function(type, stream, state) {\n      if (stream.indentation() == \"0\" && ((type == \"}\" && startOfLine(stream)) || type == \"]\" || type == \"hash\"\n                                          || type == \"qualifier\" || wordIsTag(stream.current()))) {\n        return popAndPass(type, stream, state);\n      }\n      if (type == \"{\") return pushContext(state, stream, \"keyframes\");\n      if (type == \"}\") {\n        if (startOfLine(stream)) return popContext(state, true);\n        else return pushContext(state, stream, \"keyframes\");\n      }\n      if (type == \"unit\" && /^[0-9]+\\%$/.test(stream.current())) {\n        return pushContext(state, stream, \"keyframes\");\n      }\n      if (type == \"word\") {\n        override = wordAsValue(stream.current());\n        if (override == \"block-keyword\") {\n          override = \"keyword\";\n          return pushContext(state, stream, \"keyframes\");\n        }\n      }\n      if (/@(font-face|media|supports|(-moz-)?document)/.test(type)) {\n        return pushContext(state, stream, endOfLine(stream) ? \"block\" : \"atBlock\");\n      }\n      if (type == \"mixin\") {\n        return pushContext(state, stream, \"block\", 0);\n      }\n      return state.context.type;\n    };\n\n\n    /**\n     * Interpolation\n     */\n    states.interpolation = function(type, stream, state) {\n      if (type == \"{\") popContext(state) && pushContext(state, stream, \"block\");\n      if (type == \"}\") {\n        if (stream.string.match(/^\\s*(\\.|#|:|\\[|\\*|&|>|~|\\+|\\/)/i) ||\n            (stream.string.match(/^\\s*[a-z]/i) && wordIsTag(firstWordOfLine(stream)))) {\n          return pushContext(state, stream, \"block\");\n        }\n        if (!stream.string.match(/^(\\{|\\s*\\&)/) ||\n            stream.match(/\\s*[\\w-]/,false)) {\n          return pushContext(state, stream, \"block\", 0);\n        }\n        return pushContext(state, stream, \"block\");\n      }\n      if (type == \"variable-name\") {\n        return pushContext(state, stream, \"variableName\", 0);\n      }\n      if (type == \"word\") {\n        override = wordAsValue(stream.current());\n        if (override == \"tag\") override = \"atom\";\n      }\n      return state.context.type;\n    };\n\n\n    /**\n     * Extend/s\n     */\n    states.extend = function(type, stream, state) {\n      if (type == \"[\" || type == \"=\") return \"extend\";\n      if (type == \"]\") return popContext(state);\n      if (type == \"word\") {\n        override = wordAsValue(stream.current());\n        return \"extend\";\n      }\n      return popContext(state);\n    };\n\n\n    /**\n     * Variable name\n     */\n    states.variableName = function(type, stream, state) {\n      if (type == \"string\" || type == \"[\" || type == \"]\" || stream.current().match(/^(\\.|\\$)/)) {\n        if (stream.current().match(/^\\.[\\w-]+/i)) override = \"variable-2\";\n        return \"variableName\";\n      }\n      return popAndPass(type, stream, state);\n    };\n\n\n    return {\n      startState: function(base) {\n        return {\n          tokenize: null,\n          state: \"block\",\n          context: new Context(\"block\", base || 0, null)\n        };\n      },\n      token: function(stream, state) {\n        if (!state.tokenize && stream.eatSpace()) return null;\n        style = (state.tokenize || tokenBase)(stream, state);\n        if (style && typeof style == \"object\") {\n          type = style[1];\n          style = style[0];\n        }\n        override = style;\n        state.state = states[state.state](type, stream, state);\n        return override;\n      },\n      indent: function(state, textAfter, line) {\n\n        var cx = state.context,\n            ch = textAfter && textAfter.charAt(0),\n            indent = cx.indent,\n            lineFirstWord = firstWordOfLine(textAfter),\n            lineIndent = line.match(/^\\s*/)[0].replace(/\\t/g, indentUnitString).length,\n            prevLineFirstWord = state.context.prev ? state.context.prev.line.firstWord : \"\",\n            prevLineIndent = state.context.prev ? state.context.prev.line.indent : lineIndent;\n\n        if (cx.prev &&\n            (ch == \"}\" && (cx.type == \"block\" || cx.type == \"atBlock\" || cx.type == \"keyframes\") ||\n             ch == \")\" && (cx.type == \"parens\" || cx.type == \"atBlock_parens\") ||\n             ch == \"{\" && (cx.type == \"at\"))) {\n          indent = cx.indent - indentUnit;\n        } else if (!(/(\\})/.test(ch))) {\n          if (/@|\\$|\\d/.test(ch) ||\n              /^\\{/.test(textAfter) ||\n/^\\s*\\/(\\/|\\*)/.test(textAfter) ||\n              /^\\s*\\/\\*/.test(prevLineFirstWord) ||\n              /^\\s*[\\w-\\.\\[\\]\\'\\\"]+\\s*(\\?|:|\\+)?=/i.test(textAfter) ||\n/^(\\+|-)?[a-z][\\w-]*\\(/i.test(textAfter) ||\n/^return/.test(textAfter) ||\n              wordIsBlock(lineFirstWord)) {\n            indent = lineIndent;\n          } else if (/(\\.|#|:|\\[|\\*|&|>|~|\\+|\\/)/.test(ch) || wordIsTag(lineFirstWord)) {\n            if (/\\,\\s*$/.test(prevLineFirstWord)) {\n              indent = prevLineIndent;\n            } else if (/^\\s+/.test(line) && (/(\\.|#|:|\\[|\\*|&|>|~|\\+|\\/)/.test(prevLineFirstWord) || wordIsTag(prevLineFirstWord))) {\n              indent = lineIndent <= prevLineIndent ? prevLineIndent : prevLineIndent + indentUnit;\n            } else {\n              indent = lineIndent;\n            }\n          } else if (!/,\\s*$/.test(line) && (wordIsVendorPrefix(lineFirstWord) || wordIsProperty(lineFirstWord))) {\n            if (wordIsBlock(prevLineFirstWord)) {\n              indent = lineIndent <= prevLineIndent ? prevLineIndent : prevLineIndent + indentUnit;\n            } else if (/^\\{/.test(prevLineFirstWord)) {\n              indent = lineIndent <= prevLineIndent ? lineIndent : prevLineIndent + indentUnit;\n            } else if (wordIsVendorPrefix(prevLineFirstWord) || wordIsProperty(prevLineFirstWord)) {\n              indent = lineIndent >= prevLineIndent ? prevLineIndent : lineIndent;\n            } else if (/^(\\.|#|:|\\[|\\*|&|@|\\+|\\-|>|~|\\/)/.test(prevLineFirstWord) ||\n                      /=\\s*$/.test(prevLineFirstWord) ||\n                      wordIsTag(prevLineFirstWord) ||\n                      /^\\$[\\w-\\.\\[\\]\\'\\\"]/.test(prevLineFirstWord)) {\n              indent = prevLineIndent + indentUnit;\n            } else {\n              indent = lineIndent;\n            }\n          }\n        }\n        return indent;\n      },\n      electricChars: \"}\",\n      lineComment: \"//\",\n      fold: \"indent\"\n    };\n  });\n\n  // developer.mozilla.org/en-US/docs/Web/HTML/Element\n  var tagKeywords_ = [\"a\",\"abbr\",\"address\",\"area\",\"article\",\"aside\",\"audio\", \"b\", \"base\",\"bdi\", \"bdo\",\"bgsound\",\"blockquote\",\"body\",\"br\",\"button\",\"canvas\",\"caption\",\"cite\", \"code\",\"col\",\"colgroup\",\"data\",\"datalist\",\"dd\",\"del\",\"details\",\"dfn\",\"div\", \"dl\",\"dt\",\"em\",\"embed\",\"fieldset\",\"figcaption\",\"figure\",\"footer\",\"form\",\"h1\", \"h2\",\"h3\",\"h4\",\"h5\",\"h6\",\"head\",\"header\",\"hgroup\",\"hr\",\"html\",\"i\",\"iframe\", \"img\",\"input\",\"ins\",\"kbd\",\"keygen\",\"label\",\"legend\",\"li\",\"link\",\"main\",\"map\", \"mark\",\"marquee\",\"menu\",\"menuitem\",\"meta\",\"meter\",\"nav\",\"nobr\",\"noframes\", \"noscript\",\"object\",\"ol\",\"optgroup\",\"option\",\"output\",\"p\",\"param\",\"pre\", \"progress\",\"q\",\"rp\",\"rt\",\"ruby\",\"s\",\"samp\",\"script\",\"section\",\"select\", \"small\",\"source\",\"span\",\"strong\",\"style\",\"sub\",\"summary\",\"sup\",\"table\",\"tbody\",\"td\",\"textarea\",\"tfoot\",\"th\",\"thead\",\"time\",\"tr\",\"track\", \"u\",\"ul\",\"var\",\"video\"];\n\n  // github.com/codemirror/CodeMirror/blob/master/mode/css/css.js\n  var documentTypes_ = [\"domain\", \"regexp\", \"url\", \"url-prefix\"];\n  var mediaTypes_ = [\"all\",\"aural\",\"braille\",\"handheld\",\"print\",\"projection\",\"screen\",\"tty\",\"tv\",\"embossed\"];\n  var mediaFeatures_ = [\"width\",\"min-width\",\"max-width\",\"height\",\"min-height\",\"max-height\",\"device-width\",\"min-device-width\",\"max-device-width\",\"device-height\",\"min-device-height\",\"max-device-height\",\"aspect-ratio\",\"min-aspect-ratio\",\"max-aspect-ratio\",\"device-aspect-ratio\",\"min-device-aspect-ratio\",\"max-device-aspect-ratio\",\"color\",\"min-color\",\"max-color\",\"color-index\",\"min-color-index\",\"max-color-index\",\"monochrome\",\"min-monochrome\",\"max-monochrome\",\"resolution\",\"min-resolution\",\"max-resolution\",\"scan\",\"grid\"];\n  var propertyKeywords_ = [\"align-content\",\"align-items\",\"align-self\",\"alignment-adjust\",\"alignment-baseline\",\"anchor-point\",\"animation\",\"animation-delay\",\"animation-direction\",\"animation-duration\",\"animation-fill-mode\",\"animation-iteration-count\",\"animation-name\",\"animation-play-state\",\"animation-timing-function\",\"appearance\",\"azimuth\",\"backface-visibility\",\"background\",\"background-attachment\",\"background-clip\",\"background-color\",\"background-image\",\"background-origin\",\"background-position\",\"background-repeat\",\"background-size\",\"baseline-shift\",\"binding\",\"bleed\",\"bookmark-label\",\"bookmark-level\",\"bookmark-state\",\"bookmark-target\",\"border\",\"border-bottom\",\"border-bottom-color\",\"border-bottom-left-radius\",\"border-bottom-right-radius\",\"border-bottom-style\",\"border-bottom-width\",\"border-collapse\",\"border-color\",\"border-image\",\"border-image-outset\",\"border-image-repeat\",\"border-image-slice\",\"border-image-source\",\"border-image-width\",\"border-left\",\"border-left-color\",\"border-left-style\",\"border-left-width\",\"border-radius\",\"border-right\",\"border-right-color\",\"border-right-style\",\"border-right-width\",\"border-spacing\",\"border-style\",\"border-top\",\"border-top-color\",\"border-top-left-radius\",\"border-top-right-radius\",\"border-top-style\",\"border-top-width\",\"border-width\",\"bottom\",\"box-decoration-break\",\"box-shadow\",\"box-sizing\",\"break-after\",\"break-before\",\"break-inside\",\"caption-side\",\"clear\",\"clip\",\"color\",\"color-profile\",\"column-count\",\"column-fill\",\"column-gap\",\"column-rule\",\"column-rule-color\",\"column-rule-style\",\"column-rule-width\",\"column-span\",\"column-width\",\"columns\",\"content\",\"counter-increment\",\"counter-reset\",\"crop\",\"cue\",\"cue-after\",\"cue-before\",\"cursor\",\"direction\",\"display\",\"dominant-baseline\",\"drop-initial-after-adjust\",\"drop-initial-after-align\",\"drop-initial-before-adjust\",\"drop-initial-before-align\",\"drop-initial-size\",\"drop-initial-value\",\"elevation\",\"empty-cells\",\"fit\",\"fit-position\",\"flex\",\"flex-basis\",\"flex-direction\",\"flex-flow\",\"flex-grow\",\"flex-shrink\",\"flex-wrap\",\"float\",\"float-offset\",\"flow-from\",\"flow-into\",\"font\",\"font-feature-settings\",\"font-family\",\"font-kerning\",\"font-language-override\",\"font-size\",\"font-size-adjust\",\"font-stretch\",\"font-style\",\"font-synthesis\",\"font-variant\",\"font-variant-alternates\",\"font-variant-caps\",\"font-variant-east-asian\",\"font-variant-ligatures\",\"font-variant-numeric\",\"font-variant-position\",\"font-weight\",\"grid\",\"grid-area\",\"grid-auto-columns\",\"grid-auto-flow\",\"grid-auto-position\",\"grid-auto-rows\",\"grid-column\",\"grid-column-end\",\"grid-column-start\",\"grid-row\",\"grid-row-end\",\"grid-row-start\",\"grid-template\",\"grid-template-areas\",\"grid-template-columns\",\"grid-template-rows\",\"hanging-punctuation\",\"height\",\"hyphens\",\"icon\",\"image-orientation\",\"image-rendering\",\"image-resolution\",\"inline-box-align\",\"justify-content\",\"left\",\"letter-spacing\",\"line-break\",\"line-height\",\"line-stacking\",\"line-stacking-ruby\",\"line-stacking-shift\",\"line-stacking-strategy\",\"list-style\",\"list-style-image\",\"list-style-position\",\"list-style-type\",\"margin\",\"margin-bottom\",\"margin-left\",\"margin-right\",\"margin-top\",\"marker-offset\",\"marks\",\"marquee-direction\",\"marquee-loop\",\"marquee-play-count\",\"marquee-speed\",\"marquee-style\",\"max-height\",\"max-width\",\"min-height\",\"min-width\",\"move-to\",\"nav-down\",\"nav-index\",\"nav-left\",\"nav-right\",\"nav-up\",\"object-fit\",\"object-position\",\"opacity\",\"order\",\"orphans\",\"outline\",\"outline-color\",\"outline-offset\",\"outline-style\",\"outline-width\",\"overflow\",\"overflow-style\",\"overflow-wrap\",\"overflow-x\",\"overflow-y\",\"padding\",\"padding-bottom\",\"padding-left\",\"padding-right\",\"padding-top\",\"page\",\"page-break-after\",\"page-break-before\",\"page-break-inside\",\"page-policy\",\"pause\",\"pause-after\",\"pause-before\",\"perspective\",\"perspective-origin\",\"pitch\",\"pitch-range\",\"play-during\",\"position\",\"presentation-level\",\"punctuation-trim\",\"quotes\",\"region-break-after\",\"region-break-before\",\"region-break-inside\",\"region-fragment\",\"rendering-intent\",\"resize\",\"rest\",\"rest-after\",\"rest-before\",\"richness\",\"right\",\"rotation\",\"rotation-point\",\"ruby-align\",\"ruby-overhang\",\"ruby-position\",\"ruby-span\",\"shape-image-threshold\",\"shape-inside\",\"shape-margin\",\"shape-outside\",\"size\",\"speak\",\"speak-as\",\"speak-header\",\"speak-numeral\",\"speak-punctuation\",\"speech-rate\",\"stress\",\"string-set\",\"tab-size\",\"table-layout\",\"target\",\"target-name\",\"target-new\",\"target-position\",\"text-align\",\"text-align-last\",\"text-decoration\",\"text-decoration-color\",\"text-decoration-line\",\"text-decoration-skip\",\"text-decoration-style\",\"text-emphasis\",\"text-emphasis-color\",\"text-emphasis-position\",\"text-emphasis-style\",\"text-height\",\"text-indent\",\"text-justify\",\"text-outline\",\"text-overflow\",\"text-shadow\",\"text-size-adjust\",\"text-space-collapse\",\"text-transform\",\"text-underline-position\",\"text-wrap\",\"top\",\"transform\",\"transform-origin\",\"transform-style\",\"transition\",\"transition-delay\",\"transition-duration\",\"transition-property\",\"transition-timing-function\",\"unicode-bidi\",\"vertical-align\",\"visibility\",\"voice-balance\",\"voice-duration\",\"voice-family\",\"voice-pitch\",\"voice-range\",\"voice-rate\",\"voice-stress\",\"voice-volume\",\"volume\",\"white-space\",\"widows\",\"width\",\"will-change\",\"word-break\",\"word-spacing\",\"word-wrap\",\"z-index\",\"clip-path\",\"clip-rule\",\"mask\",\"enable-background\",\"filter\",\"flood-color\",\"flood-opacity\",\"lighting-color\",\"stop-color\",\"stop-opacity\",\"pointer-events\",\"color-interpolation\",\"color-interpolation-filters\",\"color-rendering\",\"fill\",\"fill-opacity\",\"fill-rule\",\"image-rendering\",\"marker\",\"marker-end\",\"marker-mid\",\"marker-start\",\"shape-rendering\",\"stroke\",\"stroke-dasharray\",\"stroke-dashoffset\",\"stroke-linecap\",\"stroke-linejoin\",\"stroke-miterlimit\",\"stroke-opacity\",\"stroke-width\",\"text-rendering\",\"baseline-shift\",\"dominant-baseline\",\"glyph-orientation-horizontal\",\"glyph-orientation-vertical\",\"text-anchor\",\"writing-mode\",\"font-smoothing\",\"osx-font-smoothing\"];\n  var nonStandardPropertyKeywords_ = [\"scrollbar-arrow-color\",\"scrollbar-base-color\",\"scrollbar-dark-shadow-color\",\"scrollbar-face-color\",\"scrollbar-highlight-color\",\"scrollbar-shadow-color\",\"scrollbar-3d-light-color\",\"scrollbar-track-color\",\"shape-inside\",\"searchfield-cancel-button\",\"searchfield-decoration\",\"searchfield-results-button\",\"searchfield-results-decoration\",\"zoom\"];\n  var fontProperties_ = [\"font-family\",\"src\",\"unicode-range\",\"font-variant\",\"font-feature-settings\",\"font-stretch\",\"font-weight\",\"font-style\"];\n  var colorKeywords_ = [\"aliceblue\",\"antiquewhite\",\"aqua\",\"aquamarine\",\"azure\",\"beige\",\"bisque\",\"black\",\"blanchedalmond\",\"blue\",\"blueviolet\",\"brown\",\"burlywood\",\"cadetblue\",\"chartreuse\",\"chocolate\",\"coral\",\"cornflowerblue\",\"cornsilk\",\"crimson\",\"cyan\",\"darkblue\",\"darkcyan\",\"darkgoldenrod\",\"darkgray\",\"darkgreen\",\"darkkhaki\",\"darkmagenta\",\"darkolivegreen\",\"darkorange\",\"darkorchid\",\"darkred\",\"darksalmon\",\"darkseagreen\",\"darkslateblue\",\"darkslategray\",\"darkturquoise\",\"darkviolet\",\"deeppink\",\"deepskyblue\",\"dimgray\",\"dodgerblue\",\"firebrick\",\"floralwhite\",\"forestgreen\",\"fuchsia\",\"gainsboro\",\"ghostwhite\",\"gold\",\"goldenrod\",\"gray\",\"grey\",\"green\",\"greenyellow\",\"honeydew\",\"hotpink\",\"indianred\",\"indigo\",\"ivory\",\"khaki\",\"lavender\",\"lavenderblush\",\"lawngreen\",\"lemonchiffon\",\"lightblue\",\"lightcoral\",\"lightcyan\",\"lightgoldenrodyellow\",\"lightgray\",\"lightgreen\",\"lightpink\",\"lightsalmon\",\"lightseagreen\",\"lightskyblue\",\"lightslategray\",\"lightsteelblue\",\"lightyellow\",\"lime\",\"limegreen\",\"linen\",\"magenta\",\"maroon\",\"mediumaquamarine\",\"mediumblue\",\"mediumorchid\",\"mediumpurple\",\"mediumseagreen\",\"mediumslateblue\",\"mediumspringgreen\",\"mediumturquoise\",\"mediumvioletred\",\"midnightblue\",\"mintcream\",\"mistyrose\",\"moccasin\",\"navajowhite\",\"navy\",\"oldlace\",\"olive\",\"olivedrab\",\"orange\",\"orangered\",\"orchid\",\"palegoldenrod\",\"palegreen\",\"paleturquoise\",\"palevioletred\",\"papayawhip\",\"peachpuff\",\"peru\",\"pink\",\"plum\",\"powderblue\",\"purple\",\"rebeccapurple\",\"red\",\"rosybrown\",\"royalblue\",\"saddlebrown\",\"salmon\",\"sandybrown\",\"seagreen\",\"seashell\",\"sienna\",\"silver\",\"skyblue\",\"slateblue\",\"slategray\",\"snow\",\"springgreen\",\"steelblue\",\"tan\",\"teal\",\"thistle\",\"tomato\",\"turquoise\",\"violet\",\"wheat\",\"white\",\"whitesmoke\",\"yellow\",\"yellowgreen\"];\n  var valueKeywords_ = [\"above\",\"absolute\",\"activeborder\",\"additive\",\"activecaption\",\"afar\",\"after-white-space\",\"ahead\",\"alias\",\"all\",\"all-scroll\",\"alphabetic\",\"alternate\",\"always\",\"amharic\",\"amharic-abegede\",\"antialiased\",\"appworkspace\",\"arabic-indic\",\"armenian\",\"asterisks\",\"attr\",\"auto\",\"avoid\",\"avoid-column\",\"avoid-page\",\"avoid-region\",\"background\",\"backwards\",\"baseline\",\"below\",\"bidi-override\",\"binary\",\"bengali\",\"blink\",\"block\",\"block-axis\",\"bold\",\"bolder\",\"border\",\"border-box\",\"both\",\"bottom\",\"break\",\"break-all\",\"break-word\",\"bullets\",\"button\",\"button-bevel\",\"buttonface\",\"buttonhighlight\",\"buttonshadow\",\"buttontext\",\"calc\",\"cambodian\",\"capitalize\",\"caps-lock-indicator\",\"caption\",\"captiontext\",\"caret\",\"cell\",\"center\",\"checkbox\",\"circle\",\"cjk-decimal\",\"cjk-earthly-branch\",\"cjk-heavenly-stem\",\"cjk-ideographic\",\"clear\",\"clip\",\"close-quote\",\"col-resize\",\"collapse\",\"column\",\"compact\",\"condensed\",\"contain\",\"content\",\"contents\",\"content-box\",\"context-menu\",\"continuous\",\"copy\",\"counter\",\"counters\",\"cover\",\"crop\",\"cross\",\"crosshair\",\"currentcolor\",\"cursive\",\"cyclic\",\"dashed\",\"decimal\",\"decimal-leading-zero\",\"default\",\"default-button\",\"destination-atop\",\"destination-in\",\"destination-out\",\"destination-over\",\"devanagari\",\"disc\",\"discard\",\"disclosure-closed\",\"disclosure-open\",\"document\",\"dot-dash\",\"dot-dot-dash\",\"dotted\",\"double\",\"down\",\"e-resize\",\"ease\",\"ease-in\",\"ease-in-out\",\"ease-out\",\"element\",\"ellipse\",\"ellipsis\",\"embed\",\"end\",\"ethiopic\",\"ethiopic-abegede\",\"ethiopic-abegede-am-et\",\"ethiopic-abegede-gez\",\"ethiopic-abegede-ti-er\",\"ethiopic-abegede-ti-et\",\"ethiopic-halehame-aa-er\",\"ethiopic-halehame-aa-et\",\"ethiopic-halehame-am-et\",\"ethiopic-halehame-gez\",\"ethiopic-halehame-om-et\",\"ethiopic-halehame-sid-et\",\"ethiopic-halehame-so-et\",\"ethiopic-halehame-ti-er\",\"ethiopic-halehame-ti-et\",\"ethiopic-halehame-tig\",\"ethiopic-numeric\",\"ew-resize\",\"expanded\",\"extends\",\"extra-condensed\",\"extra-expanded\",\"fantasy\",\"fast\",\"fill\",\"fixed\",\"flat\",\"flex\",\"footnotes\",\"forwards\",\"from\",\"geometricPrecision\",\"georgian\",\"graytext\",\"groove\",\"gujarati\",\"gurmukhi\",\"hand\",\"hangul\",\"hangul-consonant\",\"hebrew\",\"help\",\"hidden\",\"hide\",\"higher\",\"highlight\",\"highlighttext\",\"hiragana\",\"hiragana-iroha\",\"horizontal\",\"hsl\",\"hsla\",\"icon\",\"ignore\",\"inactiveborder\",\"inactivecaption\",\"inactivecaptiontext\",\"infinite\",\"infobackground\",\"infotext\",\"inherit\",\"initial\",\"inline\",\"inline-axis\",\"inline-block\",\"inline-flex\",\"inline-table\",\"inset\",\"inside\",\"intrinsic\",\"invert\",\"italic\",\"japanese-formal\",\"japanese-informal\",\"justify\",\"kannada\",\"katakana\",\"katakana-iroha\",\"keep-all\",\"khmer\",\"korean-hangul-formal\",\"korean-hanja-formal\",\"korean-hanja-informal\",\"landscape\",\"lao\",\"large\",\"larger\",\"left\",\"level\",\"lighter\",\"line-through\",\"linear\",\"linear-gradient\",\"lines\",\"list-item\",\"listbox\",\"listitem\",\"local\",\"logical\",\"loud\",\"lower\",\"lower-alpha\",\"lower-armenian\",\"lower-greek\",\"lower-hexadecimal\",\"lower-latin\",\"lower-norwegian\",\"lower-roman\",\"lowercase\",\"ltr\",\"malayalam\",\"match\",\"matrix\",\"matrix3d\",\"media-controls-background\",\"media-current-time-display\",\"media-fullscreen-button\",\"media-mute-button\",\"media-play-button\",\"media-return-to-realtime-button\",\"media-rewind-button\",\"media-seek-back-button\",\"media-seek-forward-button\",\"media-slider\",\"media-sliderthumb\",\"media-time-remaining-display\",\"media-volume-slider\",\"media-volume-slider-container\",\"media-volume-sliderthumb\",\"medium\",\"menu\",\"menulist\",\"menulist-button\",\"menulist-text\",\"menulist-textfield\",\"menutext\",\"message-box\",\"middle\",\"min-intrinsic\",\"mix\",\"mongolian\",\"monospace\",\"move\",\"multiple\",\"myanmar\",\"n-resize\",\"narrower\",\"ne-resize\",\"nesw-resize\",\"no-close-quote\",\"no-drop\",\"no-open-quote\",\"no-repeat\",\"none\",\"normal\",\"not-allowed\",\"nowrap\",\"ns-resize\",\"numbers\",\"numeric\",\"nw-resize\",\"nwse-resize\",\"oblique\",\"octal\",\"open-quote\",\"optimizeLegibility\",\"optimizeSpeed\",\"oriya\",\"oromo\",\"outset\",\"outside\",\"outside-shape\",\"overlay\",\"overline\",\"padding\",\"padding-box\",\"painted\",\"page\",\"paused\",\"persian\",\"perspective\",\"plus-darker\",\"plus-lighter\",\"pointer\",\"polygon\",\"portrait\",\"pre\",\"pre-line\",\"pre-wrap\",\"preserve-3d\",\"progress\",\"push-button\",\"radial-gradient\",\"radio\",\"read-only\",\"read-write\",\"read-write-plaintext-only\",\"rectangle\",\"region\",\"relative\",\"repeat\",\"repeating-linear-gradient\",\"repeating-radial-gradient\",\"repeat-x\",\"repeat-y\",\"reset\",\"reverse\",\"rgb\",\"rgba\",\"ridge\",\"right\",\"rotate\",\"rotate3d\",\"rotateX\",\"rotateY\",\"rotateZ\",\"round\",\"row-resize\",\"rtl\",\"run-in\",\"running\",\"s-resize\",\"sans-serif\",\"scale\",\"scale3d\",\"scaleX\",\"scaleY\",\"scaleZ\",\"scroll\",\"scrollbar\",\"scroll-position\",\"se-resize\",\"searchfield\",\"searchfield-cancel-button\",\"searchfield-decoration\",\"searchfield-results-button\",\"searchfield-results-decoration\",\"semi-condensed\",\"semi-expanded\",\"separate\",\"serif\",\"show\",\"sidama\",\"simp-chinese-formal\",\"simp-chinese-informal\",\"single\",\"skew\",\"skewX\",\"skewY\",\"skip-white-space\",\"slide\",\"slider-horizontal\",\"slider-vertical\",\"sliderthumb-horizontal\",\"sliderthumb-vertical\",\"slow\",\"small\",\"small-caps\",\"small-caption\",\"smaller\",\"solid\",\"somali\",\"source-atop\",\"source-in\",\"source-out\",\"source-over\",\"space\",\"spell-out\",\"square\",\"square-button\",\"start\",\"static\",\"status-bar\",\"stretch\",\"stroke\",\"sub\",\"subpixel-antialiased\",\"super\",\"sw-resize\",\"symbolic\",\"symbols\",\"table\",\"table-caption\",\"table-cell\",\"table-column\",\"table-column-group\",\"table-footer-group\",\"table-header-group\",\"table-row\",\"table-row-group\",\"tamil\",\"telugu\",\"text\",\"text-bottom\",\"text-top\",\"textarea\",\"textfield\",\"thai\",\"thick\",\"thin\",\"threeddarkshadow\",\"threedface\",\"threedhighlight\",\"threedlightshadow\",\"threedshadow\",\"tibetan\",\"tigre\",\"tigrinya-er\",\"tigrinya-er-abegede\",\"tigrinya-et\",\"tigrinya-et-abegede\",\"to\",\"top\",\"trad-chinese-formal\",\"trad-chinese-informal\",\"translate\",\"translate3d\",\"translateX\",\"translateY\",\"translateZ\",\"transparent\",\"ultra-condensed\",\"ultra-expanded\",\"underline\",\"up\",\"upper-alpha\",\"upper-armenian\",\"upper-greek\",\"upper-hexadecimal\",\"upper-latin\",\"upper-norwegian\",\"upper-roman\",\"uppercase\",\"urdu\",\"url\",\"var\",\"vertical\",\"vertical-text\",\"visible\",\"visibleFill\",\"visiblePainted\",\"visibleStroke\",\"visual\",\"w-resize\",\"wait\",\"wave\",\"wider\",\"window\",\"windowframe\",\"windowtext\",\"words\",\"x-large\",\"x-small\",\"xor\",\"xx-large\",\"xx-small\",\"bicubic\",\"optimizespeed\",\"grayscale\",\"row\",\"row-reverse\",\"wrap\",\"wrap-reverse\",\"column-reverse\",\"flex-start\",\"flex-end\",\"space-between\",\"space-around\", \"unset\"];\n\n  var wordOperatorKeywords_ = [\"in\",\"and\",\"or\",\"not\",\"is not\",\"is a\",\"is\",\"isnt\",\"defined\",\"if unless\"],\n      blockKeywords_ = [\"for\",\"if\",\"else\",\"unless\", \"from\", \"to\"],\n      commonAtoms_ = [\"null\",\"true\",\"false\",\"href\",\"title\",\"type\",\"not-allowed\",\"readonly\",\"disabled\"],\n      commonDef_ = [\"@font-face\", \"@keyframes\", \"@media\", \"@viewport\", \"@page\", \"@host\", \"@supports\", \"@block\", \"@css\"];\n\n  var hintWords = tagKeywords_.concat(documentTypes_,mediaTypes_,mediaFeatures_,\n                                      propertyKeywords_,nonStandardPropertyKeywords_,\n                                      colorKeywords_,valueKeywords_,fontProperties_,\n                                      wordOperatorKeywords_,blockKeywords_,\n                                      commonAtoms_,commonDef_);\n\n  function wordRegexp(words) {\n    words = words.sort(function(a,b){return b > a;});\n    return new RegExp(\"^((\" + words.join(\")|(\") + \"))\\\\b\");\n  }\n\n  function keySet(array) {\n    var keys = {};\n    for (var i = 0; i < array.length; ++i) keys[array[i]] = true;\n    return keys;\n  }\n\n  function escapeRegExp(text) {\n    return text.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, \"\\\\$&\");\n  }\n\n  CodeMirror.registerHelper(\"hintWords\", \"stylus\", hintWords);\n  CodeMirror.defineMIME(\"text/x-styl\", \"stylus\");\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"css\", function(config, parserConfig) {\n  var inline = parserConfig.inline\n  if (!parserConfig.propertyKeywords) parserConfig = CodeMirror.resolveMode(\"text/css\");\n\n  var indentUnit = config.indentUnit,\n      tokenHooks = parserConfig.tokenHooks,\n      documentTypes = parserConfig.documentTypes || {},\n      mediaTypes = parserConfig.mediaTypes || {},\n      mediaFeatures = parserConfig.mediaFeatures || {},\n      mediaValueKeywords = parserConfig.mediaValueKeywords || {},\n      propertyKeywords = parserConfig.propertyKeywords || {},\n      nonStandardPropertyKeywords = parserConfig.nonStandardPropertyKeywords || {},\n      fontProperties = parserConfig.fontProperties || {},\n      counterDescriptors = parserConfig.counterDescriptors || {},\n      colorKeywords = parserConfig.colorKeywords || {},\n      valueKeywords = parserConfig.valueKeywords || {},\n      allowNested = parserConfig.allowNested,\n      lineComment = parserConfig.lineComment,\n      supportsAtComponent = parserConfig.supportsAtComponent === true;\n\n  var type, override;\n  function ret(style, tp) { type = tp; return style; }\n\n  // Tokenizers\n\n  function tokenBase(stream, state) {\n    var ch = stream.next();\n    if (tokenHooks[ch]) {\n      var result = tokenHooks[ch](stream, state);\n      if (result !== false) return result;\n    }\n    if (ch == \"@\") {\n      stream.eatWhile(/[\\w\\\\\\-]/);\n      return ret(\"def\", stream.current());\n    } else if (ch == \"=\" || (ch == \"~\" || ch == \"|\") && stream.eat(\"=\")) {\n      return ret(null, \"compare\");\n    } else if (ch == \"\\\"\" || ch == \"'\") {\n      state.tokenize = tokenString(ch);\n      return state.tokenize(stream, state);\n    } else if (ch == \"#\") {\n      stream.eatWhile(/[\\w\\\\\\-]/);\n      return ret(\"atom\", \"hash\");\n    } else if (ch == \"!\") {\n      stream.match(/^\\s*\\w*/);\n      return ret(\"keyword\", \"important\");\n    } else if (/\\d/.test(ch) || ch == \".\" && stream.eat(/\\d/)) {\n      stream.eatWhile(/[\\w.%]/);\n      return ret(\"number\", \"unit\");\n    } else if (ch === \"-\") {\n      if (/[\\d.]/.test(stream.peek())) {\n        stream.eatWhile(/[\\w.%]/);\n        return ret(\"number\", \"unit\");\n      } else if (stream.match(/^-[\\w\\\\\\-]*/)) {\n        stream.eatWhile(/[\\w\\\\\\-]/);\n        if (stream.match(/^\\s*:/, false))\n          return ret(\"variable-2\", \"variable-definition\");\n        return ret(\"variable-2\", \"variable\");\n      } else if (stream.match(/^\\w+-/)) {\n        return ret(\"meta\", \"meta\");\n      }\n    } else if (/[,+>*\\/]/.test(ch)) {\n      return ret(null, \"select-op\");\n    } else if (ch == \".\" && stream.match(/^-?[_a-z][_a-z0-9-]*/i)) {\n      return ret(\"qualifier\", \"qualifier\");\n    } else if (/[:;{}\\[\\]\\(\\)]/.test(ch)) {\n      return ret(null, ch);\n    } else if (stream.match(/[\\w-.]+(?=\\()/)) {\n      if (/^(url(-prefix)?|domain|regexp)$/.test(stream.current().toLowerCase())) {\n        state.tokenize = tokenParenthesized;\n      }\n      return ret(\"variable callee\", \"variable\");\n    } else if (/[\\w\\\\\\-]/.test(ch)) {\n      stream.eatWhile(/[\\w\\\\\\-]/);\n      return ret(\"property\", \"word\");\n    } else {\n      return ret(null, null);\n    }\n  }\n\n  function tokenString(quote) {\n    return function(stream, state) {\n      var escaped = false, ch;\n      while ((ch = stream.next()) != null) {\n        if (ch == quote && !escaped) {\n          if (quote == \")\") stream.backUp(1);\n          break;\n        }\n        escaped = !escaped && ch == \"\\\\\";\n      }\n      if (ch == quote || !escaped && quote != \")\") state.tokenize = null;\n      return ret(\"string\", \"string\");\n    };\n  }\n\n  function tokenParenthesized(stream, state) {\n    stream.next(); // Must be '('\n    if (!stream.match(/\\s*[\\\"\\')]/, false))\n      state.tokenize = tokenString(\")\");\n    else\n      state.tokenize = null;\n    return ret(null, \"(\");\n  }\n\n  // Context management\n\n  function Context(type, indent, prev) {\n    this.type = type;\n    this.indent = indent;\n    this.prev = prev;\n  }\n\n  function pushContext(state, stream, type, indent) {\n    state.context = new Context(type, stream.indentation() + (indent === false ? 0 : indentUnit), state.context);\n    return type;\n  }\n\n  function popContext(state) {\n    if (state.context.prev)\n      state.context = state.context.prev;\n    return state.context.type;\n  }\n\n  function pass(type, stream, state) {\n    return states[state.context.type](type, stream, state);\n  }\n  function popAndPass(type, stream, state, n) {\n    for (var i = n || 1; i > 0; i--)\n      state.context = state.context.prev;\n    return pass(type, stream, state);\n  }\n\n  // Parser\n\n  function wordAsValue(stream) {\n    var word = stream.current().toLowerCase();\n    if (valueKeywords.hasOwnProperty(word))\n      override = \"atom\";\n    else if (colorKeywords.hasOwnProperty(word))\n      override = \"keyword\";\n    else\n      override = \"variable\";\n  }\n\n  var states = {};\n\n  states.top = function(type, stream, state) {\n    if (type == \"{\") {\n      return pushContext(state, stream, \"block\");\n    } else if (type == \"}\" && state.context.prev) {\n      return popContext(state);\n    } else if (supportsAtComponent && /@component/i.test(type)) {\n      return pushContext(state, stream, \"atComponentBlock\");\n    } else if (/^@(-moz-)?document$/i.test(type)) {\n      return pushContext(state, stream, \"documentTypes\");\n    } else if (/^@(media|supports|(-moz-)?document|import)$/i.test(type)) {\n      return pushContext(state, stream, \"atBlock\");\n    } else if (/^@(font-face|counter-style)/i.test(type)) {\n      state.stateArg = type;\n      return \"restricted_atBlock_before\";\n    } else if (/^@(-(moz|ms|o|webkit)-)?keyframes$/i.test(type)) {\n      return \"keyframes\";\n    } else if (type && type.charAt(0) == \"@\") {\n      return pushContext(state, stream, \"at\");\n    } else if (type == \"hash\") {\n      override = \"builtin\";\n    } else if (type == \"word\") {\n      override = \"tag\";\n    } else if (type == \"variable-definition\") {\n      return \"maybeprop\";\n    } else if (type == \"interpolation\") {\n      return pushContext(state, stream, \"interpolation\");\n    } else if (type == \":\") {\n      return \"pseudo\";\n    } else if (allowNested && type == \"(\") {\n      return pushContext(state, stream, \"parens\");\n    }\n    return state.context.type;\n  };\n\n  states.block = function(type, stream, state) {\n    if (type == \"word\") {\n      var word = stream.current().toLowerCase();\n      if (propertyKeywords.hasOwnProperty(word)) {\n        override = \"property\";\n        return \"maybeprop\";\n      } else if (nonStandardPropertyKeywords.hasOwnProperty(word)) {\n        override = \"string-2\";\n        return \"maybeprop\";\n      } else if (allowNested) {\n        override = stream.match(/^\\s*:(?:\\s|$)/, false) ? \"property\" : \"tag\";\n        return \"block\";\n      } else {\n        override += \" error\";\n        return \"maybeprop\";\n      }\n    } else if (type == \"meta\") {\n      return \"block\";\n    } else if (!allowNested && (type == \"hash\" || type == \"qualifier\")) {\n      override = \"error\";\n      return \"block\";\n    } else {\n      return states.top(type, stream, state);\n    }\n  };\n\n  states.maybeprop = function(type, stream, state) {\n    if (type == \":\") return pushContext(state, stream, \"prop\");\n    return pass(type, stream, state);\n  };\n\n  states.prop = function(type, stream, state) {\n    if (type == \";\") return popContext(state);\n    if (type == \"{\" && allowNested) return pushContext(state, stream, \"propBlock\");\n    if (type == \"}\" || type == \"{\") return popAndPass(type, stream, state);\n    if (type == \"(\") return pushContext(state, stream, \"parens\");\n\n    if (type == \"hash\" && !/^#([0-9a-fA-f]{3,4}|[0-9a-fA-f]{6}|[0-9a-fA-f]{8})$/.test(stream.current())) {\n      override += \" error\";\n    } else if (type == \"word\") {\n      wordAsValue(stream);\n    } else if (type == \"interpolation\") {\n      return pushContext(state, stream, \"interpolation\");\n    }\n    return \"prop\";\n  };\n\n  states.propBlock = function(type, _stream, state) {\n    if (type == \"}\") return popContext(state);\n    if (type == \"word\") { override = \"property\"; return \"maybeprop\"; }\n    return state.context.type;\n  };\n\n  states.parens = function(type, stream, state) {\n    if (type == \"{\" || type == \"}\") return popAndPass(type, stream, state);\n    if (type == \")\") return popContext(state);\n    if (type == \"(\") return pushContext(state, stream, \"parens\");\n    if (type == \"interpolation\") return pushContext(state, stream, \"interpolation\");\n    if (type == \"word\") wordAsValue(stream);\n    return \"parens\";\n  };\n\n  states.pseudo = function(type, stream, state) {\n    if (type == \"meta\") return \"pseudo\";\n\n    if (type == \"word\") {\n      override = \"variable-3\";\n      return state.context.type;\n    }\n    return pass(type, stream, state);\n  };\n\n  states.documentTypes = function(type, stream, state) {\n    if (type == \"word\" && documentTypes.hasOwnProperty(stream.current())) {\n      override = \"tag\";\n      return state.context.type;\n    } else {\n      return states.atBlock(type, stream, state);\n    }\n  };\n\n  states.atBlock = function(type, stream, state) {\n    if (type == \"(\") return pushContext(state, stream, \"atBlock_parens\");\n    if (type == \"}\" || type == \";\") return popAndPass(type, stream, state);\n    if (type == \"{\") return popContext(state) && pushContext(state, stream, allowNested ? \"block\" : \"top\");\n\n    if (type == \"interpolation\") return pushContext(state, stream, \"interpolation\");\n\n    if (type == \"word\") {\n      var word = stream.current().toLowerCase();\n      if (word == \"only\" || word == \"not\" || word == \"and\" || word == \"or\")\n        override = \"keyword\";\n      else if (mediaTypes.hasOwnProperty(word))\n        override = \"attribute\";\n      else if (mediaFeatures.hasOwnProperty(word))\n        override = \"property\";\n      else if (mediaValueKeywords.hasOwnProperty(word))\n        override = \"keyword\";\n      else if (propertyKeywords.hasOwnProperty(word))\n        override = \"property\";\n      else if (nonStandardPropertyKeywords.hasOwnProperty(word))\n        override = \"string-2\";\n      else if (valueKeywords.hasOwnProperty(word))\n        override = \"atom\";\n      else if (colorKeywords.hasOwnProperty(word))\n        override = \"keyword\";\n      else\n        override = \"error\";\n    }\n    return state.context.type;\n  };\n\n  states.atComponentBlock = function(type, stream, state) {\n    if (type == \"}\")\n      return popAndPass(type, stream, state);\n    if (type == \"{\")\n      return popContext(state) && pushContext(state, stream, allowNested ? \"block\" : \"top\", false);\n    if (type == \"word\")\n      override = \"error\";\n    return state.context.type;\n  };\n\n  states.atBlock_parens = function(type, stream, state) {\n    if (type == \")\") return popContext(state);\n    if (type == \"{\" || type == \"}\") return popAndPass(type, stream, state, 2);\n    return states.atBlock(type, stream, state);\n  };\n\n  states.restricted_atBlock_before = function(type, stream, state) {\n    if (type == \"{\")\n      return pushContext(state, stream, \"restricted_atBlock\");\n    if (type == \"word\" && state.stateArg == \"@counter-style\") {\n      override = \"variable\";\n      return \"restricted_atBlock_before\";\n    }\n    return pass(type, stream, state);\n  };\n\n  states.restricted_atBlock = function(type, stream, state) {\n    if (type == \"}\") {\n      state.stateArg = null;\n      return popContext(state);\n    }\n    if (type == \"word\") {\n      if ((state.stateArg == \"@font-face\" && !fontProperties.hasOwnProperty(stream.current().toLowerCase())) ||\n          (state.stateArg == \"@counter-style\" && !counterDescriptors.hasOwnProperty(stream.current().toLowerCase())))\n        override = \"error\";\n      else\n        override = \"property\";\n      return \"maybeprop\";\n    }\n    return \"restricted_atBlock\";\n  };\n\n  states.keyframes = function(type, stream, state) {\n    if (type == \"word\") { override = \"variable\"; return \"keyframes\"; }\n    if (type == \"{\") return pushContext(state, stream, \"top\");\n    return pass(type, stream, state);\n  };\n\n  states.at = function(type, stream, state) {\n    if (type == \";\") return popContext(state);\n    if (type == \"{\" || type == \"}\") return popAndPass(type, stream, state);\n    if (type == \"word\") override = \"tag\";\n    else if (type == \"hash\") override = \"builtin\";\n    return \"at\";\n  };\n\n  states.interpolation = function(type, stream, state) {\n    if (type == \"}\") return popContext(state);\n    if (type == \"{\" || type == \";\") return popAndPass(type, stream, state);\n    if (type == \"word\") override = \"variable\";\n    else if (type != \"variable\" && type != \"(\" && type != \")\") override = \"error\";\n    return \"interpolation\";\n  };\n\n  return {\n    startState: function(base) {\n      return {tokenize: null,\n              state: inline ? \"block\" : \"top\",\n              stateArg: null,\n              context: new Context(inline ? \"block\" : \"top\", base || 0, null)};\n    },\n\n    token: function(stream, state) {\n      if (!state.tokenize && stream.eatSpace()) return null;\n      var style = (state.tokenize || tokenBase)(stream, state);\n      if (style && typeof style == \"object\") {\n        type = style[1];\n        style = style[0];\n      }\n      override = style;\n      if (type != \"comment\")\n        state.state = states[state.state](type, stream, state);\n      return override;\n    },\n\n    indent: function(state, textAfter) {\n      var cx = state.context, ch = textAfter && textAfter.charAt(0);\n      var indent = cx.indent;\n      if (cx.type == \"prop\" && (ch == \"}\" || ch == \")\")) cx = cx.prev;\n      if (cx.prev) {\n        if (ch == \"}\" && (cx.type == \"block\" || cx.type == \"top\" ||\n                          cx.type == \"interpolation\" || cx.type == \"restricted_atBlock\")) {\n          // Resume indentation from parent context.\n          cx = cx.prev;\n          indent = cx.indent;\n        } else if (ch == \")\" && (cx.type == \"parens\" || cx.type == \"atBlock_parens\") ||\n            ch == \"{\" && (cx.type == \"at\" || cx.type == \"atBlock\")) {\n          // Dedent relative to current context.\n          indent = Math.max(0, cx.indent - indentUnit);\n        }\n      }\n      return indent;\n    },\n\n    electricChars: \"}\",\n    blockCommentStart: \"/*\",\n    blockCommentEnd: \"*/\",\n    blockCommentContinue: \" * \",\n    lineComment: lineComment,\n    fold: \"brace\"\n  };\n});\n\n  function keySet(array) {\n    var keys = {};\n    for (var i = 0; i < array.length; ++i) {\n      keys[array[i].toLowerCase()] = true;\n    }\n    return keys;\n  }\n\n  var documentTypes_ = [\n    \"domain\", \"regexp\", \"url\", \"url-prefix\"\n  ], documentTypes = keySet(documentTypes_);\n\n  var mediaTypes_ = [\n    \"all\", \"aural\", \"braille\", \"handheld\", \"print\", \"projection\", \"screen\",\n    \"tty\", \"tv\", \"embossed\"\n  ], mediaTypes = keySet(mediaTypes_);\n\n  var mediaFeatures_ = [\n    \"width\", \"min-width\", \"max-width\", \"height\", \"min-height\", \"max-height\",\n    \"device-width\", \"min-device-width\", \"max-device-width\", \"device-height\",\n    \"min-device-height\", \"max-device-height\", \"aspect-ratio\",\n    \"min-aspect-ratio\", \"max-aspect-ratio\", \"device-aspect-ratio\",\n    \"min-device-aspect-ratio\", \"max-device-aspect-ratio\", \"color\", \"min-color\",\n    \"max-color\", \"color-index\", \"min-color-index\", \"max-color-index\",\n    \"monochrome\", \"min-monochrome\", \"max-monochrome\", \"resolution\",\n    \"min-resolution\", \"max-resolution\", \"scan\", \"grid\", \"orientation\",\n    \"device-pixel-ratio\", \"min-device-pixel-ratio\", \"max-device-pixel-ratio\",\n    \"pointer\", \"any-pointer\", \"hover\", \"any-hover\"\n  ], mediaFeatures = keySet(mediaFeatures_);\n\n  var mediaValueKeywords_ = [\n    \"landscape\", \"portrait\", \"none\", \"coarse\", \"fine\", \"on-demand\", \"hover\",\n    \"interlace\", \"progressive\"\n  ], mediaValueKeywords = keySet(mediaValueKeywords_);\n\n  var propertyKeywords_ = [\n    \"align-content\", \"align-items\", \"align-self\", \"alignment-adjust\",\n    \"alignment-baseline\", \"anchor-point\", \"animation\", \"animation-delay\",\n    \"animation-direction\", \"animation-duration\", \"animation-fill-mode\",\n    \"animation-iteration-count\", \"animation-name\", \"animation-play-state\",\n    \"animation-timing-function\", \"appearance\", \"azimuth\", \"backface-visibility\",\n    \"background\", \"background-attachment\", \"background-blend-mode\", \"background-clip\",\n    \"background-color\", \"background-image\", \"background-origin\", \"background-position\",\n    \"background-repeat\", \"background-size\", \"baseline-shift\", \"binding\",\n    \"bleed\", \"bookmark-label\", \"bookmark-level\", \"bookmark-state\",\n    \"bookmark-target\", \"border\", \"border-bottom\", \"border-bottom-color\",\n    \"border-bottom-left-radius\", \"border-bottom-right-radius\",\n    \"border-bottom-style\", \"border-bottom-width\", \"border-collapse\",\n    \"border-color\", \"border-image\", \"border-image-outset\",\n    \"border-image-repeat\", \"border-image-slice\", \"border-image-source\",\n    \"border-image-width\", \"border-left\", \"border-left-color\",\n    \"border-left-style\", \"border-left-width\", \"border-radius\", \"border-right\",\n    \"border-right-color\", \"border-right-style\", \"border-right-width\",\n    \"border-spacing\", \"border-style\", \"border-top\", \"border-top-color\",\n    \"border-top-left-radius\", \"border-top-right-radius\", \"border-top-style\",\n    \"border-top-width\", \"border-width\", \"bottom\", \"box-decoration-break\",\n    \"box-shadow\", \"box-sizing\", \"break-after\", \"break-before\", \"break-inside\",\n    \"caption-side\", \"caret-color\", \"clear\", \"clip\", \"color\", \"color-profile\", \"column-count\",\n    \"column-fill\", \"column-gap\", \"column-rule\", \"column-rule-color\",\n    \"column-rule-style\", \"column-rule-width\", \"column-span\", \"column-width\",\n    \"columns\", \"content\", \"counter-increment\", \"counter-reset\", \"crop\", \"cue\",\n    \"cue-after\", \"cue-before\", \"cursor\", \"direction\", \"display\",\n    \"dominant-baseline\", \"drop-initial-after-adjust\",\n    \"drop-initial-after-align\", \"drop-initial-before-adjust\",\n    \"drop-initial-before-align\", \"drop-initial-size\", \"drop-initial-value\",\n    \"elevation\", \"empty-cells\", \"fit\", \"fit-position\", \"flex\", \"flex-basis\",\n    \"flex-direction\", \"flex-flow\", \"flex-grow\", \"flex-shrink\", \"flex-wrap\",\n    \"float\", \"float-offset\", \"flow-from\", \"flow-into\", \"font\", \"font-feature-settings\",\n    \"font-family\", \"font-kerning\", \"font-language-override\", \"font-size\", \"font-size-adjust\",\n    \"font-stretch\", \"font-style\", \"font-synthesis\", \"font-variant\",\n    \"font-variant-alternates\", \"font-variant-caps\", \"font-variant-east-asian\",\n    \"font-variant-ligatures\", \"font-variant-numeric\", \"font-variant-position\",\n    \"font-weight\", \"grid\", \"grid-area\", \"grid-auto-columns\", \"grid-auto-flow\",\n    \"grid-auto-rows\", \"grid-column\", \"grid-column-end\", \"grid-column-gap\",\n    \"grid-column-start\", \"grid-gap\", \"grid-row\", \"grid-row-end\", \"grid-row-gap\",\n    \"grid-row-start\", \"grid-template\", \"grid-template-areas\", \"grid-template-columns\",\n    \"grid-template-rows\", \"hanging-punctuation\", \"height\", \"hyphens\",\n    \"icon\", \"image-orientation\", \"image-rendering\", \"image-resolution\",\n    \"inline-box-align\", \"justify-content\", \"justify-items\", \"justify-self\", \"left\", \"letter-spacing\",\n    \"line-break\", \"line-height\", \"line-stacking\", \"line-stacking-ruby\",\n    \"line-stacking-shift\", \"line-stacking-strategy\", \"list-style\",\n    \"list-style-image\", \"list-style-position\", \"list-style-type\", \"margin\",\n    \"margin-bottom\", \"margin-left\", \"margin-right\", \"margin-top\",\n    \"marks\", \"marquee-direction\", \"marquee-loop\",\n    \"marquee-play-count\", \"marquee-speed\", \"marquee-style\", \"max-height\",\n    \"max-width\", \"min-height\", \"min-width\", \"mix-blend-mode\", \"move-to\", \"nav-down\", \"nav-index\",\n    \"nav-left\", \"nav-right\", \"nav-up\", \"object-fit\", \"object-position\",\n    \"opacity\", \"order\", \"orphans\", \"outline\",\n    \"outline-color\", \"outline-offset\", \"outline-style\", \"outline-width\",\n    \"overflow\", \"overflow-style\", \"overflow-wrap\", \"overflow-x\", \"overflow-y\",\n    \"padding\", \"padding-bottom\", \"padding-left\", \"padding-right\", \"padding-top\",\n    \"page\", \"page-break-after\", \"page-break-before\", \"page-break-inside\",\n    \"page-policy\", \"pause\", \"pause-after\", \"pause-before\", \"perspective\",\n    \"perspective-origin\", \"pitch\", \"pitch-range\", \"place-content\", \"place-items\", \"place-self\", \"play-during\", \"position\",\n    \"presentation-level\", \"punctuation-trim\", \"quotes\", \"region-break-after\",\n    \"region-break-before\", \"region-break-inside\", \"region-fragment\",\n    \"rendering-intent\", \"resize\", \"rest\", \"rest-after\", \"rest-before\", \"richness\",\n    \"right\", \"rotation\", \"rotation-point\", \"ruby-align\", \"ruby-overhang\",\n    \"ruby-position\", \"ruby-span\", \"shape-image-threshold\", \"shape-inside\", \"shape-margin\",\n    \"shape-outside\", \"size\", \"speak\", \"speak-as\", \"speak-header\",\n    \"speak-numeral\", \"speak-punctuation\", \"speech-rate\", \"stress\", \"string-set\",\n    \"tab-size\", \"table-layout\", \"target\", \"target-name\", \"target-new\",\n    \"target-position\", \"text-align\", \"text-align-last\", \"text-decoration\",\n    \"text-decoration-color\", \"text-decoration-line\", \"text-decoration-skip\",\n    \"text-decoration-style\", \"text-emphasis\", \"text-emphasis-color\",\n    \"text-emphasis-position\", \"text-emphasis-style\", \"text-height\",\n    \"text-indent\", \"text-justify\", \"text-outline\", \"text-overflow\", \"text-shadow\",\n    \"text-size-adjust\", \"text-space-collapse\", \"text-transform\", \"text-underline-position\",\n    \"text-wrap\", \"top\", \"transform\", \"transform-origin\", \"transform-style\",\n    \"transition\", \"transition-delay\", \"transition-duration\",\n    \"transition-property\", \"transition-timing-function\", \"unicode-bidi\",\n    \"user-select\", \"vertical-align\", \"visibility\", \"voice-balance\", \"voice-duration\",\n    \"voice-family\", \"voice-pitch\", \"voice-range\", \"voice-rate\", \"voice-stress\",\n    \"voice-volume\", \"volume\", \"white-space\", \"widows\", \"width\", \"will-change\", \"word-break\",\n    \"word-spacing\", \"word-wrap\", \"z-index\",\n    // SVG-specific\n    \"clip-path\", \"clip-rule\", \"mask\", \"enable-background\", \"filter\", \"flood-color\",\n    \"flood-opacity\", \"lighting-color\", \"stop-color\", \"stop-opacity\", \"pointer-events\",\n    \"color-interpolation\", \"color-interpolation-filters\",\n    \"color-rendering\", \"fill\", \"fill-opacity\", \"fill-rule\", \"image-rendering\",\n    \"marker\", \"marker-end\", \"marker-mid\", \"marker-start\", \"shape-rendering\", \"stroke\",\n    \"stroke-dasharray\", \"stroke-dashoffset\", \"stroke-linecap\", \"stroke-linejoin\",\n    \"stroke-miterlimit\", \"stroke-opacity\", \"stroke-width\", \"text-rendering\",\n    \"baseline-shift\", \"dominant-baseline\", \"glyph-orientation-horizontal\",\n    \"glyph-orientation-vertical\", \"text-anchor\", \"writing-mode\"\n  ], propertyKeywords = keySet(propertyKeywords_);\n\n  var nonStandardPropertyKeywords_ = [\n    \"scrollbar-arrow-color\", \"scrollbar-base-color\", \"scrollbar-dark-shadow-color\",\n    \"scrollbar-face-color\", \"scrollbar-highlight-color\", \"scrollbar-shadow-color\",\n    \"scrollbar-3d-light-color\", \"scrollbar-track-color\", \"shape-inside\",\n    \"searchfield-cancel-button\", \"searchfield-decoration\", \"searchfield-results-button\",\n    \"searchfield-results-decoration\", \"zoom\"\n  ], nonStandardPropertyKeywords = keySet(nonStandardPropertyKeywords_);\n\n  var fontProperties_ = [\n    \"font-family\", \"src\", \"unicode-range\", \"font-variant\", \"font-feature-settings\",\n    \"font-stretch\", \"font-weight\", \"font-style\"\n  ], fontProperties = keySet(fontProperties_);\n\n  var counterDescriptors_ = [\n    \"additive-symbols\", \"fallback\", \"negative\", \"pad\", \"prefix\", \"range\",\n    \"speak-as\", \"suffix\", \"symbols\", \"system\"\n  ], counterDescriptors = keySet(counterDescriptors_);\n\n  var colorKeywords_ = [\n    \"aliceblue\", \"antiquewhite\", \"aqua\", \"aquamarine\", \"azure\", \"beige\",\n    \"bisque\", \"black\", \"blanchedalmond\", \"blue\", \"blueviolet\", \"brown\",\n    \"burlywood\", \"cadetblue\", \"chartreuse\", \"chocolate\", \"coral\", \"cornflowerblue\",\n    \"cornsilk\", \"crimson\", \"cyan\", \"darkblue\", \"darkcyan\", \"darkgoldenrod\",\n    \"darkgray\", \"darkgreen\", \"darkkhaki\", \"darkmagenta\", \"darkolivegreen\",\n    \"darkorange\", \"darkorchid\", \"darkred\", \"darksalmon\", \"darkseagreen\",\n    \"darkslateblue\", \"darkslategray\", \"darkturquoise\", \"darkviolet\",\n    \"deeppink\", \"deepskyblue\", \"dimgray\", \"dodgerblue\", \"firebrick\",\n    \"floralwhite\", \"forestgreen\", \"fuchsia\", \"gainsboro\", \"ghostwhite\",\n    \"gold\", \"goldenrod\", \"gray\", \"grey\", \"green\", \"greenyellow\", \"honeydew\",\n    \"hotpink\", \"indianred\", \"indigo\", \"ivory\", \"khaki\", \"lavender\",\n    \"lavenderblush\", \"lawngreen\", \"lemonchiffon\", \"lightblue\", \"lightcoral\",\n    \"lightcyan\", \"lightgoldenrodyellow\", \"lightgray\", \"lightgreen\", \"lightpink\",\n    \"lightsalmon\", \"lightseagreen\", \"lightskyblue\", \"lightslategray\",\n    \"lightsteelblue\", \"lightyellow\", \"lime\", \"limegreen\", \"linen\", \"magenta\",\n    \"maroon\", \"mediumaquamarine\", \"mediumblue\", \"mediumorchid\", \"mediumpurple\",\n    \"mediumseagreen\", \"mediumslateblue\", \"mediumspringgreen\", \"mediumturquoise\",\n    \"mediumvioletred\", \"midnightblue\", \"mintcream\", \"mistyrose\", \"moccasin\",\n    \"navajowhite\", \"navy\", \"oldlace\", \"olive\", \"olivedrab\", \"orange\", \"orangered\",\n    \"orchid\", \"palegoldenrod\", \"palegreen\", \"paleturquoise\", \"palevioletred\",\n    \"papayawhip\", \"peachpuff\", \"peru\", \"pink\", \"plum\", \"powderblue\",\n    \"purple\", \"rebeccapurple\", \"red\", \"rosybrown\", \"royalblue\", \"saddlebrown\",\n    \"salmon\", \"sandybrown\", \"seagreen\", \"seashell\", \"sienna\", \"silver\", \"skyblue\",\n    \"slateblue\", \"slategray\", \"snow\", \"springgreen\", \"steelblue\", \"tan\",\n    \"teal\", \"thistle\", \"tomato\", \"turquoise\", \"violet\", \"wheat\", \"white\",\n    \"whitesmoke\", \"yellow\", \"yellowgreen\"\n  ], colorKeywords = keySet(colorKeywords_);\n\n  var valueKeywords_ = [\n    \"above\", \"absolute\", \"activeborder\", \"additive\", \"activecaption\", \"afar\",\n    \"after-white-space\", \"ahead\", \"alias\", \"all\", \"all-scroll\", \"alphabetic\", \"alternate\",\n    \"always\", \"amharic\", \"amharic-abegede\", \"antialiased\", \"appworkspace\",\n    \"arabic-indic\", \"armenian\", \"asterisks\", \"attr\", \"auto\", \"auto-flow\", \"avoid\", \"avoid-column\", \"avoid-page\",\n    \"avoid-region\", \"background\", \"backwards\", \"baseline\", \"below\", \"bidi-override\", \"binary\",\n    \"bengali\", \"blink\", \"block\", \"block-axis\", \"bold\", \"bolder\", \"border\", \"border-box\",\n    \"both\", \"bottom\", \"break\", \"break-all\", \"break-word\", \"bullets\", \"button\", \"button-bevel\",\n    \"buttonface\", \"buttonhighlight\", \"buttonshadow\", \"buttontext\", \"calc\", \"cambodian\",\n    \"capitalize\", \"caps-lock-indicator\", \"caption\", \"captiontext\", \"caret\",\n    \"cell\", \"center\", \"checkbox\", \"circle\", \"cjk-decimal\", \"cjk-earthly-branch\",\n    \"cjk-heavenly-stem\", \"cjk-ideographic\", \"clear\", \"clip\", \"close-quote\",\n    \"col-resize\", \"collapse\", \"color\", \"color-burn\", \"color-dodge\", \"column\", \"column-reverse\",\n    \"compact\", \"condensed\", \"contain\", \"content\", \"contents\",\n    \"content-box\", \"context-menu\", \"continuous\", \"copy\", \"counter\", \"counters\", \"cover\", \"crop\",\n    \"cross\", \"crosshair\", \"currentcolor\", \"cursive\", \"cyclic\", \"darken\", \"dashed\", \"decimal\",\n    \"decimal-leading-zero\", \"default\", \"default-button\", \"dense\", \"destination-atop\",\n    \"destination-in\", \"destination-out\", \"destination-over\", \"devanagari\", \"difference\",\n    \"disc\", \"discard\", \"disclosure-closed\", \"disclosure-open\", \"document\",\n    \"dot-dash\", \"dot-dot-dash\",\n    \"dotted\", \"double\", \"down\", \"e-resize\", \"ease\", \"ease-in\", \"ease-in-out\", \"ease-out\",\n    \"element\", \"ellipse\", \"ellipsis\", \"embed\", \"end\", \"ethiopic\", \"ethiopic-abegede\",\n    \"ethiopic-abegede-am-et\", \"ethiopic-abegede-gez\", \"ethiopic-abegede-ti-er\",\n    \"ethiopic-abegede-ti-et\", \"ethiopic-halehame-aa-er\",\n    \"ethiopic-halehame-aa-et\", \"ethiopic-halehame-am-et\",\n    \"ethiopic-halehame-gez\", \"ethiopic-halehame-om-et\",\n    \"ethiopic-halehame-sid-et\", \"ethiopic-halehame-so-et\",\n    \"ethiopic-halehame-ti-er\", \"ethiopic-halehame-ti-et\", \"ethiopic-halehame-tig\",\n    \"ethiopic-numeric\", \"ew-resize\", \"exclusion\", \"expanded\", \"extends\", \"extra-condensed\",\n    \"extra-expanded\", \"fantasy\", \"fast\", \"fill\", \"fixed\", \"flat\", \"flex\", \"flex-end\", \"flex-start\", \"footnotes\",\n    \"forwards\", \"from\", \"geometricPrecision\", \"georgian\", \"graytext\", \"grid\", \"groove\",\n    \"gujarati\", \"gurmukhi\", \"hand\", \"hangul\", \"hangul-consonant\", \"hard-light\", \"hebrew\",\n    \"help\", \"hidden\", \"hide\", \"higher\", \"highlight\", \"highlighttext\",\n    \"hiragana\", \"hiragana-iroha\", \"horizontal\", \"hsl\", \"hsla\", \"hue\", \"icon\", \"ignore\",\n    \"inactiveborder\", \"inactivecaption\", \"inactivecaptiontext\", \"infinite\",\n    \"infobackground\", \"infotext\", \"inherit\", \"initial\", \"inline\", \"inline-axis\",\n    \"inline-block\", \"inline-flex\", \"inline-grid\", \"inline-table\", \"inset\", \"inside\", \"intrinsic\", \"invert\",\n    \"italic\", \"japanese-formal\", \"japanese-informal\", \"justify\", \"kannada\",\n    \"katakana\", \"katakana-iroha\", \"keep-all\", \"khmer\",\n    \"korean-hangul-formal\", \"korean-hanja-formal\", \"korean-hanja-informal\",\n    \"landscape\", \"lao\", \"large\", \"larger\", \"left\", \"level\", \"lighter\", \"lighten\",\n    \"line-through\", \"linear\", \"linear-gradient\", \"lines\", \"list-item\", \"listbox\", \"listitem\",\n    \"local\", \"logical\", \"loud\", \"lower\", \"lower-alpha\", \"lower-armenian\",\n    \"lower-greek\", \"lower-hexadecimal\", \"lower-latin\", \"lower-norwegian\",\n    \"lower-roman\", \"lowercase\", \"ltr\", \"luminosity\", \"malayalam\", \"match\", \"matrix\", \"matrix3d\",\n    \"media-controls-background\", \"media-current-time-display\",\n    \"media-fullscreen-button\", \"media-mute-button\", \"media-play-button\",\n    \"media-return-to-realtime-button\", \"media-rewind-button\",\n    \"media-seek-back-button\", \"media-seek-forward-button\", \"media-slider\",\n    \"media-sliderthumb\", \"media-time-remaining-display\", \"media-volume-slider\",\n    \"media-volume-slider-container\", \"media-volume-sliderthumb\", \"medium\",\n    \"menu\", \"menulist\", \"menulist-button\", \"menulist-text\",\n    \"menulist-textfield\", \"menutext\", \"message-box\", \"middle\", \"min-intrinsic\",\n    \"mix\", \"mongolian\", \"monospace\", \"move\", \"multiple\", \"multiply\", \"myanmar\", \"n-resize\",\n    \"narrower\", \"ne-resize\", \"nesw-resize\", \"no-close-quote\", \"no-drop\",\n    \"no-open-quote\", \"no-repeat\", \"none\", \"normal\", \"not-allowed\", \"nowrap\",\n    \"ns-resize\", \"numbers\", \"numeric\", \"nw-resize\", \"nwse-resize\", \"oblique\", \"octal\", \"opacity\", \"open-quote\",\n    \"optimizeLegibility\", \"optimizeSpeed\", \"oriya\", \"oromo\", \"outset\",\n    \"outside\", \"outside-shape\", \"overlay\", \"overline\", \"padding\", \"padding-box\",\n    \"painted\", \"page\", \"paused\", \"persian\", \"perspective\", \"plus-darker\", \"plus-lighter\",\n    \"pointer\", \"polygon\", \"portrait\", \"pre\", \"pre-line\", \"pre-wrap\", \"preserve-3d\",\n    \"progress\", \"push-button\", \"radial-gradient\", \"radio\", \"read-only\",\n    \"read-write\", \"read-write-plaintext-only\", \"rectangle\", \"region\",\n    \"relative\", \"repeat\", \"repeating-linear-gradient\",\n    \"repeating-radial-gradient\", \"repeat-x\", \"repeat-y\", \"reset\", \"reverse\",\n    \"rgb\", \"rgba\", \"ridge\", \"right\", \"rotate\", \"rotate3d\", \"rotateX\", \"rotateY\",\n    \"rotateZ\", \"round\", \"row\", \"row-resize\", \"row-reverse\", \"rtl\", \"run-in\", \"running\",\n    \"s-resize\", \"sans-serif\", \"saturation\", \"scale\", \"scale3d\", \"scaleX\", \"scaleY\", \"scaleZ\", \"screen\",\n    \"scroll\", \"scrollbar\", \"scroll-position\", \"se-resize\", \"searchfield\",\n    \"searchfield-cancel-button\", \"searchfield-decoration\",\n    \"searchfield-results-button\", \"searchfield-results-decoration\", \"self-start\", \"self-end\",\n    \"semi-condensed\", \"semi-expanded\", \"separate\", \"serif\", \"show\", \"sidama\",\n    \"simp-chinese-formal\", \"simp-chinese-informal\", \"single\",\n    \"skew\", \"skewX\", \"skewY\", \"skip-white-space\", \"slide\", \"slider-horizontal\",\n    \"slider-vertical\", \"sliderthumb-horizontal\", \"sliderthumb-vertical\", \"slow\",\n    \"small\", \"small-caps\", \"small-caption\", \"smaller\", \"soft-light\", \"solid\", \"somali\",\n    \"source-atop\", \"source-in\", \"source-out\", \"source-over\", \"space\", \"space-around\", \"space-between\", \"space-evenly\", \"spell-out\", \"square\",\n    \"square-button\", \"start\", \"static\", \"status-bar\", \"stretch\", \"stroke\", \"sub\",\n    \"subpixel-antialiased\", \"super\", \"sw-resize\", \"symbolic\", \"symbols\", \"system-ui\", \"table\",\n    \"table-caption\", \"table-cell\", \"table-column\", \"table-column-group\",\n    \"table-footer-group\", \"table-header-group\", \"table-row\", \"table-row-group\",\n    \"tamil\",\n    \"telugu\", \"text\", \"text-bottom\", \"text-top\", \"textarea\", \"textfield\", \"thai\",\n    \"thick\", \"thin\", \"threeddarkshadow\", \"threedface\", \"threedhighlight\",\n    \"threedlightshadow\", \"threedshadow\", \"tibetan\", \"tigre\", \"tigrinya-er\",\n    \"tigrinya-er-abegede\", \"tigrinya-et\", \"tigrinya-et-abegede\", \"to\", \"top\",\n    \"trad-chinese-formal\", \"trad-chinese-informal\", \"transform\",\n    \"translate\", \"translate3d\", \"translateX\", \"translateY\", \"translateZ\",\n    \"transparent\", \"ultra-condensed\", \"ultra-expanded\", \"underline\", \"unset\", \"up\",\n    \"upper-alpha\", \"upper-armenian\", \"upper-greek\", \"upper-hexadecimal\",\n    \"upper-latin\", \"upper-norwegian\", \"upper-roman\", \"uppercase\", \"urdu\", \"url\",\n    \"var\", \"vertical\", \"vertical-text\", \"visible\", \"visibleFill\", \"visiblePainted\",\n    \"visibleStroke\", \"visual\", \"w-resize\", \"wait\", \"wave\", \"wider\",\n    \"window\", \"windowframe\", \"windowtext\", \"words\", \"wrap\", \"wrap-reverse\", \"x-large\", \"x-small\", \"xor\",\n    \"xx-large\", \"xx-small\"\n  ], valueKeywords = keySet(valueKeywords_);\n\n  var allWords = documentTypes_.concat(mediaTypes_).concat(mediaFeatures_).concat(mediaValueKeywords_)\n    .concat(propertyKeywords_).concat(nonStandardPropertyKeywords_).concat(colorKeywords_)\n    .concat(valueKeywords_);\n  CodeMirror.registerHelper(\"hintWords\", \"css\", allWords);\n\n  function tokenCComment(stream, state) {\n    var maybeEnd = false, ch;\n    while ((ch = stream.next()) != null) {\n      if (maybeEnd && ch == \"/\") {\n        state.tokenize = null;\n        break;\n      }\n      maybeEnd = (ch == \"*\");\n    }\n    return [\"comment\", \"comment\"];\n  }\n\n  CodeMirror.defineMIME(\"text/css\", {\n    documentTypes: documentTypes,\n    mediaTypes: mediaTypes,\n    mediaFeatures: mediaFeatures,\n    mediaValueKeywords: mediaValueKeywords,\n    propertyKeywords: propertyKeywords,\n    nonStandardPropertyKeywords: nonStandardPropertyKeywords,\n    fontProperties: fontProperties,\n    counterDescriptors: counterDescriptors,\n    colorKeywords: colorKeywords,\n    valueKeywords: valueKeywords,\n    tokenHooks: {\n      \"/\": function(stream, state) {\n        if (!stream.eat(\"*\")) return false;\n        state.tokenize = tokenCComment;\n        return tokenCComment(stream, state);\n      }\n    },\n    name: \"css\"\n  });\n\n  CodeMirror.defineMIME(\"text/x-scss\", {\n    mediaTypes: mediaTypes,\n    mediaFeatures: mediaFeatures,\n    mediaValueKeywords: mediaValueKeywords,\n    propertyKeywords: propertyKeywords,\n    nonStandardPropertyKeywords: nonStandardPropertyKeywords,\n    colorKeywords: colorKeywords,\n    valueKeywords: valueKeywords,\n    fontProperties: fontProperties,\n    allowNested: true,\n    lineComment: \"//\",\n    tokenHooks: {\n      \"/\": function(stream, state) {\n        if (stream.eat(\"/\")) {\n          stream.skipToEnd();\n          return [\"comment\", \"comment\"];\n        } else if (stream.eat(\"*\")) {\n          state.tokenize = tokenCComment;\n          return tokenCComment(stream, state);\n        } else {\n          return [\"operator\", \"operator\"];\n        }\n      },\n      \":\": function(stream) {\n        if (stream.match(/\\s*\\{/, false))\n          return [null, null]\n        return false;\n      },\n      \"$\": function(stream) {\n        stream.match(/^[\\w-]+/);\n        if (stream.match(/^\\s*:/, false))\n          return [\"variable-2\", \"variable-definition\"];\n        return [\"variable-2\", \"variable\"];\n      },\n      \"#\": function(stream) {\n        if (!stream.eat(\"{\")) return false;\n        return [null, \"interpolation\"];\n      }\n    },\n    name: \"css\",\n    helperType: \"scss\"\n  });\n\n  CodeMirror.defineMIME(\"text/x-less\", {\n    mediaTypes: mediaTypes,\n    mediaFeatures: mediaFeatures,\n    mediaValueKeywords: mediaValueKeywords,\n    propertyKeywords: propertyKeywords,\n    nonStandardPropertyKeywords: nonStandardPropertyKeywords,\n    colorKeywords: colorKeywords,\n    valueKeywords: valueKeywords,\n    fontProperties: fontProperties,\n    allowNested: true,\n    lineComment: \"//\",\n    tokenHooks: {\n      \"/\": function(stream, state) {\n        if (stream.eat(\"/\")) {\n          stream.skipToEnd();\n          return [\"comment\", \"comment\"];\n        } else if (stream.eat(\"*\")) {\n          state.tokenize = tokenCComment;\n          return tokenCComment(stream, state);\n        } else {\n          return [\"operator\", \"operator\"];\n        }\n      },\n      \"@\": function(stream) {\n        if (stream.eat(\"{\")) return [null, \"interpolation\"];\n        if (stream.match(/^(charset|document|font-face|import|(-(moz|ms|o|webkit)-)?keyframes|media|namespace|page|supports)\\b/i, false)) return false;\n        stream.eatWhile(/[\\w\\\\\\-]/);\n        if (stream.match(/^\\s*:/, false))\n          return [\"variable-2\", \"variable-definition\"];\n        return [\"variable-2\", \"variable\"];\n      },\n      \"&\": function() {\n        return [\"atom\", \"atom\"];\n      }\n    },\n    name: \"css\",\n    helperType: \"less\"\n  });\n\n  CodeMirror.defineMIME(\"text/x-gss\", {\n    documentTypes: documentTypes,\n    mediaTypes: mediaTypes,\n    mediaFeatures: mediaFeatures,\n    propertyKeywords: propertyKeywords,\n    nonStandardPropertyKeywords: nonStandardPropertyKeywords,\n    fontProperties: fontProperties,\n    counterDescriptors: counterDescriptors,\n    colorKeywords: colorKeywords,\n    valueKeywords: valueKeywords,\n    supportsAtComponent: true,\n    tokenHooks: {\n      \"/\": function(stream, state) {\n        if (!stream.eat(\"*\")) return false;\n        state.tokenize = tokenCComment;\n        return tokenCComment(stream, state);\n      }\n    },\n    name: \"css\",\n    helperType: \"gss\"\n  });\n\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  var ie_lt8 = /MSIE \\d/.test(navigator.userAgent) &&\n    (document.documentMode == null || document.documentMode < 8);\n\n  var Pos = CodeMirror.Pos;\n\n  var matching = {\"(\": \")>\", \")\": \"(<\", \"[\": \"]>\", \"]\": \"[<\", \"{\": \"}>\", \"}\": \"{<\", \"<\": \">>\", \">\": \"<<\"};\n\n  function bracketRegex(config) {\n    return config && config.bracketRegex || /[(){}[\\]]/\n  }\n\n  function findMatchingBracket(cm, where, config) {\n    var line = cm.getLineHandle(where.line), pos = where.ch - 1;\n    var afterCursor = config && config.afterCursor\n    if (afterCursor == null)\n      afterCursor = /(^| )cm-fat-cursor($| )/.test(cm.getWrapperElement().className)\n    var re = bracketRegex(config)\n\n    // A cursor is defined as between two characters, but in in vim command mode\n    // (i.e. not insert mode), the cursor is visually represented as a\n    // highlighted box on top of the 2nd character. Otherwise, we allow matches\n    // from before or after the cursor.\n    var match = (!afterCursor && pos >= 0 && re.test(line.text.charAt(pos)) && matching[line.text.charAt(pos)]) ||\n        re.test(line.text.charAt(pos + 1)) && matching[line.text.charAt(++pos)];\n    if (!match) return null;\n    var dir = match.charAt(1) == \">\" ? 1 : -1;\n    if (config && config.strict && (dir > 0) != (pos == where.ch)) return null;\n    var style = cm.getTokenTypeAt(Pos(where.line, pos + 1));\n\n    var found = scanForBracket(cm, Pos(where.line, pos + (dir > 0 ? 1 : 0)), dir, style || null, config);\n    if (found == null) return null;\n    return {from: Pos(where.line, pos), to: found && found.pos,\n            match: found && found.ch == match.charAt(0), forward: dir > 0};\n  }\n\n  // bracketRegex is used to specify which type of bracket to scan\n  // should be a regexp, e.g. /[[\\]]/\n  //\n  // Note: If \"where\" is on an open bracket, then this bracket is ignored.\n  //\n  // Returns false when no bracket was found, null when it reached\n  // maxScanLines and gave up\n  function scanForBracket(cm, where, dir, style, config) {\n    var maxScanLen = (config && config.maxScanLineLength) || 10000;\n    var maxScanLines = (config && config.maxScanLines) || 1000;\n\n    var stack = [];\n    var re = bracketRegex(config)\n    var lineEnd = dir > 0 ? Math.min(where.line + maxScanLines, cm.lastLine() + 1)\n                          : Math.max(cm.firstLine() - 1, where.line - maxScanLines);\n    for (var lineNo = where.line; lineNo != lineEnd; lineNo += dir) {\n      var line = cm.getLine(lineNo);\n      if (!line) continue;\n      var pos = dir > 0 ? 0 : line.length - 1, end = dir > 0 ? line.length : -1;\n      if (line.length > maxScanLen) continue;\n      if (lineNo == where.line) pos = where.ch - (dir < 0 ? 1 : 0);\n      for (; pos != end; pos += dir) {\n        var ch = line.charAt(pos);\n        if (re.test(ch) && (style === undefined || cm.getTokenTypeAt(Pos(lineNo, pos + 1)) == style)) {\n          var match = matching[ch];\n          if (match && (match.charAt(1) == \">\") == (dir > 0)) stack.push(ch);\n          else if (!stack.length) return {pos: Pos(lineNo, pos), ch: ch};\n          else stack.pop();\n        }\n      }\n    }\n    return lineNo - dir == (dir > 0 ? cm.lastLine() : cm.firstLine()) ? false : null;\n  }\n\n  function matchBrackets(cm, autoclear, config) {\n    // Disable brace matching in long lines, since it'll cause hugely slow updates\n    var maxHighlightLen = cm.state.matchBrackets.maxHighlightLineLength || 1000;\n    var marks = [], ranges = cm.listSelections();\n    for (var i = 0; i < ranges.length; i++) {\n      var match = ranges[i].empty() && findMatchingBracket(cm, ranges[i].head, config);\n      if (match && cm.getLine(match.from.line).length <= maxHighlightLen) {\n        var style = match.match ? \"CodeMirror-matchingbracket\" : \"CodeMirror-nonmatchingbracket\";\n        marks.push(cm.markText(match.from, Pos(match.from.line, match.from.ch + 1), {className: style}));\n        if (match.to && cm.getLine(match.to.line).length <= maxHighlightLen)\n          marks.push(cm.markText(match.to, Pos(match.to.line, match.to.ch + 1), {className: style}));\n      }\n    }\n\n    if (marks.length) {\n      // Kludge to work around the IE bug from issue #1193, where text\n      // input stops going to the textare whever this fires.\n      if (ie_lt8 && cm.state.focused) cm.focus();\n\n      var clear = function() {\n        cm.operation(function() {\n          for (var i = 0; i < marks.length; i++) marks[i].clear();\n        });\n      };\n      if (autoclear) setTimeout(clear, 800);\n      else return clear;\n    }\n  }\n\n  function doMatchBrackets(cm) {\n    cm.operation(function() {\n      if (cm.state.matchBrackets.currentlyHighlighted) {\n        cm.state.matchBrackets.currentlyHighlighted();\n        cm.state.matchBrackets.currentlyHighlighted = null;\n      }\n      cm.state.matchBrackets.currentlyHighlighted = matchBrackets(cm, false, cm.state.matchBrackets);\n    });\n  }\n\n  CodeMirror.defineOption(\"matchBrackets\", false, function(cm, val, old) {\n    if (old && old != CodeMirror.Init) {\n      cm.off(\"cursorActivity\", doMatchBrackets);\n      if (cm.state.matchBrackets && cm.state.matchBrackets.currentlyHighlighted) {\n        cm.state.matchBrackets.currentlyHighlighted();\n        cm.state.matchBrackets.currentlyHighlighted = null;\n      }\n    }\n    if (val) {\n      cm.state.matchBrackets = typeof val == \"object\" ? val : {};\n      cm.on(\"cursorActivity\", doMatchBrackets);\n    }\n  });\n\n  CodeMirror.defineExtension(\"matchBrackets\", function() {matchBrackets(this, true);});\n  CodeMirror.defineExtension(\"findMatchingBracket\", function(pos, config, oldConfig){\n    // Backwards-compatibility kludge\n    if (oldConfig || typeof config == \"boolean\") {\n      if (!oldConfig) {\n        config = config ? {strict: true} : null\n      } else {\n        oldConfig.strict = config\n        config = oldConfig\n      }\n    }\n    return findMatchingBracket(this, pos, config)\n  });\n  CodeMirror.defineExtension(\"scanForBracket\", function(pos, dir, style, config){\n    return scanForBracket(this, pos, dir, style, config);\n  });\n});\n","module.exports = {\n  props: {\n    // Unique id for this interface. Should be added to the lower level \n    // HTML input element if applicable. This ID will be used in the label's\n    // `for` attribute\n    id: {\n      type: String,\n      required: true\n    },\n    // Name of the field\n    name: {\n      type: String,\n      required: true\n    },\n    // The current value. This can either be the default value, the saved database\n    // value or the current state after the user made an edit\n    value: {\n      type: null,\n      default: null\n    },\n    // Type of the field, eg `string`, `hash`, or `array`\n    type: {\n      type: String,\n      required: true\n    },\n    // Max length\n    length: {\n      type: [String, Number],\n      default: null\n    },\n    // If the field is readonly or not\n    readonly: {\n      type: Boolean,\n      default: false\n    },\n    // If the field is required or not\n    required: {\n      type: Boolean,\n      default: false\n    },\n    // Field options. A json object based on the interface's meta.json file\n    options: {\n      type: Object,\n      default: () => ({})\n    },\n    // If the item that's currently being edited is new\n    newItem: {\n      type: Boolean,\n      default: false\n    },\n    // The relation of the current field. Will contain information on the related\n    // collection and field(s)\n    relation: {\n      type: Object,\n      default: null\n    },\n    // The other fields in the current edit page\n    fields: {\n      type: Object,\n      default: null\n    },\n    // The values of the other fields on the edit page. Can be used for things like\n    // automatically generating a slug based on another field\n    values: {\n      type: Object,\n      default: null\n    }\n  }\n};\n","!function(e,t){\"object\"==typeof exports&&\"object\"==typeof module?module.exports=t(require(\"codemirror\")):\"function\"==typeof define&&define.amd?define([\"codemirror\"],t):\"object\"==typeof exports?exports.VueCodemirror=t(require(\"codemirror\")):e.VueCodemirror=t(e.codemirror)}(this,function(e){return function(e){function t(r){if(n[r])return n[r].exports;var o=n[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,t),o.l=!0,o.exports}var n={};return t.m=e,t.c=n,t.i=function(e){return e},t.d=function(e,n,r){t.o(e,n)||Object.defineProperty(e,n,{configurable:!1,enumerable:!0,get:r})},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,\"a\",n),n},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p=\"/\",t(t.s=3)}([function(t,n){t.exports=e},function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0});var r=n(0),o=function(e){return e&&e.__esModule?e:{default:e}}(r),i=window.CodeMirror||o.default;\"function\"!=typeof Object.assign&&Object.defineProperty(Object,\"assign\",{value:function(e,t){if(null==e)throw new TypeError(\"Cannot convert undefined or null to object\");for(var n=Object(e),r=1;r<arguments.length;r++){var o=arguments[r];if(null!=o)for(var i in o)Object.prototype.hasOwnProperty.call(o,i)&&(n[i]=o[i])}return n},writable:!0,configurable:!0}),t.default={name:\"codemirror\",data:function(){return{content:\"\",codemirror:null,cminstance:null}},props:{code:String,value:String,marker:Function,unseenLines:Array,name:{type:String,default:\"codemirror\"},placeholder:{type:String,default:\"\"},merge:{type:Boolean,default:!1},options:{type:Object,default:function(){return{}}},events:{type:Array,default:function(){return[]}},globalOptions:{type:Object,default:function(){return{}}},globalEvents:{type:Array,default:function(){return[]}}},watch:{options:{deep:!0,handler:function(e){for(var t in e)this.cminstance.setOption(t,e[t])}},merge:function(){this.$nextTick(this.switchMerge)},code:function(e){this.handerCodeChange(e)},value:function(e){this.handerCodeChange(e)}},methods:{initialize:function(){var e=this,t=Object.assign({},this.globalOptions,this.options);this.merge?(this.codemirror=i.MergeView(this.$refs.mergeview,t),this.cminstance=this.codemirror.edit):(this.codemirror=i.fromTextArea(this.$refs.textarea,t),this.cminstance=this.codemirror,this.cminstance.setValue(this.code||this.value||this.content)),this.cminstance.on(\"change\",function(t){e.content=t.getValue(),e.$emit&&e.$emit(\"input\",e.content)});var n={};[\"scroll\",\"changes\",\"beforeChange\",\"cursorActivity\",\"keyHandled\",\"inputRead\",\"electricInput\",\"beforeSelectionChange\",\"viewportChange\",\"swapDoc\",\"gutterClick\",\"gutterContextMenu\",\"focus\",\"blur\",\"refresh\",\"optionChange\",\"scrollCursorIntoView\",\"update\"].concat(this.events).concat(this.globalEvents).filter(function(e){return!n[e]&&(n[e]=!0)}).forEach(function(t){e.cminstance.on(t,function(){for(var n=arguments.length,r=Array(n),o=0;o<n;o++)r[o]=arguments[o];e.$emit.apply(e,[t].concat(r));var i=t.replace(/([A-Z])/g,\"-$1\").toLowerCase();i!==t&&e.$emit.apply(e,[i].concat(r))})});this.$emit(\"ready\",this.codemirror),this.unseenLineMarkers(),this.refresh()},refresh:function(){var e=this;this.$nextTick(function(){e.cminstance.refresh()})},destroy:function(){var e=this.cminstance.doc.cm.getWrapperElement();e&&e.remove&&e.remove()},handerCodeChange:function(e){if(e!==this.cminstance.getValue()){var t=this.cminstance.getScrollInfo();this.cminstance.setValue(e),this.content=e,this.cminstance.scrollTo(t.left,t.top)}this.unseenLineMarkers()},unseenLineMarkers:function(){var e=this;void 0!==this.unseenLines&&void 0!==this.marker&&this.unseenLines.forEach(function(t){var n=e.cminstance.lineInfo(t);e.cminstance.setGutterMarker(t,\"breakpoints\",n.gutterMarkers?null:e.marker())})},switchMerge:function(){var e=this.cminstance.doc.history,t=this.cminstance.doc.cleanGeneration;this.options.value=this.cminstance.getValue(),this.destroy(),this.initialize(),this.cminstance.doc.history=e,this.cminstance.doc.cleanGeneration=t}},mounted:function(){this.initialize()},beforeDestroy:function(){this.destroy()}}},function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0});var r=n(1),o=n.n(r);for(var i in r)[\"default\",\"default\"].indexOf(i)<0&&function(e){n.d(t,e,function(){return r[e]})}(i);var s=n(5),c=n(4),a=c(o.a,s.a,!1,null,null,null);t.default=a.exports},function(e,t,n){\"use strict\";function r(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,\"__esModule\",{value:!0}),t.install=t.codemirror=t.CodeMirror=void 0;var o=n(0),i=r(o),s=n(2),c=r(s),a=window.CodeMirror||i.default,u=function(e,t){t&&(t.options&&(c.default.props.globalOptions.default=function(){return t.options}),t.events&&(c.default.props.globalEvents.default=function(){return t.events})),e.component(c.default.name,c.default)},l={CodeMirror:a,codemirror:c.default,install:u};t.default=l,t.CodeMirror=a,t.codemirror=c.default,t.install=u},function(e,t){e.exports=function(e,t,n,r,o,i){var s,c=e=e||{},a=typeof e.default;\"object\"!==a&&\"function\"!==a||(s=e,c=e.default);var u=\"function\"==typeof c?c.options:c;t&&(u.render=t.render,u.staticRenderFns=t.staticRenderFns,u._compiled=!0),n&&(u.functional=!0),o&&(u._scopeId=o);var l;if(i?(l=function(e){e=e||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext,e||\"undefined\"==typeof __VUE_SSR_CONTEXT__||(e=__VUE_SSR_CONTEXT__),r&&r.call(this,e),e&&e._registeredComponents&&e._registeredComponents.add(i)},u._ssrRegister=l):r&&(l=r),l){var f=u.functional,d=f?u.render:u.beforeCreate;f?(u._injectStyles=l,u.render=function(e,t){return l.call(t),d(e,t)}):u.beforeCreate=d?[].concat(d,l):[l]}return{esModule:s,exports:c,options:u}}},function(e,t,n){\"use strict\";var r=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n(\"div\",{staticClass:\"vue-codemirror\",class:{merge:e.merge}},[e.merge?n(\"div\",{ref:\"mergeview\"}):n(\"textarea\",{ref:\"textarea\",attrs:{name:e.name,placeholder:e.placeholder}})])},o=[],i={render:r,staticRenderFns:o};t.a=i}])});","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n// Because sometimes you need to mark the selected *text*.\n//\n// Adds an option 'styleSelectedText' which, when enabled, gives\n// selected text the CSS class given as option value, or\n// \"CodeMirror-selectedtext\" when the value is not a string.\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineOption(\"styleSelectedText\", false, function(cm, val, old) {\n    var prev = old && old != CodeMirror.Init;\n    if (val && !prev) {\n      cm.state.markedSelection = [];\n      cm.state.markedSelectionStyle = typeof val == \"string\" ? val : \"CodeMirror-selectedtext\";\n      reset(cm);\n      cm.on(\"cursorActivity\", onCursorActivity);\n      cm.on(\"change\", onChange);\n    } else if (!val && prev) {\n      cm.off(\"cursorActivity\", onCursorActivity);\n      cm.off(\"change\", onChange);\n      clear(cm);\n      cm.state.markedSelection = cm.state.markedSelectionStyle = null;\n    }\n  });\n\n  function onCursorActivity(cm) {\n    if (cm.state.markedSelection)\n      cm.operation(function() { update(cm); });\n  }\n\n  function onChange(cm) {\n    if (cm.state.markedSelection && cm.state.markedSelection.length)\n      cm.operation(function() { clear(cm); });\n  }\n\n  var CHUNK_SIZE = 8;\n  var Pos = CodeMirror.Pos;\n  var cmp = CodeMirror.cmpPos;\n\n  function coverRange(cm, from, to, addAt) {\n    if (cmp(from, to) == 0) return;\n    var array = cm.state.markedSelection;\n    var cls = cm.state.markedSelectionStyle;\n    for (var line = from.line;;) {\n      var start = line == from.line ? from : Pos(line, 0);\n      var endLine = line + CHUNK_SIZE, atEnd = endLine >= to.line;\n      var end = atEnd ? to : Pos(endLine, 0);\n      var mark = cm.markText(start, end, {className: cls});\n      if (addAt == null) array.push(mark);\n      else array.splice(addAt++, 0, mark);\n      if (atEnd) break;\n      line = endLine;\n    }\n  }\n\n  function clear(cm) {\n    var array = cm.state.markedSelection;\n    for (var i = 0; i < array.length; ++i) array[i].clear();\n    array.length = 0;\n  }\n\n  function reset(cm) {\n    clear(cm);\n    var ranges = cm.listSelections();\n    for (var i = 0; i < ranges.length; i++)\n      coverRange(cm, ranges[i].from(), ranges[i].to());\n  }\n\n  function update(cm) {\n    if (!cm.somethingSelected()) return clear(cm);\n    if (cm.listSelections().length > 1) return reset(cm);\n\n    var from = cm.getCursor(\"start\"), to = cm.getCursor(\"end\");\n\n    var array = cm.state.markedSelection;\n    if (!array.length) return coverRange(cm, from, to);\n\n    var coverStart = array[0].find(), coverEnd = array[array.length - 1].find();\n    if (!coverStart || !coverEnd || to.line - from.line <= CHUNK_SIZE ||\n        cmp(from, coverEnd.to) >= 0 || cmp(to, coverStart.from) <= 0)\n      return reset(cm);\n\n    while (cmp(from, coverStart.from) > 0) {\n      array.shift().clear();\n      coverStart = array[0].find();\n    }\n    if (cmp(from, coverStart.from) < 0) {\n      if (coverStart.to.line - from.line < CHUNK_SIZE) {\n        array.shift().clear();\n        coverRange(cm, from, coverStart.to, 0);\n      } else {\n        coverRange(cm, from, coverStart.from, 0);\n      }\n    }\n\n    while (cmp(to, coverEnd.to) < 0) {\n      array.pop().clear();\n      coverEnd = array[array.length - 1].find();\n    }\n    if (cmp(to, coverEnd.to) > 0) {\n      if (to.line - coverEnd.from.line < CHUNK_SIZE) {\n        array.pop().clear();\n        coverRange(cm, coverEnd.from, to);\n      } else {\n        coverRange(cm, coverEnd.to, to);\n      }\n    }\n  }\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n// A rough approximation of Sublime Text's keybindings\n// Depends on addon/search/searchcursor.js and optionally addon/dialog/dialogs.js\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../lib/codemirror\"), require(\"../addon/search/searchcursor\"), require(\"../addon/edit/matchbrackets\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../lib/codemirror\", \"../addon/search/searchcursor\", \"../addon/edit/matchbrackets\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var cmds = CodeMirror.commands;\n  var Pos = CodeMirror.Pos;\n\n  // This is not exactly Sublime's algorithm. I couldn't make heads or tails of that.\n  function findPosSubword(doc, start, dir) {\n    if (dir < 0 && start.ch == 0) return doc.clipPos(Pos(start.line - 1));\n    var line = doc.getLine(start.line);\n    if (dir > 0 && start.ch >= line.length) return doc.clipPos(Pos(start.line + 1, 0));\n    var state = \"start\", type;\n    for (var pos = start.ch, e = dir < 0 ? 0 : line.length, i = 0; pos != e; pos += dir, i++) {\n      var next = line.charAt(dir < 0 ? pos - 1 : pos);\n      var cat = next != \"_\" && CodeMirror.isWordChar(next) ? \"w\" : \"o\";\n      if (cat == \"w\" && next.toUpperCase() == next) cat = \"W\";\n      if (state == \"start\") {\n        if (cat != \"o\") { state = \"in\"; type = cat; }\n      } else if (state == \"in\") {\n        if (type != cat) {\n          if (type == \"w\" && cat == \"W\" && dir < 0) pos--;\n          if (type == \"W\" && cat == \"w\" && dir > 0) { type = \"w\"; continue; }\n          break;\n        }\n      }\n    }\n    return Pos(start.line, pos);\n  }\n\n  function moveSubword(cm, dir) {\n    cm.extendSelectionsBy(function(range) {\n      if (cm.display.shift || cm.doc.extend || range.empty())\n        return findPosSubword(cm.doc, range.head, dir);\n      else\n        return dir < 0 ? range.from() : range.to();\n    });\n  }\n\n  cmds.goSubwordLeft = function(cm) { moveSubword(cm, -1); };\n  cmds.goSubwordRight = function(cm) { moveSubword(cm, 1); };\n\n  cmds.scrollLineUp = function(cm) {\n    var info = cm.getScrollInfo();\n    if (!cm.somethingSelected()) {\n      var visibleBottomLine = cm.lineAtHeight(info.top + info.clientHeight, \"local\");\n      if (cm.getCursor().line >= visibleBottomLine)\n        cm.execCommand(\"goLineUp\");\n    }\n    cm.scrollTo(null, info.top - cm.defaultTextHeight());\n  };\n  cmds.scrollLineDown = function(cm) {\n    var info = cm.getScrollInfo();\n    if (!cm.somethingSelected()) {\n      var visibleTopLine = cm.lineAtHeight(info.top, \"local\")+1;\n      if (cm.getCursor().line <= visibleTopLine)\n        cm.execCommand(\"goLineDown\");\n    }\n    cm.scrollTo(null, info.top + cm.defaultTextHeight());\n  };\n\n  cmds.splitSelectionByLine = function(cm) {\n    var ranges = cm.listSelections(), lineRanges = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var from = ranges[i].from(), to = ranges[i].to();\n      for (var line = from.line; line <= to.line; ++line)\n        if (!(to.line > from.line && line == to.line && to.ch == 0))\n          lineRanges.push({anchor: line == from.line ? from : Pos(line, 0),\n                           head: line == to.line ? to : Pos(line)});\n    }\n    cm.setSelections(lineRanges, 0);\n  };\n\n  cmds.singleSelectionTop = function(cm) {\n    var range = cm.listSelections()[0];\n    cm.setSelection(range.anchor, range.head, {scroll: false});\n  };\n\n  cmds.selectLine = function(cm) {\n    var ranges = cm.listSelections(), extended = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i];\n      extended.push({anchor: Pos(range.from().line, 0),\n                     head: Pos(range.to().line + 1, 0)});\n    }\n    cm.setSelections(extended);\n  };\n\n  function insertLine(cm, above) {\n    if (cm.isReadOnly()) return CodeMirror.Pass\n    cm.operation(function() {\n      var len = cm.listSelections().length, newSelection = [], last = -1;\n      for (var i = 0; i < len; i++) {\n        var head = cm.listSelections()[i].head;\n        if (head.line <= last) continue;\n        var at = Pos(head.line + (above ? 0 : 1), 0);\n        cm.replaceRange(\"\\n\", at, null, \"+insertLine\");\n        cm.indentLine(at.line, null, true);\n        newSelection.push({head: at, anchor: at});\n        last = head.line + 1;\n      }\n      cm.setSelections(newSelection);\n    });\n    cm.execCommand(\"indentAuto\");\n  }\n\n  cmds.insertLineAfter = function(cm) { return insertLine(cm, false); };\n\n  cmds.insertLineBefore = function(cm) { return insertLine(cm, true); };\n\n  function wordAt(cm, pos) {\n    var start = pos.ch, end = start, line = cm.getLine(pos.line);\n    while (start && CodeMirror.isWordChar(line.charAt(start - 1))) --start;\n    while (end < line.length && CodeMirror.isWordChar(line.charAt(end))) ++end;\n    return {from: Pos(pos.line, start), to: Pos(pos.line, end), word: line.slice(start, end)};\n  }\n\n  cmds.selectNextOccurrence = function(cm) {\n    var from = cm.getCursor(\"from\"), to = cm.getCursor(\"to\");\n    var fullWord = cm.state.sublimeFindFullWord == cm.doc.sel;\n    if (CodeMirror.cmpPos(from, to) == 0) {\n      var word = wordAt(cm, from);\n      if (!word.word) return;\n      cm.setSelection(word.from, word.to);\n      fullWord = true;\n    } else {\n      var text = cm.getRange(from, to);\n      var query = fullWord ? new RegExp(\"\\\\b\" + text + \"\\\\b\") : text;\n      var cur = cm.getSearchCursor(query, to);\n      var found = cur.findNext();\n      if (!found) {\n        cur = cm.getSearchCursor(query, Pos(cm.firstLine(), 0));\n        found = cur.findNext();\n      }\n      if (!found || isSelectedRange(cm.listSelections(), cur.from(), cur.to()))\n        return CodeMirror.Pass\n      cm.addSelection(cur.from(), cur.to());\n    }\n    if (fullWord)\n      cm.state.sublimeFindFullWord = cm.doc.sel;\n  };\n\n  function addCursorToSelection(cm, dir) {\n    var ranges = cm.listSelections(), newRanges = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i];\n      var newAnchor = cm.findPosV(\n          range.anchor, dir, \"line\", range.anchor.goalColumn);\n      var newHead = cm.findPosV(\n          range.head, dir, \"line\", range.head.goalColumn);\n      newAnchor.goalColumn = range.anchor.goalColumn != null ?\n          range.anchor.goalColumn : cm.cursorCoords(range.anchor, \"div\").left;\n      newHead.goalColumn = range.head.goalColumn != null ?\n          range.head.goalColumn : cm.cursorCoords(range.head, \"div\").left;\n      var newRange = {anchor: newAnchor, head: newHead};\n      newRanges.push(range);\n      newRanges.push(newRange);\n    }\n    cm.setSelections(newRanges);\n  }\n  cmds.addCursorToPrevLine = function(cm) { addCursorToSelection(cm, -1); };\n  cmds.addCursorToNextLine = function(cm) { addCursorToSelection(cm, 1); };\n\n  function isSelectedRange(ranges, from, to) {\n    for (var i = 0; i < ranges.length; i++)\n      if (ranges[i].from() == from && ranges[i].to() == to) return true\n    return false\n  }\n\n  var mirror = \"(){}[]\";\n  function selectBetweenBrackets(cm) {\n    var ranges = cm.listSelections(), newRanges = []\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i], pos = range.head, opening = cm.scanForBracket(pos, -1);\n      if (!opening) return false;\n      for (;;) {\n        var closing = cm.scanForBracket(pos, 1);\n        if (!closing) return false;\n        if (closing.ch == mirror.charAt(mirror.indexOf(opening.ch) + 1)) {\n          var startPos = Pos(opening.pos.line, opening.pos.ch + 1);\n          if (CodeMirror.cmpPos(startPos, range.from()) == 0 &&\n              CodeMirror.cmpPos(closing.pos, range.to()) == 0) {\n            opening = cm.scanForBracket(opening.pos, -1);\n            if (!opening) return false;\n          } else {\n            newRanges.push({anchor: startPos, head: closing.pos});\n            break;\n          }\n        }\n        pos = Pos(closing.pos.line, closing.pos.ch + 1);\n      }\n    }\n    cm.setSelections(newRanges);\n    return true;\n  }\n\n  cmds.selectScope = function(cm) {\n    selectBetweenBrackets(cm) || cm.execCommand(\"selectAll\");\n  };\n  cmds.selectBetweenBrackets = function(cm) {\n    if (!selectBetweenBrackets(cm)) return CodeMirror.Pass;\n  };\n\n  cmds.goToBracket = function(cm) {\n    cm.extendSelectionsBy(function(range) {\n      var next = cm.scanForBracket(range.head, 1);\n      if (next && CodeMirror.cmpPos(next.pos, range.head) != 0) return next.pos;\n      var prev = cm.scanForBracket(range.head, -1);\n      return prev && Pos(prev.pos.line, prev.pos.ch + 1) || range.head;\n    });\n  };\n\n  cmds.swapLineUp = function(cm) {\n    if (cm.isReadOnly()) return CodeMirror.Pass\n    var ranges = cm.listSelections(), linesToMove = [], at = cm.firstLine() - 1, newSels = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i], from = range.from().line - 1, to = range.to().line;\n      newSels.push({anchor: Pos(range.anchor.line - 1, range.anchor.ch),\n                    head: Pos(range.head.line - 1, range.head.ch)});\n      if (range.to().ch == 0 && !range.empty()) --to;\n      if (from > at) linesToMove.push(from, to);\n      else if (linesToMove.length) linesToMove[linesToMove.length - 1] = to;\n      at = to;\n    }\n    cm.operation(function() {\n      for (var i = 0; i < linesToMove.length; i += 2) {\n        var from = linesToMove[i], to = linesToMove[i + 1];\n        var line = cm.getLine(from);\n        cm.replaceRange(\"\", Pos(from, 0), Pos(from + 1, 0), \"+swapLine\");\n        if (to > cm.lastLine())\n          cm.replaceRange(\"\\n\" + line, Pos(cm.lastLine()), null, \"+swapLine\");\n        else\n          cm.replaceRange(line + \"\\n\", Pos(to, 0), null, \"+swapLine\");\n      }\n      cm.setSelections(newSels);\n      cm.scrollIntoView();\n    });\n  };\n\n  cmds.swapLineDown = function(cm) {\n    if (cm.isReadOnly()) return CodeMirror.Pass\n    var ranges = cm.listSelections(), linesToMove = [], at = cm.lastLine() + 1;\n    for (var i = ranges.length - 1; i >= 0; i--) {\n      var range = ranges[i], from = range.to().line + 1, to = range.from().line;\n      if (range.to().ch == 0 && !range.empty()) from--;\n      if (from < at) linesToMove.push(from, to);\n      else if (linesToMove.length) linesToMove[linesToMove.length - 1] = to;\n      at = to;\n    }\n    cm.operation(function() {\n      for (var i = linesToMove.length - 2; i >= 0; i -= 2) {\n        var from = linesToMove[i], to = linesToMove[i + 1];\n        var line = cm.getLine(from);\n        if (from == cm.lastLine())\n          cm.replaceRange(\"\", Pos(from - 1), Pos(from), \"+swapLine\");\n        else\n          cm.replaceRange(\"\", Pos(from, 0), Pos(from + 1, 0), \"+swapLine\");\n        cm.replaceRange(line + \"\\n\", Pos(to, 0), null, \"+swapLine\");\n      }\n      cm.scrollIntoView();\n    });\n  };\n\n  cmds.toggleCommentIndented = function(cm) {\n    cm.toggleComment({ indent: true });\n  }\n\n  cmds.joinLines = function(cm) {\n    var ranges = cm.listSelections(), joined = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i], from = range.from();\n      var start = from.line, end = range.to().line;\n      while (i < ranges.length - 1 && ranges[i + 1].from().line == end)\n        end = ranges[++i].to().line;\n      joined.push({start: start, end: end, anchor: !range.empty() && from});\n    }\n    cm.operation(function() {\n      var offset = 0, ranges = [];\n      for (var i = 0; i < joined.length; i++) {\n        var obj = joined[i];\n        var anchor = obj.anchor && Pos(obj.anchor.line - offset, obj.anchor.ch), head;\n        for (var line = obj.start; line <= obj.end; line++) {\n          var actual = line - offset;\n          if (line == obj.end) head = Pos(actual, cm.getLine(actual).length + 1);\n          if (actual < cm.lastLine()) {\n            cm.replaceRange(\" \", Pos(actual), Pos(actual + 1, /^\\s*/.exec(cm.getLine(actual + 1))[0].length));\n            ++offset;\n          }\n        }\n        ranges.push({anchor: anchor || head, head: head});\n      }\n      cm.setSelections(ranges, 0);\n    });\n  };\n\n  cmds.duplicateLine = function(cm) {\n    cm.operation(function() {\n      var rangeCount = cm.listSelections().length;\n      for (var i = 0; i < rangeCount; i++) {\n        var range = cm.listSelections()[i];\n        if (range.empty())\n          cm.replaceRange(cm.getLine(range.head.line) + \"\\n\", Pos(range.head.line, 0));\n        else\n          cm.replaceRange(cm.getRange(range.from(), range.to()), range.from());\n      }\n      cm.scrollIntoView();\n    });\n  };\n\n\n  function sortLines(cm, caseSensitive) {\n    if (cm.isReadOnly()) return CodeMirror.Pass\n    var ranges = cm.listSelections(), toSort = [], selected;\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i];\n      if (range.empty()) continue;\n      var from = range.from().line, to = range.to().line;\n      while (i < ranges.length - 1 && ranges[i + 1].from().line == to)\n        to = ranges[++i].to().line;\n      if (!ranges[i].to().ch) to--;\n      toSort.push(from, to);\n    }\n    if (toSort.length) selected = true;\n    else toSort.push(cm.firstLine(), cm.lastLine());\n\n    cm.operation(function() {\n      var ranges = [];\n      for (var i = 0; i < toSort.length; i += 2) {\n        var from = toSort[i], to = toSort[i + 1];\n        var start = Pos(from, 0), end = Pos(to);\n        var lines = cm.getRange(start, end, false);\n        if (caseSensitive)\n          lines.sort();\n        else\n          lines.sort(function(a, b) {\n            var au = a.toUpperCase(), bu = b.toUpperCase();\n            if (au != bu) { a = au; b = bu; }\n            return a < b ? -1 : a == b ? 0 : 1;\n          });\n        cm.replaceRange(lines, start, end);\n        if (selected) ranges.push({anchor: start, head: Pos(to + 1, 0)});\n      }\n      if (selected) cm.setSelections(ranges, 0);\n    });\n  }\n\n  cmds.sortLines = function(cm) { sortLines(cm, true); };\n  cmds.sortLinesInsensitive = function(cm) { sortLines(cm, false); };\n\n  cmds.nextBookmark = function(cm) {\n    var marks = cm.state.sublimeBookmarks;\n    if (marks) while (marks.length) {\n      var current = marks.shift();\n      var found = current.find();\n      if (found) {\n        marks.push(current);\n        return cm.setSelection(found.from, found.to);\n      }\n    }\n  };\n\n  cmds.prevBookmark = function(cm) {\n    var marks = cm.state.sublimeBookmarks;\n    if (marks) while (marks.length) {\n      marks.unshift(marks.pop());\n      var found = marks[marks.length - 1].find();\n      if (!found)\n        marks.pop();\n      else\n        return cm.setSelection(found.from, found.to);\n    }\n  };\n\n  cmds.toggleBookmark = function(cm) {\n    var ranges = cm.listSelections();\n    var marks = cm.state.sublimeBookmarks || (cm.state.sublimeBookmarks = []);\n    for (var i = 0; i < ranges.length; i++) {\n      var from = ranges[i].from(), to = ranges[i].to();\n      var found = ranges[i].empty() ? cm.findMarksAt(from) : cm.findMarks(from, to);\n      for (var j = 0; j < found.length; j++) {\n        if (found[j].sublimeBookmark) {\n          found[j].clear();\n          for (var k = 0; k < marks.length; k++)\n            if (marks[k] == found[j])\n              marks.splice(k--, 1);\n          break;\n        }\n      }\n      if (j == found.length)\n        marks.push(cm.markText(from, to, {sublimeBookmark: true, clearWhenEmpty: false}));\n    }\n  };\n\n  cmds.clearBookmarks = function(cm) {\n    var marks = cm.state.sublimeBookmarks;\n    if (marks) for (var i = 0; i < marks.length; i++) marks[i].clear();\n    marks.length = 0;\n  };\n\n  cmds.selectBookmarks = function(cm) {\n    var marks = cm.state.sublimeBookmarks, ranges = [];\n    if (marks) for (var i = 0; i < marks.length; i++) {\n      var found = marks[i].find();\n      if (!found)\n        marks.splice(i--, 0);\n      else\n        ranges.push({anchor: found.from, head: found.to});\n    }\n    if (ranges.length)\n      cm.setSelections(ranges, 0);\n  };\n\n  function modifyWordOrSelection(cm, mod) {\n    cm.operation(function() {\n      var ranges = cm.listSelections(), indices = [], replacements = [];\n      for (var i = 0; i < ranges.length; i++) {\n        var range = ranges[i];\n        if (range.empty()) { indices.push(i); replacements.push(\"\"); }\n        else replacements.push(mod(cm.getRange(range.from(), range.to())));\n      }\n      cm.replaceSelections(replacements, \"around\", \"case\");\n      for (var i = indices.length - 1, at; i >= 0; i--) {\n        var range = ranges[indices[i]];\n        if (at && CodeMirror.cmpPos(range.head, at) > 0) continue;\n        var word = wordAt(cm, range.head);\n        at = word.from;\n        cm.replaceRange(mod(word.word), word.from, word.to);\n      }\n    });\n  }\n\n  cmds.smartBackspace = function(cm) {\n    if (cm.somethingSelected()) return CodeMirror.Pass;\n\n    cm.operation(function() {\n      var cursors = cm.listSelections();\n      var indentUnit = cm.getOption(\"indentUnit\");\n\n      for (var i = cursors.length - 1; i >= 0; i--) {\n        var cursor = cursors[i].head;\n        var toStartOfLine = cm.getRange({line: cursor.line, ch: 0}, cursor);\n        var column = CodeMirror.countColumn(toStartOfLine, null, cm.getOption(\"tabSize\"));\n\n        // Delete by one character by default\n        var deletePos = cm.findPosH(cursor, -1, \"char\", false);\n\n        if (toStartOfLine && !/\\S/.test(toStartOfLine) && column % indentUnit == 0) {\n          var prevIndent = new Pos(cursor.line,\n            CodeMirror.findColumn(toStartOfLine, column - indentUnit, indentUnit));\n\n          // Smart delete only if we found a valid prevIndent location\n          if (prevIndent.ch != cursor.ch) deletePos = prevIndent;\n        }\n\n        cm.replaceRange(\"\", deletePos, cursor, \"+delete\");\n      }\n    });\n  };\n\n  cmds.delLineRight = function(cm) {\n    cm.operation(function() {\n      var ranges = cm.listSelections();\n      for (var i = ranges.length - 1; i >= 0; i--)\n        cm.replaceRange(\"\", ranges[i].anchor, Pos(ranges[i].to().line), \"+delete\");\n      cm.scrollIntoView();\n    });\n  };\n\n  cmds.upcaseAtCursor = function(cm) {\n    modifyWordOrSelection(cm, function(str) { return str.toUpperCase(); });\n  };\n  cmds.downcaseAtCursor = function(cm) {\n    modifyWordOrSelection(cm, function(str) { return str.toLowerCase(); });\n  };\n\n  cmds.setSublimeMark = function(cm) {\n    if (cm.state.sublimeMark) cm.state.sublimeMark.clear();\n    cm.state.sublimeMark = cm.setBookmark(cm.getCursor());\n  };\n  cmds.selectToSublimeMark = function(cm) {\n    var found = cm.state.sublimeMark && cm.state.sublimeMark.find();\n    if (found) cm.setSelection(cm.getCursor(), found);\n  };\n  cmds.deleteToSublimeMark = function(cm) {\n    var found = cm.state.sublimeMark && cm.state.sublimeMark.find();\n    if (found) {\n      var from = cm.getCursor(), to = found;\n      if (CodeMirror.cmpPos(from, to) > 0) { var tmp = to; to = from; from = tmp; }\n      cm.state.sublimeKilled = cm.getRange(from, to);\n      cm.replaceRange(\"\", from, to);\n    }\n  };\n  cmds.swapWithSublimeMark = function(cm) {\n    var found = cm.state.sublimeMark && cm.state.sublimeMark.find();\n    if (found) {\n      cm.state.sublimeMark.clear();\n      cm.state.sublimeMark = cm.setBookmark(cm.getCursor());\n      cm.setCursor(found);\n    }\n  };\n  cmds.sublimeYank = function(cm) {\n    if (cm.state.sublimeKilled != null)\n      cm.replaceSelection(cm.state.sublimeKilled, null, \"paste\");\n  };\n\n  cmds.showInCenter = function(cm) {\n    var pos = cm.cursorCoords(null, \"local\");\n    cm.scrollTo(null, (pos.top + pos.bottom) / 2 - cm.getScrollInfo().clientHeight / 2);\n  };\n\n  function getTarget(cm) {\n    var from = cm.getCursor(\"from\"), to = cm.getCursor(\"to\");\n    if (CodeMirror.cmpPos(from, to) == 0) {\n      var word = wordAt(cm, from);\n      if (!word.word) return;\n      from = word.from;\n      to = word.to;\n    }\n    return {from: from, to: to, query: cm.getRange(from, to), word: word};\n  }\n\n  function findAndGoTo(cm, forward) {\n    var target = getTarget(cm);\n    if (!target) return;\n    var query = target.query;\n    var cur = cm.getSearchCursor(query, forward ? target.to : target.from);\n\n    if (forward ? cur.findNext() : cur.findPrevious()) {\n      cm.setSelection(cur.from(), cur.to());\n    } else {\n      cur = cm.getSearchCursor(query, forward ? Pos(cm.firstLine(), 0)\n                                              : cm.clipPos(Pos(cm.lastLine())));\n      if (forward ? cur.findNext() : cur.findPrevious())\n        cm.setSelection(cur.from(), cur.to());\n      else if (target.word)\n        cm.setSelection(target.from, target.to);\n    }\n  };\n  cmds.findUnder = function(cm) { findAndGoTo(cm, true); };\n  cmds.findUnderPrevious = function(cm) { findAndGoTo(cm,false); };\n  cmds.findAllUnder = function(cm) {\n    var target = getTarget(cm);\n    if (!target) return;\n    var cur = cm.getSearchCursor(target.query);\n    var matches = [];\n    var primaryIndex = -1;\n    while (cur.findNext()) {\n      matches.push({anchor: cur.from(), head: cur.to()});\n      if (cur.from().line <= target.from.line && cur.from().ch <= target.from.ch)\n        primaryIndex++;\n    }\n    cm.setSelections(matches, primaryIndex);\n  };\n\n\n  var keyMap = CodeMirror.keyMap;\n  keyMap.macSublime = {\n    \"Cmd-Left\": \"goLineStartSmart\",\n    \"Shift-Tab\": \"indentLess\",\n    \"Shift-Ctrl-K\": \"deleteLine\",\n    \"Alt-Q\": \"wrapLines\",\n    \"Ctrl-Left\": \"goSubwordLeft\",\n    \"Ctrl-Right\": \"goSubwordRight\",\n    \"Ctrl-Alt-Up\": \"scrollLineUp\",\n    \"Ctrl-Alt-Down\": \"scrollLineDown\",\n    \"Cmd-L\": \"selectLine\",\n    \"Shift-Cmd-L\": \"splitSelectionByLine\",\n    \"Esc\": \"singleSelectionTop\",\n    \"Cmd-Enter\": \"insertLineAfter\",\n    \"Shift-Cmd-Enter\": \"insertLineBefore\",\n    \"Cmd-D\": \"selectNextOccurrence\",\n    \"Shift-Cmd-Space\": \"selectScope\",\n    \"Shift-Cmd-M\": \"selectBetweenBrackets\",\n    \"Cmd-M\": \"goToBracket\",\n    \"Cmd-Ctrl-Up\": \"swapLineUp\",\n    \"Cmd-Ctrl-Down\": \"swapLineDown\",\n    \"Cmd-/\": \"toggleCommentIndented\",\n    \"Cmd-J\": \"joinLines\",\n    \"Shift-Cmd-D\": \"duplicateLine\",\n    \"F5\": \"sortLines\",\n    \"Cmd-F5\": \"sortLinesInsensitive\",\n    \"F2\": \"nextBookmark\",\n    \"Shift-F2\": \"prevBookmark\",\n    \"Cmd-F2\": \"toggleBookmark\",\n    \"Shift-Cmd-F2\": \"clearBookmarks\",\n    \"Alt-F2\": \"selectBookmarks\",\n    \"Backspace\": \"smartBackspace\",\n    \"Cmd-K Cmd-K\": \"delLineRight\",\n    \"Cmd-K Cmd-U\": \"upcaseAtCursor\",\n    \"Cmd-K Cmd-L\": \"downcaseAtCursor\",\n    \"Cmd-K Cmd-Space\": \"setSublimeMark\",\n    \"Cmd-K Cmd-A\": \"selectToSublimeMark\",\n    \"Cmd-K Cmd-W\": \"deleteToSublimeMark\",\n    \"Cmd-K Cmd-X\": \"swapWithSublimeMark\",\n    \"Cmd-K Cmd-Y\": \"sublimeYank\",\n    \"Cmd-K Cmd-C\": \"showInCenter\",\n    \"Cmd-K Cmd-G\": \"clearBookmarks\",\n    \"Cmd-K Cmd-Backspace\": \"delLineLeft\",\n    \"Cmd-K Cmd-0\": \"unfoldAll\",\n    \"Cmd-K Cmd-J\": \"unfoldAll\",\n    \"Ctrl-Shift-Up\": \"addCursorToPrevLine\",\n    \"Ctrl-Shift-Down\": \"addCursorToNextLine\",\n    \"Cmd-F3\": \"findUnder\",\n    \"Shift-Cmd-F3\": \"findUnderPrevious\",\n    \"Alt-F3\": \"findAllUnder\",\n    \"Shift-Cmd-[\": \"fold\",\n    \"Shift-Cmd-]\": \"unfold\",\n    \"Cmd-I\": \"findIncremental\",\n    \"Shift-Cmd-I\": \"findIncrementalReverse\",\n    \"Cmd-H\": \"replace\",\n    \"F3\": \"findNext\",\n    \"Shift-F3\": \"findPrev\",\n    \"fallthrough\": \"macDefault\"\n  };\n  CodeMirror.normalizeKeyMap(keyMap.macSublime);\n\n  keyMap.pcSublime = {\n    \"Shift-Tab\": \"indentLess\",\n    \"Shift-Ctrl-K\": \"deleteLine\",\n    \"Alt-Q\": \"wrapLines\",\n    \"Ctrl-T\": \"transposeChars\",\n    \"Alt-Left\": \"goSubwordLeft\",\n    \"Alt-Right\": \"goSubwordRight\",\n    \"Ctrl-Up\": \"scrollLineUp\",\n    \"Ctrl-Down\": \"scrollLineDown\",\n    \"Ctrl-L\": \"selectLine\",\n    \"Shift-Ctrl-L\": \"splitSelectionByLine\",\n    \"Esc\": \"singleSelectionTop\",\n    \"Ctrl-Enter\": \"insertLineAfter\",\n    \"Shift-Ctrl-Enter\": \"insertLineBefore\",\n    \"Ctrl-D\": \"selectNextOccurrence\",\n    \"Shift-Ctrl-Space\": \"selectScope\",\n    \"Shift-Ctrl-M\": \"selectBetweenBrackets\",\n    \"Ctrl-M\": \"goToBracket\",\n    \"Shift-Ctrl-Up\": \"swapLineUp\",\n    \"Shift-Ctrl-Down\": \"swapLineDown\",\n    \"Ctrl-/\": \"toggleCommentIndented\",\n    \"Ctrl-J\": \"joinLines\",\n    \"Shift-Ctrl-D\": \"duplicateLine\",\n    \"F9\": \"sortLines\",\n    \"Ctrl-F9\": \"sortLinesInsensitive\",\n    \"F2\": \"nextBookmark\",\n    \"Shift-F2\": \"prevBookmark\",\n    \"Ctrl-F2\": \"toggleBookmark\",\n    \"Shift-Ctrl-F2\": \"clearBookmarks\",\n    \"Alt-F2\": \"selectBookmarks\",\n    \"Backspace\": \"smartBackspace\",\n    \"Ctrl-K Ctrl-K\": \"delLineRight\",\n    \"Ctrl-K Ctrl-U\": \"upcaseAtCursor\",\n    \"Ctrl-K Ctrl-L\": \"downcaseAtCursor\",\n    \"Ctrl-K Ctrl-Space\": \"setSublimeMark\",\n    \"Ctrl-K Ctrl-A\": \"selectToSublimeMark\",\n    \"Ctrl-K Ctrl-W\": \"deleteToSublimeMark\",\n    \"Ctrl-K Ctrl-X\": \"swapWithSublimeMark\",\n    \"Ctrl-K Ctrl-Y\": \"sublimeYank\",\n    \"Ctrl-K Ctrl-C\": \"showInCenter\",\n    \"Ctrl-K Ctrl-G\": \"clearBookmarks\",\n    \"Ctrl-K Ctrl-Backspace\": \"delLineLeft\",\n    \"Ctrl-K Ctrl-0\": \"unfoldAll\",\n    \"Ctrl-K Ctrl-J\": \"unfoldAll\",\n    \"Ctrl-Alt-Up\": \"addCursorToPrevLine\",\n    \"Ctrl-Alt-Down\": \"addCursorToNextLine\",\n    \"Ctrl-F3\": \"findUnder\",\n    \"Shift-Ctrl-F3\": \"findUnderPrevious\",\n    \"Alt-F3\": \"findAllUnder\",\n    \"Shift-Ctrl-[\": \"fold\",\n    \"Shift-Ctrl-]\": \"unfold\",\n    \"Ctrl-I\": \"findIncremental\",\n    \"Shift-Ctrl-I\": \"findIncrementalReverse\",\n    \"Ctrl-H\": \"replace\",\n    \"F3\": \"findNext\",\n    \"Shift-F3\": \"findPrev\",\n    \"fallthrough\": \"pcDefault\"\n  };\n  CodeMirror.normalizeKeyMap(keyMap.pcSublime);\n\n  var mac = keyMap.default == keyMap.macDefault;\n  keyMap.sublime = mac ? keyMap.macSublime : keyMap.pcSublime;\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var HINT_ELEMENT_CLASS        = \"CodeMirror-hint\";\n  var ACTIVE_HINT_ELEMENT_CLASS = \"CodeMirror-hint-active\";\n\n  // This is the old interface, kept around for now to stay\n  // backwards-compatible.\n  CodeMirror.showHint = function(cm, getHints, options) {\n    if (!getHints) return cm.showHint(options);\n    if (options && options.async) getHints.async = true;\n    var newOpts = {hint: getHints};\n    if (options) for (var prop in options) newOpts[prop] = options[prop];\n    return cm.showHint(newOpts);\n  };\n\n  CodeMirror.defineExtension(\"showHint\", function(options) {\n    options = parseOptions(this, this.getCursor(\"start\"), options);\n    var selections = this.listSelections()\n    if (selections.length > 1) return;\n    // By default, don't allow completion when something is selected.\n    // A hint function can have a `supportsSelection` property to\n    // indicate that it can handle selections.\n    if (this.somethingSelected()) {\n      if (!options.hint.supportsSelection) return;\n      // Don't try with cross-line selections\n      for (var i = 0; i < selections.length; i++)\n        if (selections[i].head.line != selections[i].anchor.line) return;\n    }\n\n    if (this.state.completionActive) this.state.completionActive.close();\n    var completion = this.state.completionActive = new Completion(this, options);\n    if (!completion.options.hint) return;\n\n    CodeMirror.signal(this, \"startCompletion\", this);\n    completion.update(true);\n  });\n\n  CodeMirror.defineExtension(\"closeHint\", function() {\n    if (this.state.completionActive) this.state.completionActive.close()\n  })\n\n  function Completion(cm, options) {\n    this.cm = cm;\n    this.options = options;\n    this.widget = null;\n    this.debounce = 0;\n    this.tick = 0;\n    this.startPos = this.cm.getCursor(\"start\");\n    this.startLen = this.cm.getLine(this.startPos.line).length - this.cm.getSelection().length;\n\n    var self = this;\n    cm.on(\"cursorActivity\", this.activityFunc = function() { self.cursorActivity(); });\n  }\n\n  var requestAnimationFrame = window.requestAnimationFrame || function(fn) {\n    return setTimeout(fn, 1000/60);\n  };\n  var cancelAnimationFrame = window.cancelAnimationFrame || clearTimeout;\n\n  Completion.prototype = {\n    close: function() {\n      if (!this.active()) return;\n      this.cm.state.completionActive = null;\n      this.tick = null;\n      this.cm.off(\"cursorActivity\", this.activityFunc);\n\n      if (this.widget && this.data) CodeMirror.signal(this.data, \"close\");\n      if (this.widget) this.widget.close();\n      CodeMirror.signal(this.cm, \"endCompletion\", this.cm);\n    },\n\n    active: function() {\n      return this.cm.state.completionActive == this;\n    },\n\n    pick: function(data, i) {\n      var completion = data.list[i];\n      if (completion.hint) completion.hint(this.cm, data, completion);\n      else this.cm.replaceRange(getText(completion), completion.from || data.from,\n                                completion.to || data.to, \"complete\");\n      CodeMirror.signal(data, \"pick\", completion);\n      this.close();\n    },\n\n    cursorActivity: function() {\n      if (this.debounce) {\n        cancelAnimationFrame(this.debounce);\n        this.debounce = 0;\n      }\n\n      var pos = this.cm.getCursor(), line = this.cm.getLine(pos.line);\n      if (pos.line != this.startPos.line || line.length - pos.ch != this.startLen - this.startPos.ch ||\n          pos.ch < this.startPos.ch || this.cm.somethingSelected() ||\n          (!pos.ch || this.options.closeCharacters.test(line.charAt(pos.ch - 1)))) {\n        this.close();\n      } else {\n        var self = this;\n        this.debounce = requestAnimationFrame(function() {self.update();});\n        if (this.widget) this.widget.disable();\n      }\n    },\n\n    update: function(first) {\n      if (this.tick == null) return\n      var self = this, myTick = ++this.tick\n      fetchHints(this.options.hint, this.cm, this.options, function(data) {\n        if (self.tick == myTick) self.finishUpdate(data, first)\n      })\n    },\n\n    finishUpdate: function(data, first) {\n      if (this.data) CodeMirror.signal(this.data, \"update\");\n\n      var picked = (this.widget && this.widget.picked) || (first && this.options.completeSingle);\n      if (this.widget) this.widget.close();\n\n      this.data = data;\n\n      if (data && data.list.length) {\n        if (picked && data.list.length == 1) {\n          this.pick(data, 0);\n        } else {\n          this.widget = new Widget(this, data);\n          CodeMirror.signal(data, \"shown\");\n        }\n      }\n    }\n  };\n\n  function parseOptions(cm, pos, options) {\n    var editor = cm.options.hintOptions;\n    var out = {};\n    for (var prop in defaultOptions) out[prop] = defaultOptions[prop];\n    if (editor) for (var prop in editor)\n      if (editor[prop] !== undefined) out[prop] = editor[prop];\n    if (options) for (var prop in options)\n      if (options[prop] !== undefined) out[prop] = options[prop];\n    if (out.hint.resolve) out.hint = out.hint.resolve(cm, pos)\n    return out;\n  }\n\n  function getText(completion) {\n    if (typeof completion == \"string\") return completion;\n    else return completion.text;\n  }\n\n  function buildKeyMap(completion, handle) {\n    var baseMap = {\n      Up: function() {handle.moveFocus(-1);},\n      Down: function() {handle.moveFocus(1);},\n      PageUp: function() {handle.moveFocus(-handle.menuSize() + 1, true);},\n      PageDown: function() {handle.moveFocus(handle.menuSize() - 1, true);},\n      Home: function() {handle.setFocus(0);},\n      End: function() {handle.setFocus(handle.length - 1);},\n      Enter: handle.pick,\n      Tab: handle.pick,\n      Esc: handle.close\n    };\n\n    var mac = /Mac/.test(navigator.platform);\n\n    if (mac) {\n      baseMap[\"Ctrl-P\"] = function() {handle.moveFocus(-1);};\n      baseMap[\"Ctrl-N\"] = function() {handle.moveFocus(1);};\n    }\n\n    var custom = completion.options.customKeys;\n    var ourMap = custom ? {} : baseMap;\n    function addBinding(key, val) {\n      var bound;\n      if (typeof val != \"string\")\n        bound = function(cm) { return val(cm, handle); };\n      // This mechanism is deprecated\n      else if (baseMap.hasOwnProperty(val))\n        bound = baseMap[val];\n      else\n        bound = val;\n      ourMap[key] = bound;\n    }\n    if (custom)\n      for (var key in custom) if (custom.hasOwnProperty(key))\n        addBinding(key, custom[key]);\n    var extra = completion.options.extraKeys;\n    if (extra)\n      for (var key in extra) if (extra.hasOwnProperty(key))\n        addBinding(key, extra[key]);\n    return ourMap;\n  }\n\n  function getHintElement(hintsElement, el) {\n    while (el && el != hintsElement) {\n      if (el.nodeName.toUpperCase() === \"LI\" && el.parentNode == hintsElement) return el;\n      el = el.parentNode;\n    }\n  }\n\n  function Widget(completion, data) {\n    this.completion = completion;\n    this.data = data;\n    this.picked = false;\n    var widget = this, cm = completion.cm;\n    var ownerDocument = cm.getInputField().ownerDocument;\n    var parentWindow = ownerDocument.defaultView || ownerDocument.parentWindow;\n\n    var hints = this.hints = ownerDocument.createElement(\"ul\");\n    var theme = completion.cm.options.theme;\n    hints.className = \"CodeMirror-hints \" + theme;\n    this.selectedHint = data.selectedHint || 0;\n\n    var completions = data.list;\n    for (var i = 0; i < completions.length; ++i) {\n      var elt = hints.appendChild(ownerDocument.createElement(\"li\")), cur = completions[i];\n      var className = HINT_ELEMENT_CLASS + (i != this.selectedHint ? \"\" : \" \" + ACTIVE_HINT_ELEMENT_CLASS);\n      if (cur.className != null) className = cur.className + \" \" + className;\n      elt.className = className;\n      if (cur.render) cur.render(elt, data, cur);\n      else elt.appendChild(ownerDocument.createTextNode(cur.displayText || getText(cur)));\n      elt.hintId = i;\n    }\n\n    var pos = cm.cursorCoords(completion.options.alignWithWord ? data.from : null);\n    var left = pos.left, top = pos.bottom, below = true;\n    hints.style.left = left + \"px\";\n    hints.style.top = top + \"px\";\n    // If we're at the edge of the screen, then we want the menu to appear on the left of the cursor.\n    var winW = parentWindow.innerWidth || Math.max(ownerDocument.body.offsetWidth, ownerDocument.documentElement.offsetWidth);\n    var winH = parentWindow.innerHeight || Math.max(ownerDocument.body.offsetHeight, ownerDocument.documentElement.offsetHeight);\n    (completion.options.container || ownerDocument.body).appendChild(hints);\n    var box = hints.getBoundingClientRect(), overlapY = box.bottom - winH;\n    var scrolls = hints.scrollHeight > hints.clientHeight + 1\n    var startScroll = cm.getScrollInfo();\n\n    if (overlapY > 0) {\n      var height = box.bottom - box.top, curTop = pos.top - (pos.bottom - box.top);\n      if (curTop - height > 0) { // Fits above cursor\n        hints.style.top = (top = pos.top - height) + \"px\";\n        below = false;\n      } else if (height > winH) {\n        hints.style.height = (winH - 5) + \"px\";\n        hints.style.top = (top = pos.bottom - box.top) + \"px\";\n        var cursor = cm.getCursor();\n        if (data.from.ch != cursor.ch) {\n          pos = cm.cursorCoords(cursor);\n          hints.style.left = (left = pos.left) + \"px\";\n          box = hints.getBoundingClientRect();\n        }\n      }\n    }\n    var overlapX = box.right - winW;\n    if (overlapX > 0) {\n      if (box.right - box.left > winW) {\n        hints.style.width = (winW - 5) + \"px\";\n        overlapX -= (box.right - box.left) - winW;\n      }\n      hints.style.left = (left = pos.left - overlapX) + \"px\";\n    }\n    if (scrolls) for (var node = hints.firstChild; node; node = node.nextSibling)\n      node.style.paddingRight = cm.display.nativeBarWidth + \"px\"\n\n    cm.addKeyMap(this.keyMap = buildKeyMap(completion, {\n      moveFocus: function(n, avoidWrap) { widget.changeActive(widget.selectedHint + n, avoidWrap); },\n      setFocus: function(n) { widget.changeActive(n); },\n      menuSize: function() { return widget.screenAmount(); },\n      length: completions.length,\n      close: function() { completion.close(); },\n      pick: function() { widget.pick(); },\n      data: data\n    }));\n\n    if (completion.options.closeOnUnfocus) {\n      var closingOnBlur;\n      cm.on(\"blur\", this.onBlur = function() { closingOnBlur = setTimeout(function() { completion.close(); }, 100); });\n      cm.on(\"focus\", this.onFocus = function() { clearTimeout(closingOnBlur); });\n    }\n\n    cm.on(\"scroll\", this.onScroll = function() {\n      var curScroll = cm.getScrollInfo(), editor = cm.getWrapperElement().getBoundingClientRect();\n      var newTop = top + startScroll.top - curScroll.top;\n      var point = newTop - (parentWindow.pageYOffset || (ownerDocument.documentElement || ownerDocument.body).scrollTop);\n      if (!below) point += hints.offsetHeight;\n      if (point <= editor.top || point >= editor.bottom) return completion.close();\n      hints.style.top = newTop + \"px\";\n      hints.style.left = (left + startScroll.left - curScroll.left) + \"px\";\n    });\n\n    CodeMirror.on(hints, \"dblclick\", function(e) {\n      var t = getHintElement(hints, e.target || e.srcElement);\n      if (t && t.hintId != null) {widget.changeActive(t.hintId); widget.pick();}\n    });\n\n    CodeMirror.on(hints, \"click\", function(e) {\n      var t = getHintElement(hints, e.target || e.srcElement);\n      if (t && t.hintId != null) {\n        widget.changeActive(t.hintId);\n        if (completion.options.completeOnSingleClick) widget.pick();\n      }\n    });\n\n    CodeMirror.on(hints, \"mousedown\", function() {\n      setTimeout(function(){cm.focus();}, 20);\n    });\n\n    CodeMirror.signal(data, \"select\", completions[this.selectedHint], hints.childNodes[this.selectedHint]);\n    return true;\n  }\n\n  Widget.prototype = {\n    close: function() {\n      if (this.completion.widget != this) return;\n      this.completion.widget = null;\n      this.hints.parentNode.removeChild(this.hints);\n      this.completion.cm.removeKeyMap(this.keyMap);\n\n      var cm = this.completion.cm;\n      if (this.completion.options.closeOnUnfocus) {\n        cm.off(\"blur\", this.onBlur);\n        cm.off(\"focus\", this.onFocus);\n      }\n      cm.off(\"scroll\", this.onScroll);\n    },\n\n    disable: function() {\n      this.completion.cm.removeKeyMap(this.keyMap);\n      var widget = this;\n      this.keyMap = {Enter: function() { widget.picked = true; }};\n      this.completion.cm.addKeyMap(this.keyMap);\n    },\n\n    pick: function() {\n      this.completion.pick(this.data, this.selectedHint);\n    },\n\n    changeActive: function(i, avoidWrap) {\n      if (i >= this.data.list.length)\n        i = avoidWrap ? this.data.list.length - 1 : 0;\n      else if (i < 0)\n        i = avoidWrap ? 0  : this.data.list.length - 1;\n      if (this.selectedHint == i) return;\n      var node = this.hints.childNodes[this.selectedHint];\n      if (node) node.className = node.className.replace(\" \" + ACTIVE_HINT_ELEMENT_CLASS, \"\");\n      node = this.hints.childNodes[this.selectedHint = i];\n      node.className += \" \" + ACTIVE_HINT_ELEMENT_CLASS;\n      if (node.offsetTop < this.hints.scrollTop)\n        this.hints.scrollTop = node.offsetTop - 3;\n      else if (node.offsetTop + node.offsetHeight > this.hints.scrollTop + this.hints.clientHeight)\n        this.hints.scrollTop = node.offsetTop + node.offsetHeight - this.hints.clientHeight + 3;\n      CodeMirror.signal(this.data, \"select\", this.data.list[this.selectedHint], node);\n    },\n\n    screenAmount: function() {\n      return Math.floor(this.hints.clientHeight / this.hints.firstChild.offsetHeight) || 1;\n    }\n  };\n\n  function applicableHelpers(cm, helpers) {\n    if (!cm.somethingSelected()) return helpers\n    var result = []\n    for (var i = 0; i < helpers.length; i++)\n      if (helpers[i].supportsSelection) result.push(helpers[i])\n    return result\n  }\n\n  function fetchHints(hint, cm, options, callback) {\n    if (hint.async) {\n      hint(cm, callback, options)\n    } else {\n      var result = hint(cm, options)\n      if (result && result.then) result.then(callback)\n      else callback(result)\n    }\n  }\n\n  function resolveAutoHints(cm, pos) {\n    var helpers = cm.getHelpers(pos, \"hint\"), words\n    if (helpers.length) {\n      var resolved = function(cm, callback, options) {\n        var app = applicableHelpers(cm, helpers);\n        function run(i) {\n          if (i == app.length) return callback(null)\n          fetchHints(app[i], cm, options, function(result) {\n            if (result && result.list.length > 0) callback(result)\n            else run(i + 1)\n          })\n        }\n        run(0)\n      }\n      resolved.async = true\n      resolved.supportsSelection = true\n      return resolved\n    } else if (words = cm.getHelper(cm.getCursor(), \"hintWords\")) {\n      return function(cm) { return CodeMirror.hint.fromList(cm, {words: words}) }\n    } else if (CodeMirror.hint.anyword) {\n      return function(cm, options) { return CodeMirror.hint.anyword(cm, options) }\n    } else {\n      return function() {}\n    }\n  }\n\n  CodeMirror.registerHelper(\"hint\", \"auto\", {\n    resolve: resolveAutoHints\n  });\n\n  CodeMirror.registerHelper(\"hint\", \"fromList\", function(cm, options) {\n    var cur = cm.getCursor(), token = cm.getTokenAt(cur)\n    var term, from = CodeMirror.Pos(cur.line, token.start), to = cur\n    if (token.start < cur.ch && /\\w/.test(token.string.charAt(cur.ch - token.start - 1))) {\n      term = token.string.substr(0, cur.ch - token.start)\n    } else {\n      term = \"\"\n      from = cur\n    }\n    var found = [];\n    for (var i = 0; i < options.words.length; i++) {\n      var word = options.words[i];\n      if (word.slice(0, term.length) == term)\n        found.push(word);\n    }\n\n    if (found.length) return {list: found, from: from, to: to};\n  });\n\n  CodeMirror.commands.autocomplete = CodeMirror.showHint;\n\n  var defaultOptions = {\n    hint: CodeMirror.hint.auto,\n    completeSingle: true,\n    alignWithWord: true,\n    closeCharacters: /[\\s()\\[\\]{};:>,]/,\n    closeOnUnfocus: true,\n    completeOnSingleClick: true,\n    container: null,\n    customKeys: null,\n    extraKeys: null\n  };\n\n  CodeMirror.defineOption(\"hintOptions\", null);\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineExtension(\"annotateScrollbar\", function(options) {\n    if (typeof options == \"string\") options = {className: options};\n    return new Annotation(this, options);\n  });\n\n  CodeMirror.defineOption(\"scrollButtonHeight\", 0);\n\n  function Annotation(cm, options) {\n    this.cm = cm;\n    this.options = options;\n    this.buttonHeight = options.scrollButtonHeight || cm.getOption(\"scrollButtonHeight\");\n    this.annotations = [];\n    this.doRedraw = this.doUpdate = null;\n    this.div = cm.getWrapperElement().appendChild(document.createElement(\"div\"));\n    this.div.style.cssText = \"position: absolute; right: 0; top: 0; z-index: 7; pointer-events: none\";\n    this.computeScale();\n\n    function scheduleRedraw(delay) {\n      clearTimeout(self.doRedraw);\n      self.doRedraw = setTimeout(function() { self.redraw(); }, delay);\n    }\n\n    var self = this;\n    cm.on(\"refresh\", this.resizeHandler = function() {\n      clearTimeout(self.doUpdate);\n      self.doUpdate = setTimeout(function() {\n        if (self.computeScale()) scheduleRedraw(20);\n      }, 100);\n    });\n    cm.on(\"markerAdded\", this.resizeHandler);\n    cm.on(\"markerCleared\", this.resizeHandler);\n    if (options.listenForChanges !== false)\n      cm.on(\"change\", this.changeHandler = function() {\n        scheduleRedraw(250);\n      });\n  }\n\n  Annotation.prototype.computeScale = function() {\n    var cm = this.cm;\n    var hScale = (cm.getWrapperElement().clientHeight - cm.display.barHeight - this.buttonHeight * 2) /\n      cm.getScrollerElement().scrollHeight\n    if (hScale != this.hScale) {\n      this.hScale = hScale;\n      return true;\n    }\n  };\n\n  Annotation.prototype.update = function(annotations) {\n    this.annotations = annotations;\n    this.redraw();\n  };\n\n  Annotation.prototype.redraw = function(compute) {\n    if (compute !== false) this.computeScale();\n    var cm = this.cm, hScale = this.hScale;\n\n    var frag = document.createDocumentFragment(), anns = this.annotations;\n\n    var wrapping = cm.getOption(\"lineWrapping\");\n    var singleLineH = wrapping && cm.defaultTextHeight() * 1.5;\n    var curLine = null, curLineObj = null;\n    function getY(pos, top) {\n      if (curLine != pos.line) {\n        curLine = pos.line;\n        curLineObj = cm.getLineHandle(curLine);\n      }\n      if ((curLineObj.widgets && curLineObj.widgets.length) ||\n          (wrapping && curLineObj.height > singleLineH))\n        return cm.charCoords(pos, \"local\")[top ? \"top\" : \"bottom\"];\n      var topY = cm.heightAtLine(curLineObj, \"local\");\n      return topY + (top ? 0 : curLineObj.height);\n    }\n\n    var lastLine = cm.lastLine()\n    if (cm.display.barWidth) for (var i = 0, nextTop; i < anns.length; i++) {\n      var ann = anns[i];\n      if (ann.to.line > lastLine) continue;\n      var top = nextTop || getY(ann.from, true) * hScale;\n      var bottom = getY(ann.to, false) * hScale;\n      while (i < anns.length - 1) {\n        if (anns[i + 1].to.line > lastLine) break;\n        nextTop = getY(anns[i + 1].from, true) * hScale;\n        if (nextTop > bottom + .9) break;\n        ann = anns[++i];\n        bottom = getY(ann.to, false) * hScale;\n      }\n      if (bottom == top) continue;\n      var height = Math.max(bottom - top, 3);\n\n      var elt = frag.appendChild(document.createElement(\"div\"));\n      elt.style.cssText = \"position: absolute; right: 0px; width: \" + Math.max(cm.display.barWidth - 1, 2) + \"px; top: \"\n        + (top + this.buttonHeight) + \"px; height: \" + height + \"px\";\n      elt.className = this.options.className;\n      if (ann.id) {\n        elt.setAttribute(\"annotation-id\", ann.id);\n      }\n    }\n    this.div.textContent = \"\";\n    this.div.appendChild(frag);\n  };\n\n  Annotation.prototype.clear = function() {\n    this.cm.off(\"refresh\", this.resizeHandler);\n    this.cm.off(\"markerAdded\", this.resizeHandler);\n    this.cm.off(\"markerCleared\", this.resizeHandler);\n    if (this.changeHandler) this.cm.off(\"change\", this.changeHandler);\n    this.div.parentNode.removeChild(this.div);\n  };\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n// Utility function that allows modes to be combined. The mode given\n// as the base argument takes care of most of the normal mode\n// functionality, but a second (typically simple) mode is used, which\n// can override the style of text. Both modes get to parse all of the\n// text, but when both assign a non-null style to a piece of code, the\n// overlay wins, unless the combine argument was true and not overridden,\n// or state.overlay.combineTokens was true, in which case the styles are\n// combined.\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.overlayMode = function(base, overlay, combine) {\n  return {\n    startState: function() {\n      return {\n        base: CodeMirror.startState(base),\n        overlay: CodeMirror.startState(overlay),\n        basePos: 0, baseCur: null,\n        overlayPos: 0, overlayCur: null,\n        streamSeen: null\n      };\n    },\n    copyState: function(state) {\n      return {\n        base: CodeMirror.copyState(base, state.base),\n        overlay: CodeMirror.copyState(overlay, state.overlay),\n        basePos: state.basePos, baseCur: null,\n        overlayPos: state.overlayPos, overlayCur: null\n      };\n    },\n\n    token: function(stream, state) {\n      if (stream != state.streamSeen ||\n          Math.min(state.basePos, state.overlayPos) < stream.start) {\n        state.streamSeen = stream;\n        state.basePos = state.overlayPos = stream.start;\n      }\n\n      if (stream.start == state.basePos) {\n        state.baseCur = base.token(stream, state.base);\n        state.basePos = stream.pos;\n      }\n      if (stream.start == state.overlayPos) {\n        stream.pos = stream.start;\n        state.overlayCur = overlay.token(stream, state.overlay);\n        state.overlayPos = stream.pos;\n      }\n      stream.pos = Math.min(state.basePos, state.overlayPos);\n\n      // state.overlay.combineTokens always takes precedence over combine,\n      // unless set to null\n      if (state.overlayCur == null) return state.baseCur;\n      else if (state.baseCur != null &&\n               state.overlay.combineTokens ||\n               combine && state.overlay.combineTokens == null)\n        return state.baseCur + \" \" + state.overlayCur;\n      else return state.overlayCur;\n    },\n\n    indent: base.indent && function(state, textAfter, line) {\n      return base.indent(state.base, textAfter, line);\n    },\n    electricChars: base.electricChars,\n\n    innerMode: function(state) { return {state: state.base, mode: base}; },\n\n    blankLine: function(state) {\n      var baseToken, overlayToken;\n      if (base.blankLine) baseToken = base.blankLine(state.base);\n      if (overlay.blankLine) overlayToken = overlay.blankLine(state.overlay);\n\n      return overlayToken == null ?\n        baseToken :\n        (combine && baseToken != null ? baseToken + \" \" + overlayToken : overlayToken);\n    }\n  };\n};\n\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n/**\n * Link to the project's GitHub page:\n * https://github.com/pickhardt/coffeescript-codemirror-mode\n */\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"coffeescript\", function(conf, parserConf) {\n  var ERRORCLASS = \"error\";\n\n  function wordRegexp(words) {\n    return new RegExp(\"^((\" + words.join(\")|(\") + \"))\\\\b\");\n  }\n\n  var operators = /^(?:->|=>|\\+[+=]?|-[\\-=]?|\\*[\\*=]?|\\/[\\/=]?|[=!]=|<[><]?=?|>>?=?|%=?|&=?|\\|=?|\\^=?|\\~|!|\\?|(or|and|\\|\\||&&|\\?)=)/;\n  var delimiters = /^(?:[()\\[\\]{},:`=;]|\\.\\.?\\.?)/;\n  var identifiers = /^[_A-Za-z$][_A-Za-z$0-9]*/;\n  var atProp = /^@[_A-Za-z$][_A-Za-z$0-9]*/;\n\n  var wordOperators = wordRegexp([\"and\", \"or\", \"not\",\n                                  \"is\", \"isnt\", \"in\",\n                                  \"instanceof\", \"typeof\"]);\n  var indentKeywords = [\"for\", \"while\", \"loop\", \"if\", \"unless\", \"else\",\n                        \"switch\", \"try\", \"catch\", \"finally\", \"class\"];\n  var commonKeywords = [\"break\", \"by\", \"continue\", \"debugger\", \"delete\",\n                        \"do\", \"in\", \"of\", \"new\", \"return\", \"then\",\n                        \"this\", \"@\", \"throw\", \"when\", \"until\", \"extends\"];\n\n  var keywords = wordRegexp(indentKeywords.concat(commonKeywords));\n\n  indentKeywords = wordRegexp(indentKeywords);\n\n\n  var stringPrefixes = /^('{3}|\\\"{3}|['\\\"])/;\n  var regexPrefixes = /^(\\/{3}|\\/)/;\n  var commonConstants = [\"Infinity\", \"NaN\", \"undefined\", \"null\", \"true\", \"false\", \"on\", \"off\", \"yes\", \"no\"];\n  var constants = wordRegexp(commonConstants);\n\n  // Tokenizers\n  function tokenBase(stream, state) {\n    // Handle scope changes\n    if (stream.sol()) {\n      if (state.scope.align === null) state.scope.align = false;\n      var scopeOffset = state.scope.offset;\n      if (stream.eatSpace()) {\n        var lineOffset = stream.indentation();\n        if (lineOffset > scopeOffset && state.scope.type == \"coffee\") {\n          return \"indent\";\n        } else if (lineOffset < scopeOffset) {\n          return \"dedent\";\n        }\n        return null;\n      } else {\n        if (scopeOffset > 0) {\n          dedent(stream, state);\n        }\n      }\n    }\n    if (stream.eatSpace()) {\n      return null;\n    }\n\n    var ch = stream.peek();\n\n    // Handle docco title comment (single line)\n    if (stream.match(\"####\")) {\n      stream.skipToEnd();\n      return \"comment\";\n    }\n\n    // Handle multi line comments\n    if (stream.match(\"###\")) {\n      state.tokenize = longComment;\n      return state.tokenize(stream, state);\n    }\n\n    // Single line comment\n    if (ch === \"#\") {\n      stream.skipToEnd();\n      return \"comment\";\n    }\n\n    // Handle number literals\n    if (stream.match(/^-?[0-9\\.]/, false)) {\n      var floatLiteral = false;\n      // Floats\n      if (stream.match(/^-?\\d*\\.\\d+(e[\\+\\-]?\\d+)?/i)) {\n        floatLiteral = true;\n      }\n      if (stream.match(/^-?\\d+\\.\\d*/)) {\n        floatLiteral = true;\n      }\n      if (stream.match(/^-?\\.\\d+/)) {\n        floatLiteral = true;\n      }\n\n      if (floatLiteral) {\n        // prevent from getting extra . on 1..\n        if (stream.peek() == \".\"){\n          stream.backUp(1);\n        }\n        return \"number\";\n      }\n      // Integers\n      var intLiteral = false;\n      // Hex\n      if (stream.match(/^-?0x[0-9a-f]+/i)) {\n        intLiteral = true;\n      }\n      // Decimal\n      if (stream.match(/^-?[1-9]\\d*(e[\\+\\-]?\\d+)?/)) {\n        intLiteral = true;\n      }\n      // Zero by itself with no other piece of number.\n      if (stream.match(/^-?0(?![\\dx])/i)) {\n        intLiteral = true;\n      }\n      if (intLiteral) {\n        return \"number\";\n      }\n    }\n\n    // Handle strings\n    if (stream.match(stringPrefixes)) {\n      state.tokenize = tokenFactory(stream.current(), false, \"string\");\n      return state.tokenize(stream, state);\n    }\n    // Handle regex literals\n    if (stream.match(regexPrefixes)) {\n      if (stream.current() != \"/\" || stream.match(/^.*\\//, false)) { // prevent highlight of division\n        state.tokenize = tokenFactory(stream.current(), true, \"string-2\");\n        return state.tokenize(stream, state);\n      } else {\n        stream.backUp(1);\n      }\n    }\n\n\n\n    // Handle operators and delimiters\n    if (stream.match(operators) || stream.match(wordOperators)) {\n      return \"operator\";\n    }\n    if (stream.match(delimiters)) {\n      return \"punctuation\";\n    }\n\n    if (stream.match(constants)) {\n      return \"atom\";\n    }\n\n    if (stream.match(atProp) || state.prop && stream.match(identifiers)) {\n      return \"property\";\n    }\n\n    if (stream.match(keywords)) {\n      return \"keyword\";\n    }\n\n    if (stream.match(identifiers)) {\n      return \"variable\";\n    }\n\n    // Handle non-detected items\n    stream.next();\n    return ERRORCLASS;\n  }\n\n  function tokenFactory(delimiter, singleline, outclass) {\n    return function(stream, state) {\n      while (!stream.eol()) {\n        stream.eatWhile(/[^'\"\\/\\\\]/);\n        if (stream.eat(\"\\\\\")) {\n          stream.next();\n          if (singleline && stream.eol()) {\n            return outclass;\n          }\n        } else if (stream.match(delimiter)) {\n          state.tokenize = tokenBase;\n          return outclass;\n        } else {\n          stream.eat(/['\"\\/]/);\n        }\n      }\n      if (singleline) {\n        if (parserConf.singleLineStringErrors) {\n          outclass = ERRORCLASS;\n        } else {\n          state.tokenize = tokenBase;\n        }\n      }\n      return outclass;\n    };\n  }\n\n  function longComment(stream, state) {\n    while (!stream.eol()) {\n      stream.eatWhile(/[^#]/);\n      if (stream.match(\"###\")) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      stream.eatWhile(\"#\");\n    }\n    return \"comment\";\n  }\n\n  function indent(stream, state, type) {\n    type = type || \"coffee\";\n    var offset = 0, align = false, alignOffset = null;\n    for (var scope = state.scope; scope; scope = scope.prev) {\n      if (scope.type === \"coffee\" || scope.type == \"}\") {\n        offset = scope.offset + conf.indentUnit;\n        break;\n      }\n    }\n    if (type !== \"coffee\") {\n      align = null;\n      alignOffset = stream.column() + stream.current().length;\n    } else if (state.scope.align) {\n      state.scope.align = false;\n    }\n    state.scope = {\n      offset: offset,\n      type: type,\n      prev: state.scope,\n      align: align,\n      alignOffset: alignOffset\n    };\n  }\n\n  function dedent(stream, state) {\n    if (!state.scope.prev) return;\n    if (state.scope.type === \"coffee\") {\n      var _indent = stream.indentation();\n      var matched = false;\n      for (var scope = state.scope; scope; scope = scope.prev) {\n        if (_indent === scope.offset) {\n          matched = true;\n          break;\n        }\n      }\n      if (!matched) {\n        return true;\n      }\n      while (state.scope.prev && state.scope.offset !== _indent) {\n        state.scope = state.scope.prev;\n      }\n      return false;\n    } else {\n      state.scope = state.scope.prev;\n      return false;\n    }\n  }\n\n  function tokenLexer(stream, state) {\n    var style = state.tokenize(stream, state);\n    var current = stream.current();\n\n    // Handle scope changes.\n    if (current === \"return\") {\n      state.dedent = true;\n    }\n    if (((current === \"->\" || current === \"=>\") && stream.eol())\n        || style === \"indent\") {\n      indent(stream, state);\n    }\n    var delimiter_index = \"[({\".indexOf(current);\n    if (delimiter_index !== -1) {\n      indent(stream, state, \"])}\".slice(delimiter_index, delimiter_index+1));\n    }\n    if (indentKeywords.exec(current)){\n      indent(stream, state);\n    }\n    if (current == \"then\"){\n      dedent(stream, state);\n    }\n\n\n    if (style === \"dedent\") {\n      if (dedent(stream, state)) {\n        return ERRORCLASS;\n      }\n    }\n    delimiter_index = \"])}\".indexOf(current);\n    if (delimiter_index !== -1) {\n      while (state.scope.type == \"coffee\" && state.scope.prev)\n        state.scope = state.scope.prev;\n      if (state.scope.type == current)\n        state.scope = state.scope.prev;\n    }\n    if (state.dedent && stream.eol()) {\n      if (state.scope.type == \"coffee\" && state.scope.prev)\n        state.scope = state.scope.prev;\n      state.dedent = false;\n    }\n\n    return style;\n  }\n\n  var external = {\n    startState: function(basecolumn) {\n      return {\n        tokenize: tokenBase,\n        scope: {offset:basecolumn || 0, type:\"coffee\", prev: null, align: false},\n        prop: false,\n        dedent: 0\n      };\n    },\n\n    token: function(stream, state) {\n      var fillAlign = state.scope.align === null && state.scope;\n      if (fillAlign && stream.sol()) fillAlign.align = false;\n\n      var style = tokenLexer(stream, state);\n      if (style && style != \"comment\") {\n        if (fillAlign) fillAlign.align = true;\n        state.prop = style == \"punctuation\" && stream.current() == \".\"\n      }\n\n      return style;\n    },\n\n    indent: function(state, text) {\n      if (state.tokenize != tokenBase) return 0;\n      var scope = state.scope;\n      var closer = text && \"])}\".indexOf(text.charAt(0)) > -1;\n      if (closer) while (scope.type == \"coffee\" && scope.prev) scope = scope.prev;\n      var closes = closer && scope.type === text.charAt(0);\n      if (scope.align)\n        return scope.alignOffset - (closes ? 1 : 0);\n      else\n        return (closes ? scope.prev : scope).offset;\n    },\n\n    lineComment: \"#\",\n    fold: \"indent\"\n  };\n  return external;\n});\n\n// IANA registered media type\n// https://www.iana.org/assignments/media-types/\nCodeMirror.defineMIME(\"application/vnd.coffeescript\", \"coffeescript\");\n\nCodeMirror.defineMIME(\"text/x-coffeescript\", \"coffeescript\");\nCodeMirror.defineMIME(\"text/coffeescript\", \"coffeescript\");\n\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"))\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod)\n  else // Plain browser env\n    mod(CodeMirror)\n})(function(CodeMirror) {\n  \"use strict\"\n  var Pos = CodeMirror.Pos\n\n  function regexpFlags(regexp) {\n    var flags = regexp.flags\n    return flags != null ? flags : (regexp.ignoreCase ? \"i\" : \"\")\n      + (regexp.global ? \"g\" : \"\")\n      + (regexp.multiline ? \"m\" : \"\")\n  }\n\n  function ensureFlags(regexp, flags) {\n    var current = regexpFlags(regexp), target = current\n    for (var i = 0; i < flags.length; i++) if (target.indexOf(flags.charAt(i)) == -1)\n      target += flags.charAt(i)\n    return current == target ? regexp : new RegExp(regexp.source, target)\n  }\n\n  function maybeMultiline(regexp) {\n    return /\\\\s|\\\\n|\\n|\\\\W|\\\\D|\\[\\^/.test(regexp.source)\n  }\n\n  function searchRegexpForward(doc, regexp, start) {\n    regexp = ensureFlags(regexp, \"g\")\n    for (var line = start.line, ch = start.ch, last = doc.lastLine(); line <= last; line++, ch = 0) {\n      regexp.lastIndex = ch\n      var string = doc.getLine(line), match = regexp.exec(string)\n      if (match)\n        return {from: Pos(line, match.index),\n                to: Pos(line, match.index + match[0].length),\n                match: match}\n    }\n  }\n\n  function searchRegexpForwardMultiline(doc, regexp, start) {\n    if (!maybeMultiline(regexp)) return searchRegexpForward(doc, regexp, start)\n\n    regexp = ensureFlags(regexp, \"gm\")\n    var string, chunk = 1\n    for (var line = start.line, last = doc.lastLine(); line <= last;) {\n      // This grows the search buffer in exponentially-sized chunks\n      // between matches, so that nearby matches are fast and don't\n      // require concatenating the whole document (in case we're\n      // searching for something that has tons of matches), but at the\n      // same time, the amount of retries is limited.\n      for (var i = 0; i < chunk; i++) {\n        if (line > last) break\n        var curLine = doc.getLine(line++)\n        string = string == null ? curLine : string + \"\\n\" + curLine\n      }\n      chunk = chunk * 2\n      regexp.lastIndex = start.ch\n      var match = regexp.exec(string)\n      if (match) {\n        var before = string.slice(0, match.index).split(\"\\n\"), inside = match[0].split(\"\\n\")\n        var startLine = start.line + before.length - 1, startCh = before[before.length - 1].length\n        return {from: Pos(startLine, startCh),\n                to: Pos(startLine + inside.length - 1,\n                        inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),\n                match: match}\n      }\n    }\n  }\n\n  function lastMatchIn(string, regexp) {\n    var cutOff = 0, match\n    for (;;) {\n      regexp.lastIndex = cutOff\n      var newMatch = regexp.exec(string)\n      if (!newMatch) return match\n      match = newMatch\n      cutOff = match.index + (match[0].length || 1)\n      if (cutOff == string.length) return match\n    }\n  }\n\n  function searchRegexpBackward(doc, regexp, start) {\n    regexp = ensureFlags(regexp, \"g\")\n    for (var line = start.line, ch = start.ch, first = doc.firstLine(); line >= first; line--, ch = -1) {\n      var string = doc.getLine(line)\n      if (ch > -1) string = string.slice(0, ch)\n      var match = lastMatchIn(string, regexp)\n      if (match)\n        return {from: Pos(line, match.index),\n                to: Pos(line, match.index + match[0].length),\n                match: match}\n    }\n  }\n\n  function searchRegexpBackwardMultiline(doc, regexp, start) {\n    regexp = ensureFlags(regexp, \"gm\")\n    var string, chunk = 1\n    for (var line = start.line, first = doc.firstLine(); line >= first;) {\n      for (var i = 0; i < chunk; i++) {\n        var curLine = doc.getLine(line--)\n        string = string == null ? curLine.slice(0, start.ch) : curLine + \"\\n\" + string\n      }\n      chunk *= 2\n\n      var match = lastMatchIn(string, regexp)\n      if (match) {\n        var before = string.slice(0, match.index).split(\"\\n\"), inside = match[0].split(\"\\n\")\n        var startLine = line + before.length, startCh = before[before.length - 1].length\n        return {from: Pos(startLine, startCh),\n                to: Pos(startLine + inside.length - 1,\n                        inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),\n                match: match}\n      }\n    }\n  }\n\n  var doFold, noFold\n  if (String.prototype.normalize) {\n    doFold = function(str) { return str.normalize(\"NFD\").toLowerCase() }\n    noFold = function(str) { return str.normalize(\"NFD\") }\n  } else {\n    doFold = function(str) { return str.toLowerCase() }\n    noFold = function(str) { return str }\n  }\n\n  // Maps a position in a case-folded line back to a position in the original line\n  // (compensating for codepoints increasing in number during folding)\n  function adjustPos(orig, folded, pos, foldFunc) {\n    if (orig.length == folded.length) return pos\n    for (var min = 0, max = pos + Math.max(0, orig.length - folded.length);;) {\n      if (min == max) return min\n      var mid = (min + max) >> 1\n      var len = foldFunc(orig.slice(0, mid)).length\n      if (len == pos) return mid\n      else if (len > pos) max = mid\n      else min = mid + 1\n    }\n  }\n\n  function searchStringForward(doc, query, start, caseFold) {\n    // Empty string would match anything and never progress, so we\n    // define it to match nothing instead.\n    if (!query.length) return null\n    var fold = caseFold ? doFold : noFold\n    var lines = fold(query).split(/\\r|\\n\\r?/)\n\n    search: for (var line = start.line, ch = start.ch, last = doc.lastLine() + 1 - lines.length; line <= last; line++, ch = 0) {\n      var orig = doc.getLine(line).slice(ch), string = fold(orig)\n      if (lines.length == 1) {\n        var found = string.indexOf(lines[0])\n        if (found == -1) continue search\n        var start = adjustPos(orig, string, found, fold) + ch\n        return {from: Pos(line, adjustPos(orig, string, found, fold) + ch),\n                to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold) + ch)}\n      } else {\n        var cutFrom = string.length - lines[0].length\n        if (string.slice(cutFrom) != lines[0]) continue search\n        for (var i = 1; i < lines.length - 1; i++)\n          if (fold(doc.getLine(line + i)) != lines[i]) continue search\n        var end = doc.getLine(line + lines.length - 1), endString = fold(end), lastLine = lines[lines.length - 1]\n        if (endString.slice(0, lastLine.length) != lastLine) continue search\n        return {from: Pos(line, adjustPos(orig, string, cutFrom, fold) + ch),\n                to: Pos(line + lines.length - 1, adjustPos(end, endString, lastLine.length, fold))}\n      }\n    }\n  }\n\n  function searchStringBackward(doc, query, start, caseFold) {\n    if (!query.length) return null\n    var fold = caseFold ? doFold : noFold\n    var lines = fold(query).split(/\\r|\\n\\r?/)\n\n    search: for (var line = start.line, ch = start.ch, first = doc.firstLine() - 1 + lines.length; line >= first; line--, ch = -1) {\n      var orig = doc.getLine(line)\n      if (ch > -1) orig = orig.slice(0, ch)\n      var string = fold(orig)\n      if (lines.length == 1) {\n        var found = string.lastIndexOf(lines[0])\n        if (found == -1) continue search\n        return {from: Pos(line, adjustPos(orig, string, found, fold)),\n                to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold))}\n      } else {\n        var lastLine = lines[lines.length - 1]\n        if (string.slice(0, lastLine.length) != lastLine) continue search\n        for (var i = 1, start = line - lines.length + 1; i < lines.length - 1; i++)\n          if (fold(doc.getLine(start + i)) != lines[i]) continue search\n        var top = doc.getLine(line + 1 - lines.length), topString = fold(top)\n        if (topString.slice(topString.length - lines[0].length) != lines[0]) continue search\n        return {from: Pos(line + 1 - lines.length, adjustPos(top, topString, top.length - lines[0].length, fold)),\n                to: Pos(line, adjustPos(orig, string, lastLine.length, fold))}\n      }\n    }\n  }\n\n  function SearchCursor(doc, query, pos, options) {\n    this.atOccurrence = false\n    this.doc = doc\n    pos = pos ? doc.clipPos(pos) : Pos(0, 0)\n    this.pos = {from: pos, to: pos}\n\n    var caseFold\n    if (typeof options == \"object\") {\n      caseFold = options.caseFold\n    } else { // Backwards compat for when caseFold was the 4th argument\n      caseFold = options\n      options = null\n    }\n\n    if (typeof query == \"string\") {\n      if (caseFold == null) caseFold = false\n      this.matches = function(reverse, pos) {\n        return (reverse ? searchStringBackward : searchStringForward)(doc, query, pos, caseFold)\n      }\n    } else {\n      query = ensureFlags(query, \"gm\")\n      if (!options || options.multiline !== false)\n        this.matches = function(reverse, pos) {\n          return (reverse ? searchRegexpBackwardMultiline : searchRegexpForwardMultiline)(doc, query, pos)\n        }\n      else\n        this.matches = function(reverse, pos) {\n          return (reverse ? searchRegexpBackward : searchRegexpForward)(doc, query, pos)\n        }\n    }\n  }\n\n  SearchCursor.prototype = {\n    findNext: function() {return this.find(false)},\n    findPrevious: function() {return this.find(true)},\n\n    find: function(reverse) {\n      var result = this.matches(reverse, this.doc.clipPos(reverse ? this.pos.from : this.pos.to))\n\n      // Implements weird auto-growing behavior on null-matches for\n      // backwards-compatiblity with the vim code (unfortunately)\n      while (result && CodeMirror.cmpPos(result.from, result.to) == 0) {\n        if (reverse) {\n          if (result.from.ch) result.from = Pos(result.from.line, result.from.ch - 1)\n          else if (result.from.line == this.doc.firstLine()) result = null\n          else result = this.matches(reverse, this.doc.clipPos(Pos(result.from.line - 1)))\n        } else {\n          if (result.to.ch < this.doc.getLine(result.to.line).length) result.to = Pos(result.to.line, result.to.ch + 1)\n          else if (result.to.line == this.doc.lastLine()) result = null\n          else result = this.matches(reverse, Pos(result.to.line + 1, 0))\n        }\n      }\n\n      if (result) {\n        this.pos = result\n        this.atOccurrence = true\n        return this.pos.match || true\n      } else {\n        var end = Pos(reverse ? this.doc.firstLine() : this.doc.lastLine() + 1, 0)\n        this.pos = {from: end, to: end}\n        return this.atOccurrence = false\n      }\n    },\n\n    from: function() {if (this.atOccurrence) return this.pos.from},\n    to: function() {if (this.atOccurrence) return this.pos.to},\n\n    replace: function(newText, origin) {\n      if (!this.atOccurrence) return\n      var lines = CodeMirror.splitLines(newText)\n      this.doc.replaceRange(lines, this.pos.from, this.pos.to, origin)\n      this.pos.to = Pos(this.pos.from.line + lines.length - 1,\n                        lines[lines.length - 1].length + (lines.length == 1 ? this.pos.from.ch : 0))\n    }\n  }\n\n  CodeMirror.defineExtension(\"getSearchCursor\", function(query, pos, caseFold) {\n    return new SearchCursor(this.doc, query, pos, caseFold)\n  })\n  CodeMirror.defineDocExtension(\"getSearchCursor\", function(query, pos, caseFold) {\n    return new SearchCursor(this, query, pos, caseFold)\n  })\n\n  CodeMirror.defineExtension(\"selectMatches\", function(query, caseFold) {\n    var ranges = []\n    var cur = this.getSearchCursor(query, this.getCursor(\"from\"), caseFold)\n    while (cur.findNext()) {\n      if (CodeMirror.cmpPos(cur.to(), this.getCursor(\"to\")) > 0) break\n      ranges.push({anchor: cur.from(), head: cur.to()})\n    }\n    if (ranges.length)\n      this.setSelections(ranges, 0)\n  })\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nvar htmlConfig = {\n  autoSelfClosers: {'area': true, 'base': true, 'br': true, 'col': true, 'command': true,\n                    'embed': true, 'frame': true, 'hr': true, 'img': true, 'input': true,\n                    'keygen': true, 'link': true, 'meta': true, 'param': true, 'source': true,\n                    'track': true, 'wbr': true, 'menuitem': true},\n  implicitlyClosed: {'dd': true, 'li': true, 'optgroup': true, 'option': true, 'p': true,\n                     'rp': true, 'rt': true, 'tbody': true, 'td': true, 'tfoot': true,\n                     'th': true, 'tr': true},\n  contextGrabbers: {\n    'dd': {'dd': true, 'dt': true},\n    'dt': {'dd': true, 'dt': true},\n    'li': {'li': true},\n    'option': {'option': true, 'optgroup': true},\n    'optgroup': {'optgroup': true},\n    'p': {'address': true, 'article': true, 'aside': true, 'blockquote': true, 'dir': true,\n          'div': true, 'dl': true, 'fieldset': true, 'footer': true, 'form': true,\n          'h1': true, 'h2': true, 'h3': true, 'h4': true, 'h5': true, 'h6': true,\n          'header': true, 'hgroup': true, 'hr': true, 'menu': true, 'nav': true, 'ol': true,\n          'p': true, 'pre': true, 'section': true, 'table': true, 'ul': true},\n    'rp': {'rp': true, 'rt': true},\n    'rt': {'rp': true, 'rt': true},\n    'tbody': {'tbody': true, 'tfoot': true},\n    'td': {'td': true, 'th': true},\n    'tfoot': {'tbody': true},\n    'th': {'td': true, 'th': true},\n    'thead': {'tbody': true, 'tfoot': true},\n    'tr': {'tr': true}\n  },\n  doNotIndent: {\"pre\": true},\n  allowUnquoted: true,\n  allowMissing: true,\n  caseFold: true\n}\n\nvar xmlConfig = {\n  autoSelfClosers: {},\n  implicitlyClosed: {},\n  contextGrabbers: {},\n  doNotIndent: {},\n  allowUnquoted: false,\n  allowMissing: false,\n  allowMissingTagName: false,\n  caseFold: false\n}\n\nCodeMirror.defineMode(\"xml\", function(editorConf, config_) {\n  var indentUnit = editorConf.indentUnit\n  var config = {}\n  var defaults = config_.htmlMode ? htmlConfig : xmlConfig\n  for (var prop in defaults) config[prop] = defaults[prop]\n  for (var prop in config_) config[prop] = config_[prop]\n\n  // Return variables for tokenizers\n  var type, setStyle;\n\n  function inText(stream, state) {\n    function chain(parser) {\n      state.tokenize = parser;\n      return parser(stream, state);\n    }\n\n    var ch = stream.next();\n    if (ch == \"<\") {\n      if (stream.eat(\"!\")) {\n        if (stream.eat(\"[\")) {\n          if (stream.match(\"CDATA[\")) return chain(inBlock(\"atom\", \"]]>\"));\n          else return null;\n        } else if (stream.match(\"--\")) {\n          return chain(inBlock(\"comment\", \"-->\"));\n        } else if (stream.match(\"DOCTYPE\", true, true)) {\n          stream.eatWhile(/[\\w\\._\\-]/);\n          return chain(doctype(1));\n        } else {\n          return null;\n        }\n      } else if (stream.eat(\"?\")) {\n        stream.eatWhile(/[\\w\\._\\-]/);\n        state.tokenize = inBlock(\"meta\", \"?>\");\n        return \"meta\";\n      } else {\n        type = stream.eat(\"/\") ? \"closeTag\" : \"openTag\";\n        state.tokenize = inTag;\n        return \"tag bracket\";\n      }\n    } else if (ch == \"&\") {\n      var ok;\n      if (stream.eat(\"#\")) {\n        if (stream.eat(\"x\")) {\n          ok = stream.eatWhile(/[a-fA-F\\d]/) && stream.eat(\";\");\n        } else {\n          ok = stream.eatWhile(/[\\d]/) && stream.eat(\";\");\n        }\n      } else {\n        ok = stream.eatWhile(/[\\w\\.\\-:]/) && stream.eat(\";\");\n      }\n      return ok ? \"atom\" : \"error\";\n    } else {\n      stream.eatWhile(/[^&<]/);\n      return null;\n    }\n  }\n  inText.isInText = true;\n\n  function inTag(stream, state) {\n    var ch = stream.next();\n    if (ch == \">\" || (ch == \"/\" && stream.eat(\">\"))) {\n      state.tokenize = inText;\n      type = ch == \">\" ? \"endTag\" : \"selfcloseTag\";\n      return \"tag bracket\";\n    } else if (ch == \"=\") {\n      type = \"equals\";\n      return null;\n    } else if (ch == \"<\") {\n      state.tokenize = inText;\n      state.state = baseState;\n      state.tagName = state.tagStart = null;\n      var next = state.tokenize(stream, state);\n      return next ? next + \" tag error\" : \"tag error\";\n    } else if (/[\\'\\\"]/.test(ch)) {\n      state.tokenize = inAttribute(ch);\n      state.stringStartCol = stream.column();\n      return state.tokenize(stream, state);\n    } else {\n      stream.match(/^[^\\s\\u00a0=<>\\\"\\']*[^\\s\\u00a0=<>\\\"\\'\\/]/);\n      return \"word\";\n    }\n  }\n\n  function inAttribute(quote) {\n    var closure = function(stream, state) {\n      while (!stream.eol()) {\n        if (stream.next() == quote) {\n          state.tokenize = inTag;\n          break;\n        }\n      }\n      return \"string\";\n    };\n    closure.isInAttribute = true;\n    return closure;\n  }\n\n  function inBlock(style, terminator) {\n    return function(stream, state) {\n      while (!stream.eol()) {\n        if (stream.match(terminator)) {\n          state.tokenize = inText;\n          break;\n        }\n        stream.next();\n      }\n      return style;\n    }\n  }\n\n  function doctype(depth) {\n    return function(stream, state) {\n      var ch;\n      while ((ch = stream.next()) != null) {\n        if (ch == \"<\") {\n          state.tokenize = doctype(depth + 1);\n          return state.tokenize(stream, state);\n        } else if (ch == \">\") {\n          if (depth == 1) {\n            state.tokenize = inText;\n            break;\n          } else {\n            state.tokenize = doctype(depth - 1);\n            return state.tokenize(stream, state);\n          }\n        }\n      }\n      return \"meta\";\n    };\n  }\n\n  function Context(state, tagName, startOfLine) {\n    this.prev = state.context;\n    this.tagName = tagName;\n    this.indent = state.indented;\n    this.startOfLine = startOfLine;\n    if (config.doNotIndent.hasOwnProperty(tagName) || (state.context && state.context.noIndent))\n      this.noIndent = true;\n  }\n  function popContext(state) {\n    if (state.context) state.context = state.context.prev;\n  }\n  function maybePopContext(state, nextTagName) {\n    var parentTagName;\n    while (true) {\n      if (!state.context) {\n        return;\n      }\n      parentTagName = state.context.tagName;\n      if (!config.contextGrabbers.hasOwnProperty(parentTagName) ||\n          !config.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {\n        return;\n      }\n      popContext(state);\n    }\n  }\n\n  function baseState(type, stream, state) {\n    if (type == \"openTag\") {\n      state.tagStart = stream.column();\n      return tagNameState;\n    } else if (type == \"closeTag\") {\n      return closeTagNameState;\n    } else {\n      return baseState;\n    }\n  }\n  function tagNameState(type, stream, state) {\n    if (type == \"word\") {\n      state.tagName = stream.current();\n      setStyle = \"tag\";\n      return attrState;\n    } else if (config.allowMissingTagName && type == \"endTag\") {\n      setStyle = \"tag bracket\";\n      return attrState(type, stream, state);\n    } else {\n      setStyle = \"error\";\n      return tagNameState;\n    }\n  }\n  function closeTagNameState(type, stream, state) {\n    if (type == \"word\") {\n      var tagName = stream.current();\n      if (state.context && state.context.tagName != tagName &&\n          config.implicitlyClosed.hasOwnProperty(state.context.tagName))\n        popContext(state);\n      if ((state.context && state.context.tagName == tagName) || config.matchClosing === false) {\n        setStyle = \"tag\";\n        return closeState;\n      } else {\n        setStyle = \"tag error\";\n        return closeStateErr;\n      }\n    } else if (config.allowMissingTagName && type == \"endTag\") {\n      setStyle = \"tag bracket\";\n      return closeState(type, stream, state);\n    } else {\n      setStyle = \"error\";\n      return closeStateErr;\n    }\n  }\n\n  function closeState(type, _stream, state) {\n    if (type != \"endTag\") {\n      setStyle = \"error\";\n      return closeState;\n    }\n    popContext(state);\n    return baseState;\n  }\n  function closeStateErr(type, stream, state) {\n    setStyle = \"error\";\n    return closeState(type, stream, state);\n  }\n\n  function attrState(type, _stream, state) {\n    if (type == \"word\") {\n      setStyle = \"attribute\";\n      return attrEqState;\n    } else if (type == \"endTag\" || type == \"selfcloseTag\") {\n      var tagName = state.tagName, tagStart = state.tagStart;\n      state.tagName = state.tagStart = null;\n      if (type == \"selfcloseTag\" ||\n          config.autoSelfClosers.hasOwnProperty(tagName)) {\n        maybePopContext(state, tagName);\n      } else {\n        maybePopContext(state, tagName);\n        state.context = new Context(state, tagName, tagStart == state.indented);\n      }\n      return baseState;\n    }\n    setStyle = \"error\";\n    return attrState;\n  }\n  function attrEqState(type, stream, state) {\n    if (type == \"equals\") return attrValueState;\n    if (!config.allowMissing) setStyle = \"error\";\n    return attrState(type, stream, state);\n  }\n  function attrValueState(type, stream, state) {\n    if (type == \"string\") return attrContinuedState;\n    if (type == \"word\" && config.allowUnquoted) {setStyle = \"string\"; return attrState;}\n    setStyle = \"error\";\n    return attrState(type, stream, state);\n  }\n  function attrContinuedState(type, stream, state) {\n    if (type == \"string\") return attrContinuedState;\n    return attrState(type, stream, state);\n  }\n\n  return {\n    startState: function(baseIndent) {\n      var state = {tokenize: inText,\n                   state: baseState,\n                   indented: baseIndent || 0,\n                   tagName: null, tagStart: null,\n                   context: null}\n      if (baseIndent != null) state.baseIndent = baseIndent\n      return state\n    },\n\n    token: function(stream, state) {\n      if (!state.tagName && stream.sol())\n        state.indented = stream.indentation();\n\n      if (stream.eatSpace()) return null;\n      type = null;\n      var style = state.tokenize(stream, state);\n      if ((style || type) && style != \"comment\") {\n        setStyle = null;\n        state.state = state.state(type || style, stream, state);\n        if (setStyle)\n          style = setStyle == \"error\" ? style + \" error\" : setStyle;\n      }\n      return style;\n    },\n\n    indent: function(state, textAfter, fullLine) {\n      var context = state.context;\n      // Indent multi-line strings (e.g. css).\n      if (state.tokenize.isInAttribute) {\n        if (state.tagStart == state.indented)\n          return state.stringStartCol + 1;\n        else\n          return state.indented + indentUnit;\n      }\n      if (context && context.noIndent) return CodeMirror.Pass;\n      if (state.tokenize != inTag && state.tokenize != inText)\n        return fullLine ? fullLine.match(/^(\\s*)/)[0].length : 0;\n      // Indent the starts of attribute names.\n      if (state.tagName) {\n        if (config.multilineTagIndentPastTag !== false)\n          return state.tagStart + state.tagName.length + 2;\n        else\n          return state.tagStart + indentUnit * (config.multilineTagIndentFactor || 1);\n      }\n      if (config.alignCDATA && /<!\\[CDATA\\[/.test(textAfter)) return 0;\n      var tagAfter = textAfter && /^<(\\/)?([\\w_:\\.-]*)/.exec(textAfter);\n      if (tagAfter && tagAfter[1]) { // Closing tag spotted\n        while (context) {\n          if (context.tagName == tagAfter[2]) {\n            context = context.prev;\n            break;\n          } else if (config.implicitlyClosed.hasOwnProperty(context.tagName)) {\n            context = context.prev;\n          } else {\n            break;\n          }\n        }\n      } else if (tagAfter) { // Opening tag spotted\n        while (context) {\n          var grabbers = config.contextGrabbers[context.tagName];\n          if (grabbers && grabbers.hasOwnProperty(tagAfter[2]))\n            context = context.prev;\n          else\n            break;\n        }\n      }\n      while (context && context.prev && !context.startOfLine)\n        context = context.prev;\n      if (context) return context.indent + indentUnit;\n      else return state.baseIndent || 0;\n    },\n\n    electricInput: /<\\/[\\s\\w:]+>$/,\n    blockCommentStart: \"<!--\",\n    blockCommentEnd: \"-->\",\n\n    configuration: config.htmlMode ? \"html\" : \"xml\",\n    helperType: config.htmlMode ? \"html\" : \"xml\",\n\n    skipAttribute: function(state) {\n      if (state.state == attrValueState)\n        state.state = attrState\n    }\n  };\n});\n\nCodeMirror.defineMIME(\"text/xml\", \"xml\");\nCodeMirror.defineMIME(\"application/xml\", \"xml\");\nif (!CodeMirror.mimeModes.hasOwnProperty(\"text/html\"))\n  CodeMirror.defineMIME(\"text/html\", {name: \"xml\", htmlMode: true});\n\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"../xml/xml\"), require(\"../javascript/javascript\"), require(\"../css/css\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"../xml/xml\", \"../javascript/javascript\", \"../css/css\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var defaultTags = {\n    script: [\n      [\"lang\", /(javascript|babel)/i, \"javascript\"],\n      [\"type\", /^(?:text|application)\\/(?:x-)?(?:java|ecma)script$|^module$|^$/i, \"javascript\"],\n      [\"type\", /./, \"text/plain\"],\n      [null, null, \"javascript\"]\n    ],\n    style:  [\n      [\"lang\", /^css$/i, \"css\"],\n      [\"type\", /^(text\\/)?(x-)?(stylesheet|css)$/i, \"css\"],\n      [\"type\", /./, \"text/plain\"],\n      [null, null, \"css\"]\n    ]\n  };\n\n  function maybeBackup(stream, pat, style) {\n    var cur = stream.current(), close = cur.search(pat);\n    if (close > -1) {\n      stream.backUp(cur.length - close);\n    } else if (cur.match(/<\\/?$/)) {\n      stream.backUp(cur.length);\n      if (!stream.match(pat, false)) stream.match(cur);\n    }\n    return style;\n  }\n\n  var attrRegexpCache = {};\n  function getAttrRegexp(attr) {\n    var regexp = attrRegexpCache[attr];\n    if (regexp) return regexp;\n    return attrRegexpCache[attr] = new RegExp(\"\\\\s+\" + attr + \"\\\\s*=\\\\s*('|\\\")?([^'\\\"]+)('|\\\")?\\\\s*\");\n  }\n\n  function getAttrValue(text, attr) {\n    var match = text.match(getAttrRegexp(attr))\n    return match ? /^\\s*(.*?)\\s*$/.exec(match[2])[1] : \"\"\n  }\n\n  function getTagRegexp(tagName, anchored) {\n    return new RegExp((anchored ? \"^\" : \"\") + \"<\\/\\s*\" + tagName + \"\\s*>\", \"i\");\n  }\n\n  function addTags(from, to) {\n    for (var tag in from) {\n      var dest = to[tag] || (to[tag] = []);\n      var source = from[tag];\n      for (var i = source.length - 1; i >= 0; i--)\n        dest.unshift(source[i])\n    }\n  }\n\n  function findMatchingMode(tagInfo, tagText) {\n    for (var i = 0; i < tagInfo.length; i++) {\n      var spec = tagInfo[i];\n      if (!spec[0] || spec[1].test(getAttrValue(tagText, spec[0]))) return spec[2];\n    }\n  }\n\n  CodeMirror.defineMode(\"htmlmixed\", function (config, parserConfig) {\n    var htmlMode = CodeMirror.getMode(config, {\n      name: \"xml\",\n      htmlMode: true,\n      multilineTagIndentFactor: parserConfig.multilineTagIndentFactor,\n      multilineTagIndentPastTag: parserConfig.multilineTagIndentPastTag\n    });\n\n    var tags = {};\n    var configTags = parserConfig && parserConfig.tags, configScript = parserConfig && parserConfig.scriptTypes;\n    addTags(defaultTags, tags);\n    if (configTags) addTags(configTags, tags);\n    if (configScript) for (var i = configScript.length - 1; i >= 0; i--)\n      tags.script.unshift([\"type\", configScript[i].matches, configScript[i].mode])\n\n    function html(stream, state) {\n      var style = htmlMode.token(stream, state.htmlState), tag = /\\btag\\b/.test(style), tagName\n      if (tag && !/[<>\\s\\/]/.test(stream.current()) &&\n          (tagName = state.htmlState.tagName && state.htmlState.tagName.toLowerCase()) &&\n          tags.hasOwnProperty(tagName)) {\n        state.inTag = tagName + \" \"\n      } else if (state.inTag && tag && />$/.test(stream.current())) {\n        var inTag = /^([\\S]+) (.*)/.exec(state.inTag)\n        state.inTag = null\n        var modeSpec = stream.current() == \">\" && findMatchingMode(tags[inTag[1]], inTag[2])\n        var mode = CodeMirror.getMode(config, modeSpec)\n        var endTagA = getTagRegexp(inTag[1], true), endTag = getTagRegexp(inTag[1], false);\n        state.token = function (stream, state) {\n          if (stream.match(endTagA, false)) {\n            state.token = html;\n            state.localState = state.localMode = null;\n            return null;\n          }\n          return maybeBackup(stream, endTag, state.localMode.token(stream, state.localState));\n        };\n        state.localMode = mode;\n        state.localState = CodeMirror.startState(mode, htmlMode.indent(state.htmlState, \"\", \"\"));\n      } else if (state.inTag) {\n        state.inTag += stream.current()\n        if (stream.eol()) state.inTag += \" \"\n      }\n      return style;\n    };\n\n    return {\n      startState: function () {\n        var state = CodeMirror.startState(htmlMode);\n        return {token: html, inTag: null, localMode: null, localState: null, htmlState: state};\n      },\n\n      copyState: function (state) {\n        var local;\n        if (state.localState) {\n          local = CodeMirror.copyState(state.localMode, state.localState);\n        }\n        return {token: state.token, inTag: state.inTag,\n                localMode: state.localMode, localState: local,\n                htmlState: CodeMirror.copyState(htmlMode, state.htmlState)};\n      },\n\n      token: function (stream, state) {\n        return state.token(stream, state);\n      },\n\n      indent: function (state, textAfter, line) {\n        if (!state.localMode || /^\\s*<\\//.test(textAfter))\n          return htmlMode.indent(state.htmlState, textAfter, line);\n        else if (state.localMode.indent)\n          return state.localMode.indent(state.localState, textAfter, line);\n        else\n          return CodeMirror.Pass;\n      },\n\n      innerMode: function (state) {\n        return {state: state.localState || state.htmlState, mode: state.localMode || htmlMode};\n      }\n    };\n  }, \"xml\", \"javascript\", \"css\");\n\n  CodeMirror.defineMIME(\"text/html\", \"htmlmixed\");\n});\n","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"interface-code\"},[_c('codemirror',{ref:\"codemirrorEl\",attrs:{\"options\":_vm.altOptions ? _vm.altOptions : _vm.cmOptions,\"value\":_vm.stringValue},on:{\"input\":_vm.onInput}}),(_vm.options.template)?_c('button',{directives:[{name:\"tooltip\",rawName:\"v-tooltip\",value:(_vm.$t('interfaces-code-fill_template')),expression:\"$t('interfaces-code-fill_template')\"}],on:{\"click\":_vm.fillTemplate}},[_c('v-icon',{attrs:{\"name\":\"playlist_add\"}})],1):_vm._e(),(_vm.language)?_c('small',{staticClass:\"line-count\"},[_vm._v(\"\\n    \"+_vm._s(_vm.$tc(\"interfaces-code-loc\", _vm.lineCount, {\n        count: _vm.lineCount,\n        lang: _vm.language\n      }))+\"\\n  \")]):_vm._e()],1)}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","<template>\n  <div class=\"interface-code\">\n    <codemirror\n      ref=\"codemirrorEl\"\n      :options=\"altOptions ? altOptions : cmOptions\"\n      :value=\"stringValue\"\n      @input=\"onInput\"\n    ></codemirror>\n\n    <button\n      v-if=\"options.template\"\n      v-tooltip=\"$t('interfaces-code-fill_template')\"\n      @click=\"fillTemplate\"\n    >\n      <v-icon name=\"playlist_add\" />\n    </button>\n\n    <small class=\"line-count\" v-if=\"language\">\n      {{\n        $tc(\"interfaces-code-loc\", lineCount, {\n          count: lineCount,\n          lang: language\n        })\n      }}\n    </small>\n  </div>\n</template>\n\n<script>\nimport { codemirror } from \"vue-codemirror\";\n\nimport \"codemirror/lib/codemirror.css\";\n\nimport \"codemirror/mode/vue/vue.js\";\nimport \"codemirror/mode/javascript/javascript.js\";\nimport \"codemirror/mode/php/php.js\";\n\nimport \"codemirror/addon/selection/active-line.js\";\nimport \"codemirror/addon/selection/mark-selection.js\";\nimport \"codemirror/addon/search/searchcursor.js\";\nimport \"codemirror/addon/hint/show-hint.js\";\nimport \"codemirror/addon/hint/show-hint.css\";\nimport \"codemirror/addon/hint/javascript-hint.js\";\nimport \"codemirror/addon/selection/active-line.js\";\nimport \"codemirror/addon/scroll/annotatescrollbar.js\";\nimport \"codemirror/addon/search/matchesonscrollbar.js\";\nimport \"codemirror/addon/search/searchcursor.js\";\nimport \"codemirror/addon/search/match-highlighter.js\";\nimport \"codemirror/addon/edit/matchbrackets.js\";\nimport \"codemirror/addon/comment/comment.js\";\nimport \"codemirror/addon/dialog/dialog.js\";\nimport \"codemirror/addon/dialog/dialog.css\";\nimport \"codemirror/addon/search/searchcursor.js\";\nimport \"codemirror/addon/search/search.js\";\n\nimport \"codemirror/addon/display/autorefresh.js\";\n\nimport \"codemirror/keymap/sublime.js\";\n\nimport \"./code.css\";\n\nimport mixin from \"@directus/extension-toolkit/mixins/interface\";\n\nexport default {\n  name: \"interface-code\",\n  mixins: [mixin],\n  components: {\n    codemirror\n  },\n  props: {\n    altOptions: {\n      type: Object\n    }\n  },\n  data() {\n    return {\n      lineCount: 0,\n\n      cmOptions: {\n        tabSize: 4,\n        autoRefresh: true,\n        indentUnit: 4,\n        styleActiveLine: true,\n        lineNumbers: this.options.lineNumber,\n        readOnly: this.readonly ? \"nocursor\" : false,\n        styleSelectedText: true,\n        line: true,\n        highlightSelectionMatches: { showToken: /\\w/, annotateScrollbar: true },\n        mode: this.mode,\n        hintOptions: {\n          completeSingle: true\n        },\n        matchBrackets: true,\n        showCursorWhenSelecting: true,\n        theme: \"default\",\n        extraKeys: { Ctrl: \"autocomplete\" }\n      }\n    };\n  },\n  mounted() {\n    const { codemirror } = this.$refs.codemirrorEl;\n    this.lineCount = codemirror.lineCount();\n  },\n  watch: {\n    options(newVal, oldVal) {\n      if (newVal.language !== oldVal.language) {\n        this.$set(this.cmOptions, \"mode\", newVal.language);\n      }\n\n      if (newVal.lineNumber !== oldVal.lineNumber) {\n        this.$set(this.cmOptions, \"lineNumbers\", newVal.lineNumber);\n      }\n    }\n  },\n  computed: {\n    availableTypes() {\n      return {\n        \"text/plain\": \"Plain Text\",\n        \"text/javascript\": \"JavaScript\",\n        \"application/json\": \"JSON\",\n        \"text/x-vue\": \"Vue\",\n        \"application/x-httpd-php\": \"PHP\"\n      };\n    },\n    language() {\n      return this.availableTypes[this.options.language];\n    },\n    stringValue() {\n      if (this.value == null) return null;\n\n      if (typeof this.value === \"object\") {\n        return JSON.stringify(this.value, null, 4);\n      }\n\n      return this.value;\n    },\n    mode() {\n      // There is no dedicated mode for JSON in codemirror. Switch to JS mode when JSON is selected\n      return this.options.language === \"application/json\"\n        ? \"text/javascript\"\n        : this.options.language;\n    }\n  },\n  methods: {\n    onInput(value) {\n      const { codemirror } = this.$refs.codemirrorEl;\n\n      if (this.lineCount !== codemirror.lineCount()) {\n        this.lineCount = codemirror.lineCount();\n      }\n\n      if (this.options.language === \"application/json\") {\n        try {\n          this.$emit(\"input\", JSON.parse(value));\n        } catch (e) {\n          // silently ignore saving value if it's not valid json\n        }\n      } else {\n        this.$emit(\"input\", value);\n      }\n    },\n    fillTemplate() {\n      if (\n        this.$lodash.isObject(this.options.template) ||\n        this.$lodash.isArray(this.options.template)\n      ) {\n        return this.$emit(\"input\", JSON.stringify(this.options.template, null, 4));\n      }\n\n      if (this.options.language === \"application/json\") {\n        try {\n          this.$emit(\"input\", JSON.parse(this.options.template));\n        } catch (e) {\n          // silently ignore saving value if it's not valid json\n        }\n      } else {\n        this.$emit(\"input\", this.options.template);\n      }\n    }\n  }\n};\n</script>\n\n<style lang=\"scss\" scoped>\n.interface-code {\n  position: relative;\n  width: 100%;\n  max-width: var(--width-x-large);\n  font-size: 13px;\n\n  &:focus {\n    border-color: var(--darker-gray);\n  }\n}\n\nsmall {\n  position: absolute;\n  right: 0;\n  bottom: -20px;\n  font-style: italic;\n  text-align: right;\n  color: var(--light-gray);\n}\n\nbutton {\n  position: absolute;\n  top: 10px;\n  right: 10px;\n  user-select: none;\n  color: var(--light-gray);\n  cursor: pointer;\n  transition: color var(--fast) var(--transition-out);\n  z-index: 10;\n\n  &:hover {\n    transition: none;\n    color: var(--dark-gray);\n  }\n}\n</style>\n","import mod from \"-!../../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js!../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./input.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js!../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./input.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./input.vue?vue&type=template&id=2d72df86&scoped=true&\"\nimport script from \"./input.vue?vue&type=script&lang=js&\"\nexport * from \"./input.vue?vue&type=script&lang=js&\"\nimport style0 from \"./input.vue?vue&type=style&index=0&id=2d72df86&lang=scss&scoped=true&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"2d72df86\",\n  null\n  \n)\n\nexport default component.exports","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"../../addon/mode/simple\"), require(\"../../addon/mode/multiplex\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"../../addon/mode/simple\", \"../../addon/mode/multiplex\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineSimpleMode(\"handlebars-tags\", {\n    start: [\n      { regex: /\\{\\{!--/, push: \"dash_comment\", token: \"comment\" },\n      { regex: /\\{\\{!/,   push: \"comment\", token: \"comment\" },\n      { regex: /\\{\\{/,    push: \"handlebars\", token: \"tag\" }\n    ],\n    handlebars: [\n      { regex: /\\}\\}/, pop: true, token: \"tag\" },\n\n      // Double and single quotes\n      { regex: /\"(?:[^\\\\\"]|\\\\.)*\"?/, token: \"string\" },\n      { regex: /'(?:[^\\\\']|\\\\.)*'?/, token: \"string\" },\n\n      // Handlebars keywords\n      { regex: />|[#\\/]([A-Za-z_]\\w*)/, token: \"keyword\" },\n      { regex: /(?:else|this)\\b/, token: \"keyword\" },\n\n      // Numeral\n      { regex: /\\d+/i, token: \"number\" },\n\n      // Atoms like = and .\n      { regex: /=|~|@|true|false/, token: \"atom\" },\n\n      // Paths\n      { regex: /(?:\\.\\.\\/)*(?:[A-Za-z_][\\w\\.]*)+/, token: \"variable-2\" }\n    ],\n    dash_comment: [\n      { regex: /--\\}\\}/, pop: true, token: \"comment\" },\n\n      // Commented code\n      { regex: /./, token: \"comment\"}\n    ],\n    comment: [\n      { regex: /\\}\\}/, pop: true, token: \"comment\" },\n      { regex: /./, token: \"comment\" }\n    ],\n    meta: {\n      blockCommentStart: \"{{--\",\n      blockCommentEnd: \"--}}\"\n    }\n  });\n\n  CodeMirror.defineMode(\"handlebars\", function(config, parserConfig) {\n    var handlebars = CodeMirror.getMode(config, \"handlebars-tags\");\n    if (!parserConfig || !parserConfig.base) return handlebars;\n    return CodeMirror.multiplexingMode(\n      CodeMirror.getMode(config, parserConfig.base),\n      {open: \"{{\", close: \"}}\", mode: handlebars, parseDelimiters: true}\n    );\n  });\n\n  CodeMirror.defineMIME(\"text/x-handlebars-template\", \"handlebars\");\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.multiplexingMode = function(outer /*, others */) {\n  // Others should be {open, close, mode [, delimStyle] [, innerStyle]} objects\n  var others = Array.prototype.slice.call(arguments, 1);\n\n  function indexOf(string, pattern, from, returnEnd) {\n    if (typeof pattern == \"string\") {\n      var found = string.indexOf(pattern, from);\n      return returnEnd && found > -1 ? found + pattern.length : found;\n    }\n    var m = pattern.exec(from ? string.slice(from) : string);\n    return m ? m.index + from + (returnEnd ? m[0].length : 0) : -1;\n  }\n\n  return {\n    startState: function() {\n      return {\n        outer: CodeMirror.startState(outer),\n        innerActive: null,\n        inner: null\n      };\n    },\n\n    copyState: function(state) {\n      return {\n        outer: CodeMirror.copyState(outer, state.outer),\n        innerActive: state.innerActive,\n        inner: state.innerActive && CodeMirror.copyState(state.innerActive.mode, state.inner)\n      };\n    },\n\n    token: function(stream, state) {\n      if (!state.innerActive) {\n        var cutOff = Infinity, oldContent = stream.string;\n        for (var i = 0; i < others.length; ++i) {\n          var other = others[i];\n          var found = indexOf(oldContent, other.open, stream.pos);\n          if (found == stream.pos) {\n            if (!other.parseDelimiters) stream.match(other.open);\n            state.innerActive = other;\n\n            // Get the outer indent, making sure to handle CodeMirror.Pass\n            var outerIndent = 0;\n            if (outer.indent) {\n              var possibleOuterIndent = outer.indent(state.outer, \"\", \"\");\n              if (possibleOuterIndent !== CodeMirror.Pass) outerIndent = possibleOuterIndent;\n            }\n\n            state.inner = CodeMirror.startState(other.mode, outerIndent);\n            return other.delimStyle && (other.delimStyle + \" \" + other.delimStyle + \"-open\");\n          } else if (found != -1 && found < cutOff) {\n            cutOff = found;\n          }\n        }\n        if (cutOff != Infinity) stream.string = oldContent.slice(0, cutOff);\n        var outerToken = outer.token(stream, state.outer);\n        if (cutOff != Infinity) stream.string = oldContent;\n        return outerToken;\n      } else {\n        var curInner = state.innerActive, oldContent = stream.string;\n        if (!curInner.close && stream.sol()) {\n          state.innerActive = state.inner = null;\n          return this.token(stream, state);\n        }\n        var found = curInner.close ? indexOf(oldContent, curInner.close, stream.pos, curInner.parseDelimiters) : -1;\n        if (found == stream.pos && !curInner.parseDelimiters) {\n          stream.match(curInner.close);\n          state.innerActive = state.inner = null;\n          return curInner.delimStyle && (curInner.delimStyle + \" \" + curInner.delimStyle + \"-close\");\n        }\n        if (found > -1) stream.string = oldContent.slice(0, found);\n        var innerToken = curInner.mode.token(stream, state.inner);\n        if (found > -1) stream.string = oldContent;\n\n        if (found == stream.pos && curInner.parseDelimiters)\n          state.innerActive = state.inner = null;\n\n        if (curInner.innerStyle) {\n          if (innerToken) innerToken = innerToken + \" \" + curInner.innerStyle;\n          else innerToken = curInner.innerStyle;\n        }\n\n        return innerToken;\n      }\n    },\n\n    indent: function(state, textAfter, line) {\n      var mode = state.innerActive ? state.innerActive.mode : outer;\n      if (!mode.indent) return CodeMirror.Pass;\n      return mode.indent(state.innerActive ? state.inner : state.outer, textAfter, line);\n    },\n\n    blankLine: function(state) {\n      var mode = state.innerActive ? state.innerActive.mode : outer;\n      if (mode.blankLine) {\n        mode.blankLine(state.innerActive ? state.inner : state.outer);\n      }\n      if (!state.innerActive) {\n        for (var i = 0; i < others.length; ++i) {\n          var other = others[i];\n          if (other.open === \"\\n\") {\n            state.innerActive = other;\n            state.inner = CodeMirror.startState(other.mode, mode.indent ? mode.indent(state.outer, \"\", \"\") : 0);\n          }\n        }\n      } else if (state.innerActive.close === \"\\n\") {\n        state.innerActive = state.inner = null;\n      }\n    },\n\n    electricChars: outer.electricChars,\n\n    innerMode: function(state) {\n      return state.inner ? {state: state.inner, mode: state.innerActive.mode} : {state: state.outer, mode: outer};\n    }\n  };\n};\n\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"))\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod)\n  else // Plain browser env\n    mod(CodeMirror)\n})(function(CodeMirror) {\n  \"use strict\"\n\n  CodeMirror.defineOption(\"autoRefresh\", false, function(cm, val) {\n    if (cm.state.autoRefresh) {\n      stopListening(cm, cm.state.autoRefresh)\n      cm.state.autoRefresh = null\n    }\n    if (val && cm.display.wrapper.offsetHeight == 0)\n      startListening(cm, cm.state.autoRefresh = {delay: val.delay || 250})\n  })\n\n  function startListening(cm, state) {\n    function check() {\n      if (cm.display.wrapper.offsetHeight) {\n        stopListening(cm, state)\n        if (cm.display.lastWrapHeight != cm.display.wrapper.clientHeight)\n          cm.refresh()\n      } else {\n        state.timeout = setTimeout(check, state.delay)\n      }\n    }\n    state.timeout = setTimeout(check, state.delay)\n    state.hurry = function() {\n      clearTimeout(state.timeout)\n      state.timeout = setTimeout(check, 50)\n    }\n    CodeMirror.on(window, \"mouseup\", state.hurry)\n    CodeMirror.on(window, \"keyup\", state.hurry)\n  }\n\n  function stopListening(_cm, state) {\n    clearTimeout(state.timeout)\n    CodeMirror.off(window, \"mouseup\", state.hurry)\n    CodeMirror.off(window, \"keyup\", state.hurry)\n  }\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"javascript\", function(config, parserConfig) {\n  var indentUnit = config.indentUnit;\n  var statementIndent = parserConfig.statementIndent;\n  var jsonldMode = parserConfig.jsonld;\n  var jsonMode = parserConfig.json || jsonldMode;\n  var isTS = parserConfig.typescript;\n  var wordRE = parserConfig.wordCharacters || /[\\w$\\xa1-\\uffff]/;\n\n  // Tokenizer\n\n  var keywords = function(){\n    function kw(type) {return {type: type, style: \"keyword\"};}\n    var A = kw(\"keyword a\"), B = kw(\"keyword b\"), C = kw(\"keyword c\"), D = kw(\"keyword d\");\n    var operator = kw(\"operator\"), atom = {type: \"atom\", style: \"atom\"};\n\n    return {\n      \"if\": kw(\"if\"), \"while\": A, \"with\": A, \"else\": B, \"do\": B, \"try\": B, \"finally\": B,\n      \"return\": D, \"break\": D, \"continue\": D, \"new\": kw(\"new\"), \"delete\": C, \"void\": C, \"throw\": C,\n      \"debugger\": kw(\"debugger\"), \"var\": kw(\"var\"), \"const\": kw(\"var\"), \"let\": kw(\"var\"),\n      \"function\": kw(\"function\"), \"catch\": kw(\"catch\"),\n      \"for\": kw(\"for\"), \"switch\": kw(\"switch\"), \"case\": kw(\"case\"), \"default\": kw(\"default\"),\n      \"in\": operator, \"typeof\": operator, \"instanceof\": operator,\n      \"true\": atom, \"false\": atom, \"null\": atom, \"undefined\": atom, \"NaN\": atom, \"Infinity\": atom,\n      \"this\": kw(\"this\"), \"class\": kw(\"class\"), \"super\": kw(\"atom\"),\n      \"yield\": C, \"export\": kw(\"export\"), \"import\": kw(\"import\"), \"extends\": C,\n      \"await\": C\n    };\n  }();\n\n  var isOperatorChar = /[+\\-*&%=<>!?|~^@]/;\n  var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)\"/;\n\n  function readRegexp(stream) {\n    var escaped = false, next, inSet = false;\n    while ((next = stream.next()) != null) {\n      if (!escaped) {\n        if (next == \"/\" && !inSet) return;\n        if (next == \"[\") inSet = true;\n        else if (inSet && next == \"]\") inSet = false;\n      }\n      escaped = !escaped && next == \"\\\\\";\n    }\n  }\n\n  // Used as scratch variables to communicate multiple values without\n  // consing up tons of objects.\n  var type, content;\n  function ret(tp, style, cont) {\n    type = tp; content = cont;\n    return style;\n  }\n  function tokenBase(stream, state) {\n    var ch = stream.next();\n    if (ch == '\"' || ch == \"'\") {\n      state.tokenize = tokenString(ch);\n      return state.tokenize(stream, state);\n    } else if (ch == \".\" && stream.match(/^\\d+(?:[eE][+\\-]?\\d+)?/)) {\n      return ret(\"number\", \"number\");\n    } else if (ch == \".\" && stream.match(\"..\")) {\n      return ret(\"spread\", \"meta\");\n    } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n      return ret(ch);\n    } else if (ch == \"=\" && stream.eat(\">\")) {\n      return ret(\"=>\", \"operator\");\n    } else if (ch == \"0\" && stream.match(/^(?:x[\\da-f]+|o[0-7]+|b[01]+)n?/i)) {\n      return ret(\"number\", \"number\");\n    } else if (/\\d/.test(ch)) {\n      stream.match(/^\\d*(?:n|(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?)?/);\n      return ret(\"number\", \"number\");\n    } else if (ch == \"/\") {\n      if (stream.eat(\"*\")) {\n        state.tokenize = tokenComment;\n        return tokenComment(stream, state);\n      } else if (stream.eat(\"/\")) {\n        stream.skipToEnd();\n        return ret(\"comment\", \"comment\");\n      } else if (expressionAllowed(stream, state, 1)) {\n        readRegexp(stream);\n        stream.match(/^\\b(([gimyus])(?![gimyus]*\\2))+\\b/);\n        return ret(\"regexp\", \"string-2\");\n      } else {\n        stream.eat(\"=\");\n        return ret(\"operator\", \"operator\", stream.current());\n      }\n    } else if (ch == \"`\") {\n      state.tokenize = tokenQuasi;\n      return tokenQuasi(stream, state);\n    } else if (ch == \"#\") {\n      stream.skipToEnd();\n      return ret(\"error\", \"error\");\n    } else if (isOperatorChar.test(ch)) {\n      if (ch != \">\" || !state.lexical || state.lexical.type != \">\") {\n        if (stream.eat(\"=\")) {\n          if (ch == \"!\" || ch == \"=\") stream.eat(\"=\")\n        } else if (/[<>*+\\-]/.test(ch)) {\n          stream.eat(ch)\n          if (ch == \">\") stream.eat(ch)\n        }\n      }\n      return ret(\"operator\", \"operator\", stream.current());\n    } else if (wordRE.test(ch)) {\n      stream.eatWhile(wordRE);\n      var word = stream.current()\n      if (state.lastType != \".\") {\n        if (keywords.propertyIsEnumerable(word)) {\n          var kw = keywords[word]\n          return ret(kw.type, kw.style, word)\n        }\n        if (word == \"async\" && stream.match(/^(\\s|\\/\\*.*?\\*\\/)*[\\[\\(\\w]/, false))\n          return ret(\"async\", \"keyword\", word)\n      }\n      return ret(\"variable\", \"variable\", word)\n    }\n  }\n\n  function tokenString(quote) {\n    return function(stream, state) {\n      var escaped = false, next;\n      if (jsonldMode && stream.peek() == \"@\" && stream.match(isJsonldKeyword)){\n        state.tokenize = tokenBase;\n        return ret(\"jsonld-keyword\", \"meta\");\n      }\n      while ((next = stream.next()) != null) {\n        if (next == quote && !escaped) break;\n        escaped = !escaped && next == \"\\\\\";\n      }\n      if (!escaped) state.tokenize = tokenBase;\n      return ret(\"string\", \"string\");\n    };\n  }\n\n  function tokenComment(stream, state) {\n    var maybeEnd = false, ch;\n    while (ch = stream.next()) {\n      if (ch == \"/\" && maybeEnd) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      maybeEnd = (ch == \"*\");\n    }\n    return ret(\"comment\", \"comment\");\n  }\n\n  function tokenQuasi(stream, state) {\n    var escaped = false, next;\n    while ((next = stream.next()) != null) {\n      if (!escaped && (next == \"`\" || next == \"$\" && stream.eat(\"{\"))) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      escaped = !escaped && next == \"\\\\\";\n    }\n    return ret(\"quasi\", \"string-2\", stream.current());\n  }\n\n  var brackets = \"([{}])\";\n  // This is a crude lookahead trick to try and notice that we're\n  // parsing the argument patterns for a fat-arrow function before we\n  // actually hit the arrow token. It only works if the arrow is on\n  // the same line as the arguments and there's no strange noise\n  // (comments) in between. Fallback is to only notice when we hit the\n  // arrow, and not declare the arguments as locals for the arrow\n  // body.\n  function findFatArrow(stream, state) {\n    if (state.fatArrowAt) state.fatArrowAt = null;\n    var arrow = stream.string.indexOf(\"=>\", stream.start);\n    if (arrow < 0) return;\n\n    if (isTS) { // Try to skip TypeScript return type declarations after the arguments\n      var m = /:\\s*(?:\\w+(?:<[^>]*>|\\[\\])?|\\{[^}]*\\})\\s*$/.exec(stream.string.slice(stream.start, arrow))\n      if (m) arrow = m.index\n    }\n\n    var depth = 0, sawSomething = false;\n    for (var pos = arrow - 1; pos >= 0; --pos) {\n      var ch = stream.string.charAt(pos);\n      var bracket = brackets.indexOf(ch);\n      if (bracket >= 0 && bracket < 3) {\n        if (!depth) { ++pos; break; }\n        if (--depth == 0) { if (ch == \"(\") sawSomething = true; break; }\n      } else if (bracket >= 3 && bracket < 6) {\n        ++depth;\n      } else if (wordRE.test(ch)) {\n        sawSomething = true;\n      } else if (/[\"'\\/]/.test(ch)) {\n        return;\n      } else if (sawSomething && !depth) {\n        ++pos;\n        break;\n      }\n    }\n    if (sawSomething && !depth) state.fatArrowAt = pos;\n  }\n\n  // Parser\n\n  var atomicTypes = {\"atom\": true, \"number\": true, \"variable\": true, \"string\": true, \"regexp\": true, \"this\": true, \"jsonld-keyword\": true};\n\n  function JSLexical(indented, column, type, align, prev, info) {\n    this.indented = indented;\n    this.column = column;\n    this.type = type;\n    this.prev = prev;\n    this.info = info;\n    if (align != null) this.align = align;\n  }\n\n  function inScope(state, varname) {\n    for (var v = state.localVars; v; v = v.next)\n      if (v.name == varname) return true;\n    for (var cx = state.context; cx; cx = cx.prev) {\n      for (var v = cx.vars; v; v = v.next)\n        if (v.name == varname) return true;\n    }\n  }\n\n  function parseJS(state, style, type, content, stream) {\n    var cc = state.cc;\n    // Communicate our context to the combinators.\n    // (Less wasteful than consing up a hundred closures on every call.)\n    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc; cx.style = style;\n\n    if (!state.lexical.hasOwnProperty(\"align\"))\n      state.lexical.align = true;\n\n    while(true) {\n      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;\n      if (combinator(type, content)) {\n        while(cc.length && cc[cc.length - 1].lex)\n          cc.pop()();\n        if (cx.marked) return cx.marked;\n        if (type == \"variable\" && inScope(state, content)) return \"variable-2\";\n        return style;\n      }\n    }\n  }\n\n  // Combinator utils\n\n  var cx = {state: null, column: null, marked: null, cc: null};\n  function pass() {\n    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);\n  }\n  function cont() {\n    pass.apply(null, arguments);\n    return true;\n  }\n  function inList(name, list) {\n    for (var v = list; v; v = v.next) if (v.name == name) return true\n    return false;\n  }\n  function register(varname) {\n    var state = cx.state;\n    cx.marked = \"def\";\n    if (state.context) {\n      if (state.lexical.info == \"var\" && state.context && state.context.block) {\n        // FIXME function decls are also not block scoped\n        var newContext = registerVarScoped(varname, state.context)\n        if (newContext != null) {\n          state.context = newContext\n          return\n        }\n      } else if (!inList(varname, state.localVars)) {\n        state.localVars = new Var(varname, state.localVars)\n        return\n      }\n    }\n    // Fall through means this is global\n    if (parserConfig.globalVars && !inList(varname, state.globalVars))\n      state.globalVars = new Var(varname, state.globalVars)\n  }\n  function registerVarScoped(varname, context) {\n    if (!context) {\n      return null\n    } else if (context.block) {\n      var inner = registerVarScoped(varname, context.prev)\n      if (!inner) return null\n      if (inner == context.prev) return context\n      return new Context(inner, context.vars, true)\n    } else if (inList(varname, context.vars)) {\n      return context\n    } else {\n      return new Context(context.prev, new Var(varname, context.vars), false)\n    }\n  }\n\n  function isModifier(name) {\n    return name == \"public\" || name == \"private\" || name == \"protected\" || name == \"abstract\" || name == \"readonly\"\n  }\n\n  // Combinators\n\n  function Context(prev, vars, block) { this.prev = prev; this.vars = vars; this.block = block }\n  function Var(name, next) { this.name = name; this.next = next }\n\n  var defaultVars = new Var(\"this\", new Var(\"arguments\", null))\n  function pushcontext() {\n    cx.state.context = new Context(cx.state.context, cx.state.localVars, false)\n    cx.state.localVars = defaultVars\n  }\n  function pushblockcontext() {\n    cx.state.context = new Context(cx.state.context, cx.state.localVars, true)\n    cx.state.localVars = null\n  }\n  function popcontext() {\n    cx.state.localVars = cx.state.context.vars\n    cx.state.context = cx.state.context.prev\n  }\n  popcontext.lex = true\n  function pushlex(type, info) {\n    var result = function() {\n      var state = cx.state, indent = state.indented;\n      if (state.lexical.type == \"stat\") indent = state.lexical.indented;\n      else for (var outer = state.lexical; outer && outer.type == \")\" && outer.align; outer = outer.prev)\n        indent = outer.indented;\n      state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);\n    };\n    result.lex = true;\n    return result;\n  }\n  function poplex() {\n    var state = cx.state;\n    if (state.lexical.prev) {\n      if (state.lexical.type == \")\")\n        state.indented = state.lexical.indented;\n      state.lexical = state.lexical.prev;\n    }\n  }\n  poplex.lex = true;\n\n  function expect(wanted) {\n    function exp(type) {\n      if (type == wanted) return cont();\n      else if (wanted == \";\" || type == \"}\" || type == \")\" || type == \"]\") return pass();\n      else return cont(exp);\n    };\n    return exp;\n  }\n\n  function statement(type, value) {\n    if (type == \"var\") return cont(pushlex(\"vardef\", value), vardef, expect(\";\"), poplex);\n    if (type == \"keyword a\") return cont(pushlex(\"form\"), parenExpr, statement, poplex);\n    if (type == \"keyword b\") return cont(pushlex(\"form\"), statement, poplex);\n    if (type == \"keyword d\") return cx.stream.match(/^\\s*$/, false) ? cont() : cont(pushlex(\"stat\"), maybeexpression, expect(\";\"), poplex);\n    if (type == \"debugger\") return cont(expect(\";\"));\n    if (type == \"{\") return cont(pushlex(\"}\"), pushblockcontext, block, poplex, popcontext);\n    if (type == \";\") return cont();\n    if (type == \"if\") {\n      if (cx.state.lexical.info == \"else\" && cx.state.cc[cx.state.cc.length - 1] == poplex)\n        cx.state.cc.pop()();\n      return cont(pushlex(\"form\"), parenExpr, statement, poplex, maybeelse);\n    }\n    if (type == \"function\") return cont(functiondef);\n    if (type == \"for\") return cont(pushlex(\"form\"), forspec, statement, poplex);\n    if (type == \"class\" || (isTS && value == \"interface\")) {\n      cx.marked = \"keyword\"\n      return cont(pushlex(\"form\", type == \"class\" ? type : value), className, poplex)\n    }\n    if (type == \"variable\") {\n      if (isTS && value == \"declare\") {\n        cx.marked = \"keyword\"\n        return cont(statement)\n      } else if (isTS && (value == \"module\" || value == \"enum\" || value == \"type\") && cx.stream.match(/^\\s*\\w/, false)) {\n        cx.marked = \"keyword\"\n        if (value == \"enum\") return cont(enumdef);\n        else if (value == \"type\") return cont(typename, expect(\"operator\"), typeexpr, expect(\";\"));\n        else return cont(pushlex(\"form\"), pattern, expect(\"{\"), pushlex(\"}\"), block, poplex, poplex)\n      } else if (isTS && value == \"namespace\") {\n        cx.marked = \"keyword\"\n        return cont(pushlex(\"form\"), expression, statement, poplex)\n      } else if (isTS && value == \"abstract\") {\n        cx.marked = \"keyword\"\n        return cont(statement)\n      } else {\n        return cont(pushlex(\"stat\"), maybelabel);\n      }\n    }\n    if (type == \"switch\") return cont(pushlex(\"form\"), parenExpr, expect(\"{\"), pushlex(\"}\", \"switch\"), pushblockcontext,\n                                      block, poplex, poplex, popcontext);\n    if (type == \"case\") return cont(expression, expect(\":\"));\n    if (type == \"default\") return cont(expect(\":\"));\n    if (type == \"catch\") return cont(pushlex(\"form\"), pushcontext, maybeCatchBinding, statement, poplex, popcontext);\n    if (type == \"export\") return cont(pushlex(\"stat\"), afterExport, poplex);\n    if (type == \"import\") return cont(pushlex(\"stat\"), afterImport, poplex);\n    if (type == \"async\") return cont(statement)\n    if (value == \"@\") return cont(expression, statement)\n    return pass(pushlex(\"stat\"), expression, expect(\";\"), poplex);\n  }\n  function maybeCatchBinding(type) {\n    if (type == \"(\") return cont(funarg, expect(\")\"))\n  }\n  function expression(type, value) {\n    return expressionInner(type, value, false);\n  }\n  function expressionNoComma(type, value) {\n    return expressionInner(type, value, true);\n  }\n  function parenExpr(type) {\n    if (type != \"(\") return pass()\n    return cont(pushlex(\")\"), expression, expect(\")\"), poplex)\n  }\n  function expressionInner(type, value, noComma) {\n    if (cx.state.fatArrowAt == cx.stream.start) {\n      var body = noComma ? arrowBodyNoComma : arrowBody;\n      if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, expect(\"=>\"), body, popcontext);\n      else if (type == \"variable\") return pass(pushcontext, pattern, expect(\"=>\"), body, popcontext);\n    }\n\n    var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;\n    if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);\n    if (type == \"function\") return cont(functiondef, maybeop);\n    if (type == \"class\" || (isTS && value == \"interface\")) { cx.marked = \"keyword\"; return cont(pushlex(\"form\"), classExpression, poplex); }\n    if (type == \"keyword c\" || type == \"async\") return cont(noComma ? expressionNoComma : expression);\n    if (type == \"(\") return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex, maybeop);\n    if (type == \"operator\" || type == \"spread\") return cont(noComma ? expressionNoComma : expression);\n    if (type == \"[\") return cont(pushlex(\"]\"), arrayLiteral, poplex, maybeop);\n    if (type == \"{\") return contCommasep(objprop, \"}\", null, maybeop);\n    if (type == \"quasi\") return pass(quasi, maybeop);\n    if (type == \"new\") return cont(maybeTarget(noComma));\n    if (type == \"import\") return cont(expression);\n    return cont();\n  }\n  function maybeexpression(type) {\n    if (type.match(/[;\\}\\)\\],]/)) return pass();\n    return pass(expression);\n  }\n\n  function maybeoperatorComma(type, value) {\n    if (type == \",\") return cont(expression);\n    return maybeoperatorNoComma(type, value, false);\n  }\n  function maybeoperatorNoComma(type, value, noComma) {\n    var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;\n    var expr = noComma == false ? expression : expressionNoComma;\n    if (type == \"=>\") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);\n    if (type == \"operator\") {\n      if (/\\+\\+|--/.test(value) || isTS && value == \"!\") return cont(me);\n      if (isTS && value == \"<\" && cx.stream.match(/^([^>]|<.*?>)*>\\s*\\(/, false))\n        return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, me);\n      if (value == \"?\") return cont(expression, expect(\":\"), expr);\n      return cont(expr);\n    }\n    if (type == \"quasi\") { return pass(quasi, me); }\n    if (type == \";\") return;\n    if (type == \"(\") return contCommasep(expressionNoComma, \")\", \"call\", me);\n    if (type == \".\") return cont(property, me);\n    if (type == \"[\") return cont(pushlex(\"]\"), maybeexpression, expect(\"]\"), poplex, me);\n    if (isTS && value == \"as\") { cx.marked = \"keyword\"; return cont(typeexpr, me) }\n    if (type == \"regexp\") {\n      cx.state.lastType = cx.marked = \"operator\"\n      cx.stream.backUp(cx.stream.pos - cx.stream.start - 1)\n      return cont(expr)\n    }\n  }\n  function quasi(type, value) {\n    if (type != \"quasi\") return pass();\n    if (value.slice(value.length - 2) != \"${\") return cont(quasi);\n    return cont(expression, continueQuasi);\n  }\n  function continueQuasi(type) {\n    if (type == \"}\") {\n      cx.marked = \"string-2\";\n      cx.state.tokenize = tokenQuasi;\n      return cont(quasi);\n    }\n  }\n  function arrowBody(type) {\n    findFatArrow(cx.stream, cx.state);\n    return pass(type == \"{\" ? statement : expression);\n  }\n  function arrowBodyNoComma(type) {\n    findFatArrow(cx.stream, cx.state);\n    return pass(type == \"{\" ? statement : expressionNoComma);\n  }\n  function maybeTarget(noComma) {\n    return function(type) {\n      if (type == \".\") return cont(noComma ? targetNoComma : target);\n      else if (type == \"variable\" && isTS) return cont(maybeTypeArgs, noComma ? maybeoperatorNoComma : maybeoperatorComma)\n      else return pass(noComma ? expressionNoComma : expression);\n    };\n  }\n  function target(_, value) {\n    if (value == \"target\") { cx.marked = \"keyword\"; return cont(maybeoperatorComma); }\n  }\n  function targetNoComma(_, value) {\n    if (value == \"target\") { cx.marked = \"keyword\"; return cont(maybeoperatorNoComma); }\n  }\n  function maybelabel(type) {\n    if (type == \":\") return cont(poplex, statement);\n    return pass(maybeoperatorComma, expect(\";\"), poplex);\n  }\n  function property(type) {\n    if (type == \"variable\") {cx.marked = \"property\"; return cont();}\n  }\n  function objprop(type, value) {\n    if (type == \"async\") {\n      cx.marked = \"property\";\n      return cont(objprop);\n    } else if (type == \"variable\" || cx.style == \"keyword\") {\n      cx.marked = \"property\";\n      if (value == \"get\" || value == \"set\") return cont(getterSetter);\n      var m // Work around fat-arrow-detection complication for detecting typescript typed arrow params\n      if (isTS && cx.state.fatArrowAt == cx.stream.start && (m = cx.stream.match(/^\\s*:\\s*/, false)))\n        cx.state.fatArrowAt = cx.stream.pos + m[0].length\n      return cont(afterprop);\n    } else if (type == \"number\" || type == \"string\") {\n      cx.marked = jsonldMode ? \"property\" : (cx.style + \" property\");\n      return cont(afterprop);\n    } else if (type == \"jsonld-keyword\") {\n      return cont(afterprop);\n    } else if (isTS && isModifier(value)) {\n      cx.marked = \"keyword\"\n      return cont(objprop)\n    } else if (type == \"[\") {\n      return cont(expression, maybetype, expect(\"]\"), afterprop);\n    } else if (type == \"spread\") {\n      return cont(expressionNoComma, afterprop);\n    } else if (value == \"*\") {\n      cx.marked = \"keyword\";\n      return cont(objprop);\n    } else if (type == \":\") {\n      return pass(afterprop)\n    }\n  }\n  function getterSetter(type) {\n    if (type != \"variable\") return pass(afterprop);\n    cx.marked = \"property\";\n    return cont(functiondef);\n  }\n  function afterprop(type) {\n    if (type == \":\") return cont(expressionNoComma);\n    if (type == \"(\") return pass(functiondef);\n  }\n  function commasep(what, end, sep) {\n    function proceed(type, value) {\n      if (sep ? sep.indexOf(type) > -1 : type == \",\") {\n        var lex = cx.state.lexical;\n        if (lex.info == \"call\") lex.pos = (lex.pos || 0) + 1;\n        return cont(function(type, value) {\n          if (type == end || value == end) return pass()\n          return pass(what)\n        }, proceed);\n      }\n      if (type == end || value == end) return cont();\n      if (sep && sep.indexOf(\";\") > -1) return pass(what)\n      return cont(expect(end));\n    }\n    return function(type, value) {\n      if (type == end || value == end) return cont();\n      return pass(what, proceed);\n    };\n  }\n  function contCommasep(what, end, info) {\n    for (var i = 3; i < arguments.length; i++)\n      cx.cc.push(arguments[i]);\n    return cont(pushlex(end, info), commasep(what, end), poplex);\n  }\n  function block(type) {\n    if (type == \"}\") return cont();\n    return pass(statement, block);\n  }\n  function maybetype(type, value) {\n    if (isTS) {\n      if (type == \":\" || value == \"in\") return cont(typeexpr);\n      if (value == \"?\") return cont(maybetype);\n    }\n  }\n  function mayberettype(type) {\n    if (isTS && type == \":\") {\n      if (cx.stream.match(/^\\s*\\w+\\s+is\\b/, false)) return cont(expression, isKW, typeexpr)\n      else return cont(typeexpr)\n    }\n  }\n  function isKW(_, value) {\n    if (value == \"is\") {\n      cx.marked = \"keyword\"\n      return cont()\n    }\n  }\n  function typeexpr(type, value) {\n    if (value == \"keyof\" || value == \"typeof\" || value == \"infer\") {\n      cx.marked = \"keyword\"\n      return cont(value == \"typeof\" ? expressionNoComma : typeexpr)\n    }\n    if (type == \"variable\" || value == \"void\") {\n      cx.marked = \"type\"\n      return cont(afterType)\n    }\n    if (value == \"|\" || value == \"&\") return cont(typeexpr)\n    if (type == \"string\" || type == \"number\" || type == \"atom\") return cont(afterType);\n    if (type == \"[\") return cont(pushlex(\"]\"), commasep(typeexpr, \"]\", \",\"), poplex, afterType)\n    if (type == \"{\") return cont(pushlex(\"}\"), commasep(typeprop, \"}\", \",;\"), poplex, afterType)\n    if (type == \"(\") return cont(commasep(typearg, \")\"), maybeReturnType, afterType)\n    if (type == \"<\") return cont(commasep(typeexpr, \">\"), typeexpr)\n  }\n  function maybeReturnType(type) {\n    if (type == \"=>\") return cont(typeexpr)\n  }\n  function typeprop(type, value) {\n    if (type == \"variable\" || cx.style == \"keyword\") {\n      cx.marked = \"property\"\n      return cont(typeprop)\n    } else if (value == \"?\" || type == \"number\" || type == \"string\") {\n      return cont(typeprop)\n    } else if (type == \":\") {\n      return cont(typeexpr)\n    } else if (type == \"[\") {\n      return cont(expect(\"variable\"), maybetype, expect(\"]\"), typeprop)\n    } else if (type == \"(\") {\n      return pass(functiondecl, typeprop)\n    }\n  }\n  function typearg(type, value) {\n    if (type == \"variable\" && cx.stream.match(/^\\s*[?:]/, false) || value == \"?\") return cont(typearg)\n    if (type == \":\") return cont(typeexpr)\n    if (type == \"spread\") return cont(typearg)\n    return pass(typeexpr)\n  }\n  function afterType(type, value) {\n    if (value == \"<\") return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, afterType)\n    if (value == \"|\" || type == \".\" || value == \"&\") return cont(typeexpr)\n    if (type == \"[\") return cont(typeexpr, expect(\"]\"), afterType)\n    if (value == \"extends\" || value == \"implements\") { cx.marked = \"keyword\"; return cont(typeexpr) }\n    if (value == \"?\") return cont(typeexpr, expect(\":\"), typeexpr)\n  }\n  function maybeTypeArgs(_, value) {\n    if (value == \"<\") return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, afterType)\n  }\n  function typeparam() {\n    return pass(typeexpr, maybeTypeDefault)\n  }\n  function maybeTypeDefault(_, value) {\n    if (value == \"=\") return cont(typeexpr)\n  }\n  function vardef(_, value) {\n    if (value == \"enum\") {cx.marked = \"keyword\"; return cont(enumdef)}\n    return pass(pattern, maybetype, maybeAssign, vardefCont);\n  }\n  function pattern(type, value) {\n    if (isTS && isModifier(value)) { cx.marked = \"keyword\"; return cont(pattern) }\n    if (type == \"variable\") { register(value); return cont(); }\n    if (type == \"spread\") return cont(pattern);\n    if (type == \"[\") return contCommasep(eltpattern, \"]\");\n    if (type == \"{\") return contCommasep(proppattern, \"}\");\n  }\n  function proppattern(type, value) {\n    if (type == \"variable\" && !cx.stream.match(/^\\s*:/, false)) {\n      register(value);\n      return cont(maybeAssign);\n    }\n    if (type == \"variable\") cx.marked = \"property\";\n    if (type == \"spread\") return cont(pattern);\n    if (type == \"}\") return pass();\n    if (type == \"[\") return cont(expression, expect(']'), expect(':'), proppattern);\n    return cont(expect(\":\"), pattern, maybeAssign);\n  }\n  function eltpattern() {\n    return pass(pattern, maybeAssign)\n  }\n  function maybeAssign(_type, value) {\n    if (value == \"=\") return cont(expressionNoComma);\n  }\n  function vardefCont(type) {\n    if (type == \",\") return cont(vardef);\n  }\n  function maybeelse(type, value) {\n    if (type == \"keyword b\" && value == \"else\") return cont(pushlex(\"form\", \"else\"), statement, poplex);\n  }\n  function forspec(type, value) {\n    if (value == \"await\") return cont(forspec);\n    if (type == \"(\") return cont(pushlex(\")\"), forspec1, poplex);\n  }\n  function forspec1(type) {\n    if (type == \"var\") return cont(vardef, forspec2);\n    if (type == \"variable\") return cont(forspec2);\n    return pass(forspec2)\n  }\n  function forspec2(type, value) {\n    if (type == \")\") return cont()\n    if (type == \";\") return cont(forspec2)\n    if (value == \"in\" || value == \"of\") { cx.marked = \"keyword\"; return cont(expression, forspec2) }\n    return pass(expression, forspec2)\n  }\n  function functiondef(type, value) {\n    if (value == \"*\") {cx.marked = \"keyword\"; return cont(functiondef);}\n    if (type == \"variable\") {register(value); return cont(functiondef);}\n    if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, mayberettype, statement, popcontext);\n    if (isTS && value == \"<\") return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex, functiondef)\n  }\n  function functiondecl(type, value) {\n    if (value == \"*\") {cx.marked = \"keyword\"; return cont(functiondecl);}\n    if (type == \"variable\") {register(value); return cont(functiondecl);}\n    if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, mayberettype, popcontext);\n    if (isTS && value == \"<\") return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex, functiondecl)\n  }\n  function typename(type, value) {\n    if (type == \"keyword\" || type == \"variable\") {\n      cx.marked = \"type\"\n      return cont(typename)\n    } else if (value == \"<\") {\n      return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex)\n    }\n  }\n  function funarg(type, value) {\n    if (value == \"@\") cont(expression, funarg)\n    if (type == \"spread\") return cont(funarg);\n    if (isTS && isModifier(value)) { cx.marked = \"keyword\"; return cont(funarg); }\n    if (isTS && type == \"this\") return cont(maybetype, maybeAssign)\n    return pass(pattern, maybetype, maybeAssign);\n  }\n  function classExpression(type, value) {\n    // Class expressions may have an optional name.\n    if (type == \"variable\") return className(type, value);\n    return classNameAfter(type, value);\n  }\n  function className(type, value) {\n    if (type == \"variable\") {register(value); return cont(classNameAfter);}\n  }\n  function classNameAfter(type, value) {\n    if (value == \"<\") return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex, classNameAfter)\n    if (value == \"extends\" || value == \"implements\" || (isTS && type == \",\")) {\n      if (value == \"implements\") cx.marked = \"keyword\";\n      return cont(isTS ? typeexpr : expression, classNameAfter);\n    }\n    if (type == \"{\") return cont(pushlex(\"}\"), classBody, poplex);\n  }\n  function classBody(type, value) {\n    if (type == \"async\" ||\n        (type == \"variable\" &&\n         (value == \"static\" || value == \"get\" || value == \"set\" || (isTS && isModifier(value))) &&\n         cx.stream.match(/^\\s+[\\w$\\xa1-\\uffff]/, false))) {\n      cx.marked = \"keyword\";\n      return cont(classBody);\n    }\n    if (type == \"variable\" || cx.style == \"keyword\") {\n      cx.marked = \"property\";\n      return cont(isTS ? classfield : functiondef, classBody);\n    }\n    if (type == \"number\" || type == \"string\") return cont(isTS ? classfield : functiondef, classBody);\n    if (type == \"[\")\n      return cont(expression, maybetype, expect(\"]\"), isTS ? classfield : functiondef, classBody)\n    if (value == \"*\") {\n      cx.marked = \"keyword\";\n      return cont(classBody);\n    }\n    if (isTS && type == \"(\") return pass(functiondecl, classBody)\n    if (type == \";\" || type == \",\") return cont(classBody);\n    if (type == \"}\") return cont();\n    if (value == \"@\") return cont(expression, classBody)\n  }\n  function classfield(type, value) {\n    if (value == \"?\") return cont(classfield)\n    if (type == \":\") return cont(typeexpr, maybeAssign)\n    if (value == \"=\") return cont(expressionNoComma)\n    var context = cx.state.lexical.prev, isInterface = context && context.info == \"interface\"\n    return pass(isInterface ? functiondecl : functiondef)\n  }\n  function afterExport(type, value) {\n    if (value == \"*\") { cx.marked = \"keyword\"; return cont(maybeFrom, expect(\";\")); }\n    if (value == \"default\") { cx.marked = \"keyword\"; return cont(expression, expect(\";\")); }\n    if (type == \"{\") return cont(commasep(exportField, \"}\"), maybeFrom, expect(\";\"));\n    return pass(statement);\n  }\n  function exportField(type, value) {\n    if (value == \"as\") { cx.marked = \"keyword\"; return cont(expect(\"variable\")); }\n    if (type == \"variable\") return pass(expressionNoComma, exportField);\n  }\n  function afterImport(type) {\n    if (type == \"string\") return cont();\n    if (type == \"(\") return pass(expression);\n    return pass(importSpec, maybeMoreImports, maybeFrom);\n  }\n  function importSpec(type, value) {\n    if (type == \"{\") return contCommasep(importSpec, \"}\");\n    if (type == \"variable\") register(value);\n    if (value == \"*\") cx.marked = \"keyword\";\n    return cont(maybeAs);\n  }\n  function maybeMoreImports(type) {\n    if (type == \",\") return cont(importSpec, maybeMoreImports)\n  }\n  function maybeAs(_type, value) {\n    if (value == \"as\") { cx.marked = \"keyword\"; return cont(importSpec); }\n  }\n  function maybeFrom(_type, value) {\n    if (value == \"from\") { cx.marked = \"keyword\"; return cont(expression); }\n  }\n  function arrayLiteral(type) {\n    if (type == \"]\") return cont();\n    return pass(commasep(expressionNoComma, \"]\"));\n  }\n  function enumdef() {\n    return pass(pushlex(\"form\"), pattern, expect(\"{\"), pushlex(\"}\"), commasep(enummember, \"}\"), poplex, poplex)\n  }\n  function enummember() {\n    return pass(pattern, maybeAssign);\n  }\n\n  function isContinuedStatement(state, textAfter) {\n    return state.lastType == \"operator\" || state.lastType == \",\" ||\n      isOperatorChar.test(textAfter.charAt(0)) ||\n      /[,.]/.test(textAfter.charAt(0));\n  }\n\n  function expressionAllowed(stream, state, backUp) {\n    return state.tokenize == tokenBase &&\n      /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\\[{}\\(,;:]|=>)$/.test(state.lastType) ||\n      (state.lastType == \"quasi\" && /\\{\\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0))))\n  }\n\n  // Interface\n\n  return {\n    startState: function(basecolumn) {\n      var state = {\n        tokenize: tokenBase,\n        lastType: \"sof\",\n        cc: [],\n        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, \"block\", false),\n        localVars: parserConfig.localVars,\n        context: parserConfig.localVars && new Context(null, null, false),\n        indented: basecolumn || 0\n      };\n      if (parserConfig.globalVars && typeof parserConfig.globalVars == \"object\")\n        state.globalVars = parserConfig.globalVars;\n      return state;\n    },\n\n    token: function(stream, state) {\n      if (stream.sol()) {\n        if (!state.lexical.hasOwnProperty(\"align\"))\n          state.lexical.align = false;\n        state.indented = stream.indentation();\n        findFatArrow(stream, state);\n      }\n      if (state.tokenize != tokenComment && stream.eatSpace()) return null;\n      var style = state.tokenize(stream, state);\n      if (type == \"comment\") return style;\n      state.lastType = type == \"operator\" && (content == \"++\" || content == \"--\") ? \"incdec\" : type;\n      return parseJS(state, style, type, content, stream);\n    },\n\n    indent: function(state, textAfter) {\n      if (state.tokenize == tokenComment) return CodeMirror.Pass;\n      if (state.tokenize != tokenBase) return 0;\n      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical, top\n      // Kludge to prevent 'maybelse' from blocking lexical scope pops\n      if (!/^\\s*else\\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {\n        var c = state.cc[i];\n        if (c == poplex) lexical = lexical.prev;\n        else if (c != maybeelse) break;\n      }\n      while ((lexical.type == \"stat\" || lexical.type == \"form\") &&\n             (firstChar == \"}\" || ((top = state.cc[state.cc.length - 1]) &&\n                                   (top == maybeoperatorComma || top == maybeoperatorNoComma) &&\n                                   !/^[,\\.=+\\-*:?[\\(]/.test(textAfter))))\n        lexical = lexical.prev;\n      if (statementIndent && lexical.type == \")\" && lexical.prev.type == \"stat\")\n        lexical = lexical.prev;\n      var type = lexical.type, closing = firstChar == type;\n\n      if (type == \"vardef\") return lexical.indented + (state.lastType == \"operator\" || state.lastType == \",\" ? lexical.info.length + 1 : 0);\n      else if (type == \"form\" && firstChar == \"{\") return lexical.indented;\n      else if (type == \"form\") return lexical.indented + indentUnit;\n      else if (type == \"stat\")\n        return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);\n      else if (lexical.info == \"switch\" && !closing && parserConfig.doubleIndentSwitch != false)\n        return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? indentUnit : 2 * indentUnit);\n      else if (lexical.align) return lexical.column + (closing ? 0 : 1);\n      else return lexical.indented + (closing ? 0 : indentUnit);\n    },\n\n    electricInput: /^\\s*(?:case .*?:|default:|\\{|\\})$/,\n    blockCommentStart: jsonMode ? null : \"/*\",\n    blockCommentEnd: jsonMode ? null : \"*/\",\n    blockCommentContinue: jsonMode ? null : \" * \",\n    lineComment: jsonMode ? null : \"//\",\n    fold: \"brace\",\n    closeBrackets: \"()[]{}''\\\"\\\"``\",\n\n    helperType: jsonMode ? \"json\" : \"javascript\",\n    jsonldMode: jsonldMode,\n    jsonMode: jsonMode,\n\n    expressionAllowed: expressionAllowed,\n\n    skipExpression: function(state) {\n      var top = state.cc[state.cc.length - 1]\n      if (top == expression || top == expressionNoComma) state.cc.pop()\n    }\n  };\n});\n\nCodeMirror.registerHelper(\"wordChars\", \"javascript\", /[\\w$]/);\n\nCodeMirror.defineMIME(\"text/javascript\", \"javascript\");\nCodeMirror.defineMIME(\"text/ecmascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/javascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/x-javascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/ecmascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/json\", {name: \"javascript\", json: true});\nCodeMirror.defineMIME(\"application/x-json\", {name: \"javascript\", json: true});\nCodeMirror.defineMIME(\"application/ld+json\", {name: \"javascript\", jsonld: true});\nCodeMirror.defineMIME(\"text/typescript\", { name: \"javascript\", typescript: true });\nCodeMirror.defineMIME(\"application/typescript\", { name: \"javascript\", typescript: true });\n\n});\n"],"sourceRoot":""}